<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yol</title>
  
  <subtitle>睡到自然醒，悠然见南山~</subtitle>
  <link href="https://xu-zi-kang.github.io/atom.xml" rel="self"/>
  
  <link href="https://xu-zi-kang.github.io/"/>
  <updated>2024-06-30T07:59:58.351Z</updated>
  <id>https://xu-zi-kang.github.io/</id>
  
  <author>
    <name>yol</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【工作】众云网基础知识</title>
    <link href="https://xu-zi-kang.github.io/2024/06/30/%E3%80%90%E5%B7%A5%E4%BD%9C%E3%80%91%E4%BC%97%E4%BA%91%E7%BD%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://xu-zi-kang.github.io/2024/06/30/%E3%80%90%E5%B7%A5%E4%BD%9C%E3%80%91%E4%BC%97%E4%BA%91%E7%BD%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2024-06-30T07:58:39.000Z</published>
    <updated>2024-06-30T07:59:58.351Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、-行业发展现状学习"><a href="#一、-行业发展现状学习" class="headerlink" title="一、 行业发展现状学习"></a>一、 行业发展现状学习</h2><p>目标：了解网络安全、数据流动治理行业的市场现状及未来发展趋势，包括竞争对手、上下 游产业链、细分的市场领域 </p><p>参考资料：见附件 </p><p>（1）网络安全到底在干啥？聊聊网络知识体系与行业分类（B 站视频 35min） </p><p>[【陈鑫杰】网络安全到底在干啥？搞网络安全就是搞“黑客技术”？聊聊网络安全的知识体系与行业分类_哔哩哔哩_bilibili](<a href="https://www.bilibili.com/video/BV14k4y1z7mx/?share_source=copy_web&vd_sourc">https://www.bilibili.com/video/BV14k4y1z7mx/?share_source=copy_web&amp;vd_sourc</a> e&#x3D;38ac0d7b9ea28ecf28b1f2f521d02689)</p><p>国际安全等级：ISO2700x</p><p>国内：网络安全等级保护2.0（等保）</p><p><strong>网络安全的分类：</strong></p><p>网络安全：1.防火墙（网闸） 2.入侵检测&#x2F;防御 3.VPN网关&#x2F;身份认证&#x2F;流量审计</p><p>Web安全：1.前段安全（XSS） 2.后端安全（文件上传&#x2F;WebShell） 3.数据安全（SQL注入） 4.通信安全（HTTP、HTTPS）</p><p>移动安全：1.IOS安全 2.Android安全 3.小程序安全</p><p>云计算安全：1.平台安全 2.容器安全 3.虚拟机安全 4.云主机安全 5.云安全（DDOS）</p><p>桌面安全：1.Windows安全 2.MacOS安全 3.Linux安全</p><p>数据&#x2F;大数据安全、物联网安全、工控安全、无线安全</p><p>（2）2023 年网络与信息安全行业全景图 </p><p>（3）《2023 年中国网络安全市场与企业竞争力分析》报告 </p><p>（4）《中国网络安全产业分析报告（2023 年）》 </p><p>（5）《2023 中国网络安全产品用户调查报告》完整版 </p><p>建议：通过百度收集资料进行学习，也可去 B 站找相关视频，形成专业名词库</p><h2 id="二、-行业基础知识学习"><a href="#二、-行业基础知识学习" class="headerlink" title="二、 行业基础知识学习"></a>二、 行业基础知识学习</h2><p>目标：了解日常工作中涉及到的行业名词的基本含义，形成初步的认知 </p><h3 id="1-信息安全、数据安全、网络安全、数据流动、数据库"><a href="#1-信息安全、数据安全、网络安全、数据流动、数据库" class="headerlink" title="1.信息安全、数据安全、网络安全、数据流动、数据库"></a>1.信息安全、数据安全、网络安全、数据流动、数据库</h3><p><strong>信息安全</strong>：指保护信息及其相关系统免受未经授权的访问、使用、披露、破坏、修改或毁坏的实践。其目标是确保信息的机密性、完整性和可用性。</p><p><strong>数据安全</strong>：专注于保护数据免受恶意行为、泄露、修改和破坏。数据安全策略包括加密、备份、访问控制和数据丢失预防（DLP）等措施。</p><p><strong>网络安全</strong>：涵盖保护计算机网络及其服务免受未经授权的访问、滥用和攻击的措施。网络安全包括防火墙、入侵检测系统（IDS）、防病毒软件和虚拟专用网络（VPN）等技术。</p><p><strong>数据流动</strong>：指数据在不同网络节点之间的传输过程。数据流动的安全涉及保护数据在传输过程中的机密性和完整性，防止数据被窃取或篡改。</p><p><strong>数据库</strong>：是一个组织系统化存储、管理和检索数据的集合。数据库安全涉及保护数据库免受未经授权的访问和恶意活动，确保数据的安全性和隐私。</p><h3 id="2-拓扑图、交换机、路由器、服务器、防火墙、计算机病毒"><a href="#2-拓扑图、交换机、路由器、服务器、防火墙、计算机病毒" class="headerlink" title="2.拓扑图、交换机、路由器、服务器、防火墙、计算机病毒"></a>2.拓扑图、交换机、路由器、服务器、防火墙、计算机病毒</h3><p><strong>拓扑图</strong>：描述网络设备和连接结构的图形表示。它展示了网络中各设备（如计算机、交换机、路由器）的相对位置和连接方式，帮助网络管理员设计和管理网络。</p><p><strong>交换机</strong>：一种用于网络的设备，能够在局域网（LAN）中将数据包在网络设备之间转发。交换机通过MAC地址表来决定数据包的转发路径，提高了网络效率和安全性。</p><p><strong>路由器</strong>：用于连接不同网络，并在它们之间转发数据包的设备。路由器通过路由表和路由协议决定数据包的最佳传输路径，通常用于连接局域网（LAN）和广域网（WAN）。</p><p><strong>服务器</strong>：提供网络服务的计算机或软件系统。服务器可以提供各种服务，如网页托管、电子邮件、文件存储和数据库管理。服务器安全涉及保护服务器免受攻击，确保其正常运行和数据的安全性。</p><p><strong>防火墙</strong>：一种网络安全设备或软件，用于监控和控制进出网络的流量，基于预定的安全规则来允许或阻止数据包的传输。防火墙是保护网络免受外部威胁的重要工具。</p><p><strong>计算机病毒</strong>：一种恶意软件程序，能够复制自身并感染计算机系统。病毒通常通过执行恶意代码来破坏系统、窃取信息或对用户造成其他损害。计算机病毒的防护措施包括防病毒软件和安全习惯。</p><h3 id="3-勒索软件、广域网、局域网、等保、社会工程攻击、钓鱼邮件"><a href="#3-勒索软件、广域网、局域网、等保、社会工程攻击、钓鱼邮件" class="headerlink" title="3.勒索软件、广域网、局域网、等保、社会工程攻击、钓鱼邮件"></a>3.勒索软件、广域网、局域网、等保、社会工程攻击、钓鱼邮件</h3><p><strong>勒索软件</strong>：一种恶意软件，感染计算机后加密受害者的文件或锁定系统，要求支付赎金以恢复访问。勒索软件攻击通常通过钓鱼邮件、恶意下载等途径传播。</p><p><strong>广域网（WAN）</strong>：覆盖较大地理范围的网络，可以连接城市、国家甚至全球的计算机网络。广域网使用路由器和公共通信链路（如电话线、光纤）来实现远距离的数据传输。</p><p><strong>局域网（LAN）</strong>：覆盖有限区域（如家庭、办公室或校园）的网络，用于连接相对较近的计算机和设备。局域网通常使用交换机和以太网线缆实现高速数据传输。</p><p><strong>等保（等级保护）</strong>：指信息系统安全等级保护制度，根据系统的重要性和风险等级对信息系统进行分级保护，确保系统达到相应的安全保护级别。等保制度在中国是信息安全管理的重要标准。</p><p><strong>社会工程攻击</strong>：通过心理操纵和欺骗手段获取机密信息或执行某些操作的攻击方式。社会工程攻击常见形式包括冒充、恐吓、伪装信任关系等。</p><p><strong>钓鱼邮件</strong>：一种常见的社会工程攻击，通过伪装成合法机构发送欺骗性邮件，引诱收件人泄露敏感信息（如用户名、密码、信用卡号）或点击恶意链接。防范钓鱼邮件需要提高用户的安全意识和使用反钓鱼技术。</p><h3 id="4-黑帽白帽、HW-行动、业务系统（ERP、OA、CRM、MES、DB、SVN、SCADA-等）"><a href="#4-黑帽白帽、HW-行动、业务系统（ERP、OA、CRM、MES、DB、SVN、SCADA-等）" class="headerlink" title="4.黑帽白帽、HW 行动、业务系统（ERP、OA、CRM、MES、DB、SVN、SCADA 等）"></a>4.黑帽白帽、HW 行动、业务系统（ERP、OA、CRM、MES、DB、SVN、SCADA 等）</h3><h4 id="1-黑帽白帽"><a href="#1-黑帽白帽" class="headerlink" title="(1)黑帽白帽"></a>(1)黑帽白帽</h4><p><strong>黑帽：</strong>专门研究木马病毒，寻找系统漏洞，以个人利益出发攻击系统或站点</p><p><strong>白帽：</strong>负责维护网络安全，一般在大公司里会有</p><p>灰帽：介于黑帽和白帽之间的角色，没有恶意，在未经允许的情况下入侵查看系统</p><p>红帽：爱国的中国黑客</p><h4 id="2-HW-行动"><a href="#2-HW-行动" class="headerlink" title="(2)HW 行动"></a>(2)HW 行动</h4><p>网络安全攻防战。分红队和蓝队，蓝队为防守方，红队为攻击方</p><h4 id="3-业务系统"><a href="#3-业务系统" class="headerlink" title="(3)业务系统"></a>(3)业务系统</h4><p><strong>ERP：</strong>供应链管理系统，负责货品库存，报价销售等信息管理</p><p><strong>OA：</strong>企业办公自动化系统，负责工作流程管理，信息协作</p><p><strong>CRM：</strong>客户信息管理系统，负责管理客户信息资源，主要用户营销、销售过程中与客户的交互</p><p><strong>MES：</strong>执行制造系统，是一种用于管理和监控制造过程的软件系统。它是在ERP（企业资源计划）和SCADA（监控和数据采集系统）之间的一个中间层，用于实现生产计划的执行和监控。例如投料、生产流程安排、生成品质监控等</p><p><strong>DB：</strong>数据库管理系统</p><p><strong>SVN：</strong>版本管理系统</p><p><strong>SCADA：</strong>监控和数据采集系统，在电力系统中，SCADA系统应用最为广泛，可以对现场的运行设备进行监视和控制，以实现数据采集、设备控制、<a href="https://baike.baidu.com/item/%E6%B5%8B%E9%87%8F/398072?fromModule=lemma_inlink">测量</a>、参数调节以及各类信号报警等各项功能</p><h2 id="四、销售技巧-基础工具"><a href="#四、销售技巧-基础工具" class="headerlink" title="四、销售技巧&#x2F;基础工具"></a>四、销售技巧&#x2F;基础工具</h2><p><strong>销售技巧：</strong></p><ul><li>销售五要素七步法</li></ul><h4 id="五要素"><a href="#五要素" class="headerlink" title="五要素"></a>五要素</h4><ol><li><strong>客户需求</strong>：了解客户的需求是销售的起点，只有清晰了解客户需要什么，才能提供针对性的产品或服务。</li><li><strong>产品优势</strong>：熟悉自己产品或服务的优势和特点，能够在销售过程中突出这些优势，以满足客户需求。</li><li><strong>竞争对手</strong>：了解竞争对手的产品和市场策略，有助于制定更有效的销售策略，赢得客户。</li><li><strong>市场环境</strong>：掌握市场趋势和变化，能够更好地调整销售策略，适应市场需求。</li><li><strong>销售技巧</strong>：熟练掌握各种销售技巧，能够更有效地与客户沟通，达成销售目标。</li></ol><h4 id="七步法"><a href="#七步法" class="headerlink" title="七步法"></a>七步法</h4><ol><li><strong>前期准备</strong>：做好客户信息的收集和产品知识的准备，确保对客户和产品都有充分的了解。</li><li><strong>接触客户</strong>：通过电话、邮件、面谈等方式与客户建立初步联系，介绍自己和公司。</li><li><strong>了解需求</strong>：通过问询和倾听，深入了解客户的需求和痛点，建立信任关系。</li><li><strong>介绍产品</strong>：针对客户需求，详细介绍产品或服务的特点和优势，突出其解决问题的能力。</li><li><strong>应对异议</strong>：针对客户提出的疑问或反对意见，给予专业的解答和回应，化解客户的疑虑。</li><li><strong>达成协议</strong>：在客户认可产品价值后，进行价格谈判和合同签订，最终达成销售协议。</li><li><strong>售后跟进</strong>：销售完成后，进行售后服务和客户跟进，确保客户满意，建立长期合作关系。</li></ol><ul><li>SPIN 销售法</li></ul><h4 id="SPIN-销售法"><a href="#SPIN-销售法" class="headerlink" title="SPIN 销售法"></a>SPIN 销售法</h4><p>SPIN 销售法是一种基于咨询式销售的方法，通过系统化的提问来引导客户发现需求和问题，从而促进销售。SPIN 是四种类型问题的缩写：</p><ol><li><strong>S - Situation（情境问题）</strong>：了解客户的现状和背景，收集基本信息。<ul><li>示例问题：您目前使用的是什么系统？</li></ul></li><li><strong>P - Problem（难点问题）</strong>：识别客户当前面临的问题或困扰，找出潜在需求。<ul><li>示例问题：您觉得目前系统的最大问题是什么？</li></ul></li><li><strong>I - Implication（暗示问题）</strong>：深入挖掘问题带来的影响和后果，让客户意识到问题的严重性。<ul><li>示例问题：这些问题对您的业务产生了哪些影响？</li></ul></li><li><strong>N - Need-Payoff（需求-收益问题）</strong>：引导客户思考解决问题后将获得的好处，激发客户购买动机。<ul><li>示例问题：如果这些问题得到解决，您的业务将会有哪些改善？</li></ul></li></ol><h4 id="SPIN-销售法的应用步骤"><a href="#SPIN-销售法的应用步骤" class="headerlink" title="SPIN 销售法的应用步骤"></a>SPIN 销售法的应用步骤</h4><ol><li><strong>情境分析</strong>：通过情境问题了解客户的现状，获取基本信息，为后续提问打下基础。</li><li><strong>问题挖掘</strong>：通过难点问题识别客户的痛点和需求，建立问题意识。</li><li><strong>影响引导</strong>：通过暗示问题让客户认识到问题的严重性和迫切性，增加需求紧迫感。</li><li><strong>需求激发</strong>：通过需求-收益问题激发客户对解决方案的兴趣和购买意愿，推动销售进程。</li></ol><p>SPIN 销售法的核心在于通过系统化的提问，引导客户自我发现需求和问题，从而更有效地促进销售。相比传统的销售方式，SPIN 更注重客户需求和问题的挖掘，是一种更为客户导向的销售方法。</p><p>以上自行百度学习，<strong>需熟练掌握</strong> </p><p><strong>基础工具</strong>：熟练掌握 Word、Excel、PPT 等工具的使用，<strong>重点学习 PPT</strong> </p><p>顾问式销售技巧</p><p>s-背景问题</p><p>p-通过背景问题确认痛点</p><p>i-暗示性问题，放大痛点</p><p>n-收益回报问题</p><p>常见网络安全产品</p><p><strong>边界安全：</strong></p><p>防火墙：访问控制ACL(源地址、源端口、目的地址、目的端口、动作)、地址转换NAT(将多种业务转换成同一个公网地址)、上传速度的带宽管理(数据上送和下传)、用户认证(三级安全域一般放数据库，服务器。二级安全域一般放静态网站)，低级别的区域想要访问高级别区域，防火墙就要去进行拦截操作(内网渗透)</p><p>抗DDOS、网闸</p><p><strong>应用安全：</strong></p><p>入侵防御系统（IPS）、web应用防火墙（WAF）、负载均衡、上网行为管理</p><p><strong>数据安全：</strong></p><p>数据安全审计系统</p><p><strong>终端安全：</strong></p><p>终端安全管理系统、终端安全准入管理系统</p><p><strong>运维与审计：</strong></p><p>数据安全态势感知平台、漏洞扫描系统、日志审计系统、堡垒机</p><h2 id="五、众云网产品"><a href="#五、众云网产品" class="headerlink" title="五、众云网产品"></a>五、众云网产品</h2><p>软件开发：</p><p>CRM客户信息管理系统</p><p>IT资产管理平台</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、-行业发展现状学习&quot;&gt;&lt;a href=&quot;#一、-行业发展现状学习&quot; class=&quot;headerlink&quot; title=&quot;一、 行业发展现状学习&quot;&gt;&lt;/a&gt;一、 行业发展现状学习&lt;/h2&gt;&lt;p&gt;目标：了解网络安全、数据流动治理行业的市场现状及未来发展趋势，包括竞</summary>
      
    
    
    
    
    <category term="-众云网" scheme="https://xu-zi-kang.github.io/tags/%E4%BC%97%E4%BA%91%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【面试】深圳炬亚科技有限公司</title>
    <link href="https://xu-zi-kang.github.io/2024/04/08/%E3%80%90%E9%9D%A2%E8%AF%95%E3%80%91%E6%B7%B1%E5%9C%B3%E7%82%AC%E4%BA%9A%E7%A7%91%E6%8A%80%E6%9C%89%E9%99%90%E5%85%AC%E5%8F%B8/"/>
    <id>https://xu-zi-kang.github.io/2024/04/08/%E3%80%90%E9%9D%A2%E8%AF%95%E3%80%91%E6%B7%B1%E5%9C%B3%E7%82%AC%E4%BA%9A%E7%A7%91%E6%8A%80%E6%9C%89%E9%99%90%E5%85%AC%E5%8F%B8/</id>
    <published>2024-04-08T10:59:04.000Z</published>
    <updated>2024-04-08T11:06:52.854Z</updated>
    
    <content type="html"><![CDATA[<p><strong>答题要求：以下试题，可任选三题或以上作答。</strong></p><h1 id="1、现在的社会，全民短视频，请从产品经理的角度分析下微视对比快手，抖音的在产品上的差别，您认为微视如何才能从快手，抖音上抢到市场份额？"><a href="#1、现在的社会，全民短视频，请从产品经理的角度分析下微视对比快手，抖音的在产品上的差别，您认为微视如何才能从快手，抖音上抢到市场份额？" class="headerlink" title="1、现在的社会，全民短视频，请从产品经理的角度分析下微视对比快手，抖音的在产品上的差别，您认为微视如何才能从快手，抖音上抢到市场份额？"></a>1、现在的社会，全民短视频，请从产品经理的角度分析下微视对比快手，抖音的在产品上的差别，您认为微视如何才能从快手，抖音上抢到市场份额？</h1><h3 id="回答："><a href="#回答：" class="headerlink" title="回答："></a>回答：</h3><p>快手在视频内容方面比较接地气（用户群体更偏向于农村、中年人），而抖音的用户群体更多的是年轻人，注重的是内容的新颖。</p><p>微视是腾讯旗下产品，腾讯旗下的qq、微信的用户量很大，</p><p>（1）通过这两款平台对微视进行流量扶持和植入，在微信视频&#x2F;qq视频中添加微视视频的内容。</p><p>（2）优化创作激励机制来吸引创作者的加入。</p><p>（3）可以学习采取拼多多平台定期看视频，看满时长可提取现金的机制。 </p><h3 id="ChatGPT："><a href="#ChatGPT：" class="headerlink" title="ChatGPT："></a>ChatGPT：</h3><p>微视、快手和抖音都是短视频平台，但各有侧重点和差异：</p><p>快手强调社区氛围，内容更加接地气，强化用户之间的互动和连接。</p><p>抖音以算法推荐为核心，注重内容的新颖性和娱乐性，拥有较高的用户活跃度和传播效率。</p><p>微视作为腾讯系的产品，拥有QQ、微信等社交平台的流量支持，但相对于快手和抖音，在市场占有率、用户活跃度上有待提升。</p><p>为了从快手、抖音中抢夺市场份额，微视可以采取以下策略：</p><p>利用腾讯生态优势：深化与微信、QQ的整合，比如在微信视频动态中优先推荐微视内容，利用社交关系链推动内容分发。</p><p>差异化内容策略：发掘和培养具有特色的内容创作者和细分领域（如教育、科技、文化艺术等），形成与快手、抖音不同的内容生态。</p><p>创新功能和用户体验：引入创新的互动方式和视频编辑工具，改善用户体验，提高内容创作的便利性和趣味性。</p><p>激励机制：优化创作者激励计划，提供更具竞争力的分成比例、流量扶持等，吸引高质量创作者加入。</p><h1 id="2、假设你是虎牙的产品经理，除了直播打赏以外，您还能从哪些角度为品牌进行变现？"><a href="#2、假设你是虎牙的产品经理，除了直播打赏以外，您还能从哪些角度为品牌进行变现？" class="headerlink" title="2、假设你是虎牙的产品经理，除了直播打赏以外，您还能从哪些角度为品牌进行变现？"></a>2、假设你是虎牙的产品经理，除了直播打赏以外，您还能从哪些角度为品牌进行变现？</h1><h3 id="回答"><a href="#回答" class="headerlink" title="回答"></a>回答</h3><p>（1）  可以在直播中引入品牌赞助，根据产品内容直播定制广告</p><p>（2）  开启直播带货</p><p>（3）  启用会员服务，开通单频道会员的用户可以享受更高的画质，主播专属表情包或者礼物</p><h3 id="ChatGPT：-1"><a href="#ChatGPT：-1" class="headerlink" title="ChatGPT："></a>ChatGPT：</h3><p>作为虎牙的产品经理，除直播打赏外，还可探索以下变现途径：</p><p>广告收入：引入品牌赞助和定制广告，尤其是与直播内容相关的品牌合作。</p><p>电商联动：开展直播带货，特别是与游戏、娱乐、时尚相关的产品销售。</p><p>会员服务：推出更多元化的会员服务，比如高清流、广告免费、专属表情包、直播间特权等。</p><p>内容付费：针对部分高质量内容设置付费观看门槛，如大型比赛、独家访谈等。</p><h1 id="3、假设现在有一个直播产品，真实用户的比例是20-，其余50-为游客，30-为注册但未转化的用户，现在要开发一个VIP直播功能（仅供真实客户使用）以及普通直播的未转化用户专属的开户优惠功能，在技术人力只能开发一个的时候，您会先做哪个？"><a href="#3、假设现在有一个直播产品，真实用户的比例是20-，其余50-为游客，30-为注册但未转化的用户，现在要开发一个VIP直播功能（仅供真实客户使用）以及普通直播的未转化用户专属的开户优惠功能，在技术人力只能开发一个的时候，您会先做哪个？" class="headerlink" title="3、假设现在有一个直播产品，真实用户的比例是20%，其余50%为游客，30%为注册但未转化的用户，现在要开发一个VIP直播功能（仅供真实客户使用）以及普通直播的未转化用户专属的开户优惠功能，在技术人力只能开发一个的时候，您会先做哪个？"></a>3、假设现在有一个直播产品，真实用户的比例是20%，其余50%为游客，30%为注册但未转化的用户，现在要开发一个VIP直播功能（仅供真实客户使用）以及普通直播的未转化用户专属的开户优惠功能，在技术人力只能开发一个的时候，您会先做哪个？</h1><h3 id="回答：-1"><a href="#回答：-1" class="headerlink" title="回答："></a>回答：</h3><p>我会选择先开发为转化用户的专属优惠功能，因为真实用户的比例只占有20%，而为转化的占50%，如果可以将其转化为真实用户这样可以提高真实用户的基数，为后续开放新活动奠定了老用户的基础</p><h3 id="ChatGPT：-2"><a href="#ChatGPT：-2" class="headerlink" title="ChatGPT："></a>ChatGPT：</h3><p>在技术资源有限的情况下，需要在VIP直播功能和未转化用户的开户优惠功能之间做出选择。考虑到真实用户的比例只有20%，优先吸引和转化未转化的用户（占50%）比较紧迫。因此，我会优先开发普通直播的未转化用户专属的开户优惠功能。这不仅可以提升用户转化率，还有助于扩大真实用户基础，为后续推出VIP功能创造更好的基础。</p><h1 id="4、请给我们介绍一下最近一年内使用过印象最深的一个APP？"><a href="#4、请给我们介绍一下最近一年内使用过印象最深的一个APP？" class="headerlink" title="4、请给我们介绍一下最近一年内使用过印象最深的一个APP？"></a>4、请给我们介绍一下最近一年内使用过印象最深的一个APP？</h1><h3 id="回答：-2"><a href="#回答：-2" class="headerlink" title="回答："></a>回答：</h3><p>我使用过印象最深的app是微软的To Do。它是一款任务管理应用，是Microsoft全家桶的工具之一，他最吸引我的点是它可以在苹果、安卓、windows三个平台进行任务同步（对于电脑当很是友好）。还有它可以进行协同任务，在公司可以跟同事之间进行任务的分工合作，也可以查看对方的任务进度。它还可以设置任务提醒，同步到apple的生态。还有是因为他是微软的服务所以不像其他的任务管理软件那样有广告或者会员系统，他是一个完全免费的应用。</p><h1 id="5、假设消费100块可以获得10积分，100积分抽一次，抽奖可得积分、VIP会员、实体书等，需要让大家积极抽奖、获奖相对公平且公司可以获得更多的转化用户（公司可接受成本为2000块）？"><a href="#5、假设消费100块可以获得10积分，100积分抽一次，抽奖可得积分、VIP会员、实体书等，需要让大家积极抽奖、获奖相对公平且公司可以获得更多的转化用户（公司可接受成本为2000块）？" class="headerlink" title="5、假设消费100块可以获得10积分，100积分抽一次，抽奖可得积分、VIP会员、实体书等，需要让大家积极抽奖、获奖相对公平且公司可以获得更多的转化用户（公司可接受成本为2000块）？"></a>5、假设消费100块可以获得10积分，100积分抽一次，抽奖可得积分、VIP会员、实体书等，需要让大家积极抽奖、获奖相对公平且公司可以获得更多的转化用户（公司可接受成本为2000块）？</h1><h3 id="回答：-3"><a href="#回答：-3" class="headerlink" title="回答："></a>回答：</h3><p>（1）可以设置多个奖励等级，除了最后大奖意外可以有多个小奖项来增加用户的积极性从而获得更多的转化用户</p><p>（2）可以设定获取积分的更多途径，例如分享到朋友圈、邀新等操作来增江更多用户量</p><h3 id="ChatGPT：-3"><a href="#ChatGPT：-3" class="headerlink" title="ChatGPT："></a>ChatGPT：</h3><p>要让大家积极参与抽奖，同时确保抽奖公平且公司能获得更多转化用户，可以采用以下策略：</p><p>设置多级奖励：除了大奖外，设置多个小奖，增加中奖机会，鼓励更多用户参与。</p><p>增加积分获取途径：除了消费外，通过参与调研、分享产品到社交媒体、邀请新用户等方式也能获得积分，增加用户互动和参与度。</p><p>透明化抽奖机制：公开抽奖规则和中奖概率，增强用户信任。</p><p>利用限时活动：定期开展积分加倍、特别奖励等限时活动，刺激消费和参与。</p><p>跟踪分析反馈：监控活动效果和用户反馈，及时调整策略以最大化用户参与度和满意度。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;答题要求：以下试题，可任选三题或以上作答。&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;1、现在的社会，全民短视频，请从产品经理的角度分析下微视对比快手，抖音的在产品上的差别，您认为微视如何才能从快手，抖音上抢到市场份额？&quot;&gt;&lt;a href=&quot;#1、现在的社会</summary>
      
    
    
    
    
    <category term="-面试" scheme="https://xu-zi-kang.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>【面试】泰康诺生物科技公司</title>
    <link href="https://xu-zi-kang.github.io/2024/03/31/%E3%80%90%E9%9D%A2%E8%AF%95%E3%80%91%E6%B3%B0%E5%BA%B7%E8%AF%BA%E7%94%9F%E7%89%A9%E7%A7%91%E6%8A%80%E5%85%AC%E5%8F%B8/"/>
    <id>https://xu-zi-kang.github.io/2024/03/31/%E3%80%90%E9%9D%A2%E8%AF%95%E3%80%91%E6%B3%B0%E5%BA%B7%E8%AF%BA%E7%94%9F%E7%89%A9%E7%A7%91%E6%8A%80%E5%85%AC%E5%8F%B8/</id>
    <published>2024-03-31T06:17:25.000Z</published>
    <updated>2024-03-31T07:54:06.458Z</updated>
    
    <content type="html"><![CDATA[<h1 id="U-Net网络结构讲解-语义分割"><a href="#U-Net网络结构讲解-语义分割" class="headerlink" title="U-Net网络结构讲解(语义分割)"></a>U-Net网络结构讲解(语义分割)</h1><p>我来介绍一下U-Net算法，这篇论文主要是针对于生物医学影像这个领域提出的，被广泛应用于各种医学图像分割任务，包括：</p><ul><li>组织和器官分割</li><li>肿瘤检测和分割</li><li>细胞计数和分类</li><li>病变检测</li></ul><p>U-Net网络是一个<code>Encoder</code>-<code>Decoder</code>的结构，<code>Encoder</code>对应的是U型左边的这般部分，也就是我们特征提取下采样的部分，<code>Decoder</code>解码就是右边的这一部分，是通过一系列上采样得到分割图。</p><p><img src="https://jsd.cdn.zzko.cn/gh/Asakushen/pic/2024/03/31/fc3a0b.png" alt="图片"></p><p>​左边的这一部分作者称为<code>contracting path</code>，右边的这一部分作者称之为<code>expansive path</code>，在这幅图当中每一个长条的矩形对应的都是一个特征层，这些箭头每一个对应的都是一种操作，右下角就是每种操作对应的类型。</p><p><img src="https://jsd.cdn.zzko.cn/gh/Asakushen/pic/2024/03/31/42cdff.png" alt="图片"></p><p>我们先从输入开始看一下，这里输入是以572*572的单通道的图像为例的，首先会通过一个卷积层，这个卷积层会跟一个ReLU激活函数。这个卷积层他的布距是为1的，其次它是没有进行Pading的，所以你会发现通过卷积层之后他的高和宽都会减少。</p><p>接下来通过一个下采样：也就是一个<code>max pool</code>，池化为2*2，布距为2。高和宽就会减半，由568变为这里的284，此时channel是没有变化的，还是64。然后在通过卷积层，但是每次下采样之后通过卷积层都会将他的channel翻倍，也就是现在变成了128。。最后的最后由512跳转到了1024。</p><p><img src="https://jsd.cdn.zzko.cn/gh/Asakushen/pic/2024/03/31/ebb573.png" alt="图片"></p><p>这个绿色的箭头是一个上采样，这个上采样采用的就是一个转质卷积，通过这个转质卷积之后，它会将特征层的高和宽都放大两倍（28-54），而channel会减半（1024-512）,</p><p><img src="https://jsd.cdn.zzko.cn/gh/Asakushen/pic/2024/03/31/584df0.png" alt="图片"></p><p>然后注意一下这个灰色的箭头，上面写的是<code>copy and crop</code>，左边的特征层大小是64 * 64大小的，但是我们经过上采样得到的特征层他的高宽高宽56 * 56大小的，很明显现在是没法将他们直接进行一个<code>copy and crop</code>拼接的。那么他将这里的64*64的特征层进行了一个中心裁剪，就是将中间56 * 56的部分裁剪过来，然后再将它们进行一个<code>copy and crop</code>的拼接。然后拼接之后channel就变成1024了，然后再通过两个3 * 3的卷积层将channel调整成512，然后再通过上采样的方式，将特征层的高和宽从52调整为104，</p><p>最后得到388 * 388宽高，通道个数为64的特征层，最后再通过一个灰色的1 * 1的卷积层，他的卷积和的个数是和我们分类的类别个数是一样的，论文中的示例它只有两个类别也就是前景和背景。所以他的卷积和的个数是&#x3D;2的，最后通过它之后我们输出的分割的结果就是一个388 * 388 * 2 的一个分割图，最后通过的这个卷积层是没有ReLU激活函数的。</p><p><img src="https://jsd.cdn.zzko.cn/gh/Asakushen/pic/2024/03/31/15542a.png" alt="图片"></p><p>我们输入的图片大小是572 * 572，但是我们最后得到的分割图的大小是388 * 388的。他不是针对572的分割图，而是只有中间388 * 388那个区域的分割图。</p><p>但是现在主流的实现方式并不是按照原论文当中这种方式实现，而是在这些紫色的卷积层当中加上一个<code>Pading</code>，就是说每次通过3 * 3 的卷积层不会去改变特征层的宽高。并且在卷积和ReLU中间再加上一个BN，也就是<strong>Batch Normalization</strong>。由于加了Pading所以不会改变大小，原来是32 * 32 ，还是32 * 32，然后上采集变为64 * 64，两个都是64 * 64，就可以进行拼接了，所以最后得到的分割图其实也是你传入的图的大小，也就是572 * 572。</p><p>参考链接：<a href="https://www.bilibili.com/video/BV1Vq4y127fB/?spm_id_from=333.337.search-card.all.click&vd_source=32d8b55922ba56abcddb7313cd20ec05">BiliBili-U-Net网络结构讲解</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;U-Net网络结构讲解-语义分割&quot;&gt;&lt;a href=&quot;#U-Net网络结构讲解-语义分割&quot; class=&quot;headerlink&quot; title=&quot;U-Net网络结构讲解(语义分割)&quot;&gt;&lt;/a&gt;U-Net网络结构讲解(语义分割)&lt;/h1&gt;&lt;p&gt;我来介绍一下U-Net算</summary>
      
    
    
    
    
    <category term="-面试" scheme="https://xu-zi-kang.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>【面试】深圳波罗密科技</title>
    <link href="https://xu-zi-kang.github.io/2024/03/29/%E3%80%90%E9%9D%A2%E8%AF%95%E3%80%91%E6%B7%B1%E5%9C%B3%E6%B3%A2%E7%BD%97%E5%AF%86%E7%A7%91%E6%8A%80/"/>
    <id>https://xu-zi-kang.github.io/2024/03/29/%E3%80%90%E9%9D%A2%E8%AF%95%E3%80%91%E6%B7%B1%E5%9C%B3%E6%B3%A2%E7%BD%97%E5%AF%86%E7%A7%91%E6%8A%80/</id>
    <published>2024-03-29T01:29:57.000Z</published>
    <updated>2024-03-31T07:56:53.362Z</updated>
    
    <content type="html"><![CDATA[<p>面试后给我布置了三个问题</p><h1 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h1><p>说一下你对产品经理这个岗位的理解，以及你对未来的规划</p><p>产品的阶段：产品文员-产品专员-产品经理的阶段</p><p><strong>ChatGPT参考</strong>：</p><h3 id="对产品经理岗位的理解"><a href="#对产品经理岗位的理解" class="headerlink" title="对产品经理岗位的理解"></a>对产品经理岗位的理解</h3><ul><li><strong>用户需求的倾听者</strong>：产品经理需要深入理解用户需求，通过市场调研、用户访谈等方式收集用户反馈，识别用户痛点。</li><li><strong>产品愿景的制定者</strong>：基于对用户需求的理解，产品经理需要制定清晰的产品愿景和目标，指导产品开发的整个过程。</li><li><strong>团队协作的推动者</strong>：产品经理要与设计师、工程师等团队成员紧密合作，确保团队朝着共同的目标努力，有效沟通是关键。</li><li><strong>决策和优先级的管理者</strong>：在产品开发过程中，产品经理需要不断做出决策，并管理产品特性的优先级，确保资源有效分配，专注于最有价值的功能。</li></ul><h3 id="对未来的规划"><a href="#对未来的规划" class="headerlink" title="对未来的规划"></a>对未来的规划</h3><ul><li><strong>深化产品知识和技能</strong>：计划通过阅读相关书籍、参加行业会议和在线课程，不断深化对产品管理理论和实践的了解。</li><li><strong>增强技术理解能力</strong>：虽然产品经理不一定要精通编程，但理解技术的基础和限制对产品设计至关重要。计划通过学习基础编程知识和技术框架，增强与技术团队的沟通效率。</li><li><strong>提升用户体验设计能力</strong>：用户体验是产品成功的关键，计划通过实践项目和学习最佳设计实践，提升对用户体验设计的理解和应用能力。</li><li><strong>建立人脉网络</strong>：行业联系对于了解市场趋势、寻找合作机会和职业发展都非常重要。计划通过参与行业活动和社交平台，积极建立和维护人脉网络。</li><li><strong>实践经验的积累</strong>：理论知识的学习需要通过实践来巩固。计划通过实习、参与项目等方式，积累实际操作经验，理解产品从构思到市场推出的全过程。</li></ul><p>对于未来，我希望能够在产品经理的道路上不断进步，从一个初入行的实习生成长为能够独立负责产品线的资深产品经理。在这个过程中，我认为最重要的是保持对用户需求的敏锐洞察力，持续学习新知识和技能，以及积极寻求挑战，通过实践经验的积累不断提高自己的产品管理能力。</p><h1 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h1><p>从产品经理的角度说一款你喜欢的App</p><p>答：</p><p><strong>从功能的角度来说</strong>：1.它可以跨平台使用，ios，mac，windows，安卓</p><p>2.可以有云端的记录</p><p>3.清晰展示任务列表，并且可以用户自定义列表</p><p>4.创建任务可以分配子任务，定时任务等功能，提醒</p><p>5.可以有团队写作的功能</p><ol start="6"><li></li></ol><ul><li>作为一名项目经理，我希望能够创建多个任务列表，以便按项目分别管理任务，提高工作效率。</li><li>作为一名学生，我需要为我的任务设置截止日期和提醒，这样我就不会错过任何重要的截止日期。</li><li>作为一个家庭主妇，我希望能够与家人分享购物列表，这样任何人都可以实时更新所需购买的物品。</li></ul><p><strong>首先从市场的角度考虑</strong>：他是微软办公全家桶里面的一个工具，在你有整个套件的时候，可以免费去使用它</p><p><strong>ChatGPT参考</strong>：</p><h3 id="实现逻辑："><a href="#实现逻辑：" class="headerlink" title="实现逻辑："></a>实现逻辑：</h3><p>To Do应用的核心在于其任务管理逻辑，应用需要能够处理包括<strong>创建任务</strong>、<strong>分配任务优先级</strong>、<strong>设置截止日期</strong>、<strong>提醒设置</strong>以及<strong>任务跟踪</strong>等功能。此外，还需要有一个高效的<strong>同步机制</strong>，确保用户在不同设备上看到的任务列表始终保持最新。</p><h3 id="详细功能描述："><a href="#详细功能描述：" class="headerlink" title="详细功能描述："></a>详细功能描述：</h3><ul><li><strong>任务创建和编辑</strong>：用户可以<strong>快速创建任务</strong>，并<strong>添加任务描述</strong>、设置<strong>截止日期</strong>和<strong>优先级</strong>。</li><li><strong>列表管理</strong>：用户可以<strong>创建自定义列表</strong>，并将任务分配到不同的列表中。</li><li><strong>任务协作</strong>：支持<strong>任务共享</strong>和<strong>团队协作</strong>功能，用户可以邀请其他人编辑或查看特定的任务列表。</li><li><strong>提醒和通知</strong>：应用应支持基于时间和位置的<strong>提醒功能</strong>，以确保用户不会错过任何重要任务。</li></ul><h1 id="问题三"><a href="#问题三" class="headerlink" title="问题三"></a>问题三</h1><p>拼多多拉新这个产品模块的，原型设计；需求，产品框架，文档，流程图<br>模仿其功能自己设计一个这样的优惠活动</p><h3 id="产品特性名称：新用户引流模块"><a href="#产品特性名称：新用户引流模块" class="headerlink" title="产品特性名称：新用户引流模块"></a>产品特性名称：新用户引流模块</h3><h3 id="需求描述："><a href="#需求描述：" class="headerlink" title="需求描述："></a>需求描述：</h3><p>该模块旨在通过引入新用户来增加平台的活跃度和用户基数，利用现有用户网络以奖励机制为激励，鼓励现有用户邀请非平台用户加入。此外，该模块还将通过简化注册流程和提供新用户专属福利来增加新用户的转化率。</p><h3 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h3><p>当前电子商务平台面临用户增长放缓的问题。为解决这一挑战，设计了一个以现有用户为基础，通过奖励机制激励他们邀请新用户的模块。该模块不仅能提升用户增长率，还能增强用户对平台的忠诚度。</p><h3 id="相关页面设计："><a href="#相关页面设计：" class="headerlink" title="相关页面设计："></a>相关页面设计：</h3><ul><li><strong>邀请页面</strong>：展示当前的奖励政策，包括邀请新用户可获得的奖励细节，如优惠券、积分等。同时，提供分享邀请链接的按钮，支持通过社交媒体、短信、电子邮件等方式分享。</li><li><strong>注册页面</strong>：为新用户提供一个简化的注册流程，要求填写最少的信息。页面上还将突出显示新用户专属的福利，如首单折扣、新人大礼包等。</li><li><strong>奖励领取页面</strong>：允许用户查看他们通过邀请新用户获得的奖励，并提供一个简单的流程来领取这些奖励。</li></ul><h3 id="用户旅程："><a href="#用户旅程：" class="headerlink" title="用户旅程："></a>用户旅程：</h3><ol><li><strong>现有用户分享邀请</strong>：用户在平台内发现了邀请新用户的奖励活动，并通过社交媒体分享了邀请链接。</li><li><strong>新用户点击链接并注册</strong>：通过链接访问的新用户决定注册平台，享受新用户福利。</li><li><strong>奖励发放</strong>：一旦新用户完成注册，邀请人和新用户都会收到相应的奖励。</li></ol><h3 id="用户故事："><a href="#用户故事：" class="headerlink" title="用户故事："></a>用户故事：</h3><ul><li>作为一个平台老用户，我希望能通过邀请朋友加入来获得奖励，这样我就有更多理由使用这个平台。</li><li>作为一个潜在的新用户，我希望注册过程简单快速，并且能立即获得一些新用户专享的优惠，这样我就更愿意尝试这个平台。</li></ul><h3 id="实现逻辑：-1"><a href="#实现逻辑：-1" class="headerlink" title="实现逻辑："></a>实现逻辑：</h3><ul><li><strong>邀请机制</strong>：系统生成唯一的邀请链接，每个现有用户都可以分享自己的链接。系统跟踪链接的点击和注册情况，以确定奖励的归属。</li><li><strong>奖励机制</strong>：奖励分为两部分，一部分是邀请人的奖励，另一部分是新用户的注册奖励。奖励在满足条件（如新用户完成首次购物）后自动发放。</li><li><strong>注册流程优化</strong>：为了提高转化率，注册流程需要简化，仅要求必要信息，并明确展示新用户将获得的福利。</li></ul><h3 id="详细功能描述：-1"><a href="#详细功能描述：-1" class="headerlink" title="详细功能描述："></a>详细功能描述：</h3><ul><li><strong>邀请链接生成与分享</strong>：系统为每个用户生成唯一邀请码和链接，用户可以通过各种方式分享这个链接。系统需要能够跟踪这些链接的分享、点击和注册情况。</li><li><strong>新用户注册流程</strong>：新用户通过邀请链接访问注册页面，页面上需要清晰展示新用户福利。注册过程中要求的信息要尽量简化，以提高转化率。</li><li><strong>奖励发放机制</strong>：系统根据跟踪到的注册和用户活动自动计算奖励。需要有后台逻辑来验证奖励条件是否满足，并在条件满足时自动发放奖励。a</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;面试后给我布置了三个问题&lt;/p&gt;
&lt;h1 id=&quot;问题一&quot;&gt;&lt;a href=&quot;#问题一&quot; class=&quot;headerlink&quot; title=&quot;问题一&quot;&gt;&lt;/a&gt;问题一&lt;/h1&gt;&lt;p&gt;说一下你对产品经理这个岗位的理解，以及你对未来的规划&lt;/p&gt;
&lt;p&gt;产品的阶段：产品文员-产</summary>
      
    
    
    
    
    <category term="-面试" scheme="https://xu-zi-kang.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>【面试】深圳众云网</title>
    <link href="https://xu-zi-kang.github.io/2024/03/28/%E3%80%90%E9%9D%A2%E8%AF%95%E3%80%91%E6%B7%B1%E5%9C%B3%E4%BC%97%E4%BA%91%E7%BD%91/"/>
    <id>https://xu-zi-kang.github.io/2024/03/28/%E3%80%90%E9%9D%A2%E8%AF%95%E3%80%91%E6%B7%B1%E5%9C%B3%E4%BC%97%E4%BA%91%E7%BD%91/</id>
    <published>2024-03-28T11:03:18.000Z</published>
    <updated>2024-04-15T06:18:36.532Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深圳众云面试"><a href="#深圳众云面试" class="headerlink" title="深圳众云面试"></a>深圳众云面试</h1><h2 id="一-自我介绍"><a href="#一-自我介绍" class="headerlink" title="一.自我介绍"></a>一.自我介绍</h2><p>对售前工程师的理解：链接销售和研发之间的纽带&#x2F;桥梁</p><p>对行业的理解：可以说一下对网络安全行业的看法、对行业前景的可观性。</p><p>对公司的了解：提前去网上了解下你面试的公司，大概就能说出一些了</p><p>专业技能：虽说售前不需要你去敲代码，但是你有些产品类的售前是需要具备产品环境部署能力的，这个时候你可以把你在学校学的一些专业课程挑些来说。另外，售前的工作几乎全部依赖于Office，所以你也可以说说你的Office的熟练程度；</p><p>优缺点：尽量往售前工程师招聘要求的去说你的优点，比如自己的沟通表达能力、文字功底能力、学习理解能力等等；</p><p>职业规划：大部分面试官都会问这个问题吧，分长期和短期的来说下你的职业规划。：想干技术和其他领域交织的，技术➕产品，技术➕销售</p><p><strong>用户大部分技术问题都能代表公司独当一面给出权威解释，是公司技术的代言人，客户信任的专家顾问</strong></p><p><strong>如果发现自己说的话偏离主题了</strong>：所以针对您刚才提出的问题，我是这样考虑的。</p><p><strong>问</strong>：请简单介绍一下你做的项目。当你拿到一个需求之后都会做些什么？怎么处理？哪些步骤？</p><p><strong>讲故事的方式进行回答</strong>：</p><ol><li>做这个事情的背景&#x2F;大前提是什么？你的动机是什么？需求的来源是什么？</li></ol><p>​是为了追逐市场空间，流量增长，变现能力。</p><ol start="2"><li><p>分析了哪些数据？对比了哪些竞品？他们是怎么做的？实际的业务场景和哪些业务人员是怎么样沟通的？</p><p>做了哪些工作？得出了什么样的结论？最后决定是怎么样去做的？</p></li></ol><p>​制作产品的简单介绍以及简单功能—流程</p><p>有自己的chatgpt项目，主要一些问题回答点从用户&#x2F;从公司角度说，为X类用户解决X问题，对公司X价值…….<br>内部：产品规划的本身 老板和业务方 数据分析的需求<br>外部：竞品分析 用户上的反馈</p><hr><p>我将从我的<strong>实习经历</strong>和我<strong>未来的一个规划</strong>，两个方面介绍自己，</p><p>文档能力（<strong>PDR文档</strong>，和博客<strong>md文档</strong>）</p><p>在公司协助产品经理写过PRD文档，根据他的PRD文档画原型图—-ToC挪窝（商场合作，理解用户需求，通过一次次的线下活动进行功能上的迭代—回来开会进行总结）</p><p>博客<strong>md文档</strong>，记录之前面试的一些面经，之前搞程序的一些技术上的总结</p><p>职业规划想做（技术+产品）或者（技术+售前）售前工程师是：链接销售和研发之间的纽带&#x2F;桥梁</p><p>虽说售前不需要你去敲代码，但是你有些产品类的售前是需要具备产品环境部署能力的，这个时候你可以把你在学校学的一些专业课程挑些来说。另外，售前的工作几乎全部依赖于Office，所以你也可以说说你的Office的熟练程度</p><hr><h2 id="二-问题"><a href="#二-问题" class="headerlink" title="二.问题"></a>二.问题</h2><h3 id="1-请介绍一下你对网络安全的理解和认识？"><a href="#1-请介绍一下你对网络安全的理解和认识？" class="headerlink" title="1.请介绍一下你对网络安全的理解和认识？"></a>1.请介绍一下你对网络安全的理解和认识？</h3><p>网络安全是指保护计算机网络和网络资源不受未授权的访问、攻击、盗窃、损害等威胁的技术和实践。它围绕数据的保密性、完整性和可用性展开，旨在确保信息和通信技术系统的安全和稳定运行。网络安全不仅包括防止恶意软件（如病毒、蠕虫、间谍软件）的侵害，还涵盖了数据保护、应用安全、网络服务的安全、以及防止网络攻击（如DDoS攻击、钓鱼、社交工程）等多个方面。</p><h3 id="2-你对网络安全产品和技术有一些了解吗？"><a href="#2-你对网络安全产品和技术有一些了解吗？" class="headerlink" title="2.你对网络安全产品和技术有一些了解吗？"></a>2.你对网络安全产品和技术有一些了解吗？</h3><p>网络安全产品和技术广泛而多样，主要可以分为几大类：</p><ul><li><strong>防火墙和入侵检测系统（IDS&#x2F;IPS）</strong>：用于监控和控制网络流量，阻止未授权的访问和潜在的攻击。</li><li><strong>恶意软件防护软件</strong>：包括杀毒软件、反间谍软件等，用于检测、隔离和清除恶意软件。</li><li><strong>加密技术</strong>：用于保护数据的保密性和完整性，包括传输层安全协议（TLS）、安全套接字层（SSL）、以及各种加密算法。</li><li><strong>身份和访问管理（IAM）</strong>：包括密码管理、多因素认证、权限管理等，用于确保只有授权用户才能访问网络资源。</li><li><strong>安全信息和事件管理（SIEM）</strong>：用于实时监视、分析网络安全事件，帮助企业及时发现和响应安全威胁。</li><li><strong>数据泄露防护（DLP）</strong>：用于防止敏感数据的未授权访问和泄露。</li></ul><h3 id="3-你对网络安全行业的发展趋势有什么看法？"><a href="#3-你对网络安全行业的发展趋势有什么看法？" class="headerlink" title="3.你对网络安全行业的发展趋势有什么看法？"></a>3.你对网络安全行业的发展趋势有什么看法？</h3><ul><li><p><strong>人工智能与机器学习</strong>：随着人工智能和机器学习技术的发展，网络安全产品正在变得更加智能，能够自动识别和响应新出现的威胁。</p></li><li><p><strong>云安全</strong>：随着越来越多的企业采用云计算，云安全成为了一个重要议题。保护云环境的数据和应用，确保云服务的安全，是当前网络安全的一个重要方向。</p></li><li><p><strong>零信任安全模型</strong>：传统的安全模型基于“信任但验证”的原则，而零信任安全模型认为不应默认信任任何内外网络请求，所有访问都需进行严格验证。</p></li><li><p><strong>法规和合规要求的加强</strong>：随着数据保护法规（如欧盟的GDPR、加州的CCPA）的实施，企业在网络安全上的投入增加，以确保合规性。</p></li><li><p><strong>供应链安全</strong>：软件供应链攻击日益频繁，强调了供应链安全的重要性。企业需要确保他们所依赖的第三方服务和组件的安全性。</p><hr></li></ul><h3 id="4-路由器和交换机的区别"><a href="#4-路由器和交换机的区别" class="headerlink" title="4.路由器和交换机的区别"></a>4.路由器和交换机的区别</h3><p>让我们通过一个具体的例子来说明路由器和交换机的区别及它们在网络中的作用：</p><p>假设一个小型企业的网络环境，这个企业有两个部门：市场部和技术部。每个部门都有自己的网络，需要连接多台计算机以及打印机等设备。同时，这两个部门还需要访问互联网以及彼此之间进行数据交换。</p><h4 id="使用交换机构建部门网络"><a href="#使用交换机构建部门网络" class="headerlink" title="使用交换机构建部门网络"></a><strong>使用交换机构建部门网络</strong></h4><p>为了满足每个部门内部设备之间的连接需求，我们可以在每个部门内部使用交换机。交换机允许部门内的所有设备（如计算机和打印机）在同一个局域网（LAN）内相互连接和通信。例如：</p><ul><li><strong>市场部交换机</strong>：连接市场部所有的计算机和打印机。</li><li><strong>技术部交换机</strong>：连接技术部所有的计算机和服务器。</li></ul><p>这样，市场部内部的设备可以自由共享文件和访问打印机，技术部也是如此。交换机通过检查数据包的MAC地址，确保数据准确地从发送者传输到接收者。</p><h4 id="使用路由器连接部门网络并访问互联网"><a href="#使用路由器连接部门网络并访问互联网" class="headerlink" title="使用路由器连接部门网络并访问互联网"></a>使用路由器连接部门网络并访问互联网</h4><p>尽管交换机可以在各个部门内部实现设备的相互连接，但如果要实现部门之间的通信或访问互联网，则需要路由器。路由器可以连接到两个部门的交换机，并将这些局域网（LAN）连接到互联网。同时，路由器还可以控制市场部和技术部之间的数据流动。例如：</p><ul><li><strong>路由器</strong>：连接到市场部交换机和技术部交换机，同时连接到互联网服务提供商（ISP）。它根据IP地址路由数据包，允许两个部门之间以及与互联网之间的通信。</li></ul><p>这种设置允许市场部的员工访问技术部的服务器上的资源，反之亦然。同时，所有部门的员工都可以通过路由器访问互联网，路由器可以提供NAT和防火墙等功能，以保护内部网络免受外部威胁。</p><hr><h3 id="5-网络基础知识"><a href="#5-网络基础知识" class="headerlink" title="5.网络基础知识"></a>5.网络基础知识</h3><p>网络基础知识包括了一系列的概念、技术和协议，它们是构建、理解和管理计算机网络的基石。下面是一些核心的网络基础知识点：</p><h4 id="1-网络的基本概念"><a href="#1-网络的基本概念" class="headerlink" title="1. 网络的基本概念"></a>1. 网络的基本概念</h4><ul><li><strong>网络</strong>：由多台计算机和其他设备通过通信介质（如电缆、电话线、无线信号）连接起来，共享资源（如打印机、文件、互联网连接）的集合。</li><li><strong>互联网</strong>：是全球最大的网络，连接了全世界的计算机网络，使用IP协议（Internet Protocol）进行通信。</li></ul><h4 id="2-OSI七层模型"><a href="#2-OSI七层模型" class="headerlink" title="2. OSI七层模型"></a>2. OSI七层模型</h4><p>为了理解网络通信是如何工作的，OSI（开放系统互连）模型将网络通信分为七个层次：</p><ol><li><strong>物理层</strong>：处理通过物理媒介传输的原始比特流。</li><li><strong>数据链路层</strong>：负责在相邻节点间的可靠传输，如以太网。</li><li><strong>网络层</strong>：处理数据包在网络中的传输，包括路由选择，如IP协议。</li><li><strong>传输层</strong>：负责提供端到端的数据传输服务，如TCP&#x2F;UDP协议。</li><li><strong>会话层</strong>：管理应用程序之间的会话。</li><li><strong>表示层</strong>：确保传输的数据可以被接收方理解，如数据格式转换。</li><li><strong>应用层</strong>：为应用程序提供网络服务，如HTTP、FTP等协议。</li></ol><h4 id="3-IP地址"><a href="#3-IP地址" class="headerlink" title="3. IP地址"></a>3. IP地址</h4><ul><li><strong>IP地址</strong>：是指互联网协议地址，用于在网络中唯一标识一个设备。</li><li>分为IPv4（如192.168.1.1）和IPv6（更长，以支持更多设备）。</li></ul><h4 id="4-子网掩码"><a href="#4-子网掩码" class="headerlink" title="4. 子网掩码"></a>4. 子网掩码</h4><ul><li><strong>子网掩码</strong>：用于划分IP地址的网络部分和主机部分，帮助确定哪些设备在同一个网络上。</li></ul><h4 id="5-路由器与交换机"><a href="#5-路由器与交换机" class="headerlink" title="5. 路由器与交换机"></a>5. 路由器与交换机</h4><ul><li><strong>路由器</strong>：用于连接不同网络，决定数据包的最佳路径。</li><li><strong>交换机</strong>：用于连接同一网络内的设备，通过物理地址（MAC地址）转发数据。</li></ul><h4 id="6-无线网络"><a href="#6-无线网络" class="headerlink" title="6. 无线网络"></a>6. 无线网络</h4><ul><li><strong>Wi-Fi</strong>：一种无线网络技术，允许设备通过无线信号连接到局域网或互联网。</li></ul><h4 id="7-网络协议"><a href="#7-网络协议" class="headerlink" title="7. 网络协议"></a>7. 网络协议</h4><ul><li><strong>TCP&#x2F;IP</strong>：一套互联网通信协议，包括IP（定位和路由）和TCP（提供可靠的字节流服务）。</li><li><strong>HTTP&#x2F;HTTPS</strong>：超文本传输协议，用于Web浏览器和服务器之间的通信；HTTPS是加密的HTTP版本。</li><li><strong>FTP</strong>：文件传输协议，用于在网络上的计算机之间传输文件。</li><li><strong>DNS</strong>：域名系统，将易于记忆的域名转换为IP地址。</li></ul><h4 id="8-网络安全"><a href="#8-网络安全" class="headerlink" title="8. 网络安全"></a>8. 网络安全</h4><ul><li><strong>防火墙</strong>：网络安全系统，监控和控制进出网络的数据包。</li><li><strong>VPN</strong>：虚拟私人网络，通过加密通道连接远程网络，增加数据传输的安全性。</li></ul><hr><h3 id="三次握手的例子"><a href="#三次握手的例子" class="headerlink" title="三次握手的例子"></a>三次握手的例子</h3><p>假设有一个客户端（比如你的电脑）想要建立与服务器（比如一个网站的服务器）的TCP连接：</p><ol><li><strong>第一次握手</strong>：客户端发送一个SYN包（假设序列号是100）到服务器，表示客户端尝试建立连接。此时，客户端进入SYN_SENT状态。</li><li><strong>第二次握手</strong>：服务器收到客户端的SYN包后，回复一个SYN-ACK包。这个包包含服务器的初始序列号（假设是300）和对客户端序列号的确认（101，即客户端的序列号加1）。此时，服务器进入SYN_RECEIVED状态。</li><li><strong>第三次握手</strong>：客户端收到SYN-ACK包后，发送一个ACK包给服务器，确认号为服务器序列号加1（301）。这个ACK包标志着连接的建立。此时，客户端和服务器都进入ESTABLISHED状态，开始数据传输。</li></ol><h3 id="四次挥手的例子"><a href="#四次挥手的例子" class="headerlink" title="四次挥手的例子"></a>四次挥手的例子</h3><p>在数据传输完成后，如果客户端想要关闭与服务器的连接：</p><ol><li><strong>第一次挥手</strong>：客户端发送一个FIN包给服务器，表示它没有数据要发送了并想要关闭连接。</li><li><strong>第二次挥手</strong>：服务器收到这个FIN包后，发送一个ACK包给客户端，确认收到客户端的终止请求。此时，客户端进入FIN_WAIT_2状态，等待服务器准备好关闭连接。</li><li><strong>第三次挥手</strong>：服务器准备好关闭连接后，它也发送一个FIN包给客户端，请求关闭连接。</li><li><strong>第四次挥手</strong>：客户端收到服务器的FIN包后，回复一个ACK包。此时，客户端进入TIME_WAIT状态。经过一段时间后（这段时间是为了确保服务器接收到了客户端的ACK包），客户端关闭连接。</li></ol><hr><p>售前的工作流程</p><p><img src="https://jsd.cdn.zzko.cn/gh/Asakushen/pic/2024/03/29/8f30e7.png" alt="图片"></p><p><strong>PoC（Proof of Concept）</strong>，即<a href="https://www.zhihu.com/search?q=%E6%A6%82%E5%BF%B5%E9%AA%8C%E8%AF%81&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1216336798%7D">概念验证</a>。通常是企业进行产品选型时或开展外部实施项目前，进行的一种产品或供应商能力验证工作。</p><p>身为三星级酒店服务的人是很多的因此选择一个大品牌有必要的</p><p>农夫山泉的产业链和供应链更完备能及时供货，本地品牌小品牌供货不稳定资金链不稳定</p><hr><h1 id="销售工程师"><a href="#销售工程师" class="headerlink" title="销售工程师"></a>销售工程师</h1><h2 id="1-你认为作为一名优秀的销售，最重要的能力是哪几项-你认为目前自己相对最弱的是哪项-为什么"><a href="#1-你认为作为一名优秀的销售，最重要的能力是哪几项-你认为目前自己相对最弱的是哪项-为什么" class="headerlink" title="1.你认为作为一名优秀的销售，最重要的能力是哪几项?你认为目前自己相对最弱的是哪项?为什么?"></a>1.你认为作为一名优秀的销售，最重要的能力是哪几项?你认为目前自己相对最弱的是哪项?为什么?</h2><p>优秀的销售人员应具备以下几项关键能力：</p><ul><li><strong>沟通能力</strong>：能够清晰、有效地与客户交流，理解客户需求并提供解决方案。</li><li><strong>建立关系的能力</strong>：与客户建立信任和长期关系，了解他们的业务和挑战。</li><li><strong>市场和产品知识</strong>：对所销售的产品和市场有深入理解，以便有效地解答客户问题并提供专业建议。</li><li><strong>解决问题的能力</strong>：能够灵活应对各种销售挑战和客户问题。</li><li><strong>自我驱动与目标导向</strong>：具有高度的自我驱动力，能够设定并达成销售目标。</li></ul><p>个人最弱的能力可能会因人而异，但识别和承认自己的弱点是成长的第一步。例如，如果你认为自己在<strong>建立关系的能力</strong>上相对较弱，可能是因为你觉得难以在短时间内与客户建立深层次的联系，这通常需要时间、耐心和持续的努力。</p><h2 id="2-你好不容易约到了A公司的IT采购负责人王经理谈服务器的购买事宜，并且你提前跟对方再三确认好了时间和参会人员。但是到了约定的会面时间，你发现王经理并没有出席，将和你谈判的是王经理的下属张主管，请问接下来你会怎么做"><a href="#2-你好不容易约到了A公司的IT采购负责人王经理谈服务器的购买事宜，并且你提前跟对方再三确认好了时间和参会人员。但是到了约定的会面时间，你发现王经理并没有出席，将和你谈判的是王经理的下属张主管，请问接下来你会怎么做" class="headerlink" title="2.你好不容易约到了A公司的IT采购负责人王经理谈服务器的购买事宜，并且你提前跟对方再三确认好了时间和参会人员。但是到了约定的会面时间，你发现王经理并没有出席，将和你谈判的是王经理的下属张主管，请问接下来你会怎么做?"></a>2.你好不容易约到了A公司的IT采购负责人王经理谈服务器的购买事宜，并且你提前跟对方再三确认好了时间和参会人员。但是到了约定的会面时间，你发现王经理并没有出席，将和你谈判的是王经理的下属张主管，请问接下来你会怎么做?</h2><p>面对这种情况，首先要保持专业和灵活性。可以采取以下步骤：</p><ul><li><strong>表达理解和灵活性</strong>：向张主管表示理解并表达愿意与他进行讨论的意愿。</li><li><strong>确认张主管的决策权限</strong>：礼貌地询问张主管是否有权做出采购决策或他会将会议结果反馈给王经理。</li><li><strong>适应性展示</strong>：根据张主管的知识水平和关注点调整你的演示和讨论重点。</li><li><strong>安排后续会议</strong>：如果感觉张主管无法做出最终决定，可以提出安排与王经理后续会议的可能性。</li></ul><h2 id="3-年底了，公司要组织客户答谢会，感谢新老客户在过去一年对我们的支持，但是名额有限。你打算邀请自己名下的哪些客户参与-如何邀请"><a href="#3-年底了，公司要组织客户答谢会，感谢新老客户在过去一年对我们的支持，但是名额有限。你打算邀请自己名下的哪些客户参与-如何邀请" class="headerlink" title="3.年底了，公司要组织客户答谢会，感谢新老客户在过去一年对我们的支持，但是名额有限。你打算邀请自己名下的哪些客户参与?如何邀请?"></a>3.年底了，公司要组织客户答谢会，感谢新老客户在过去一年对我们的支持，但是名额有限。你打算邀请自己名下的哪些客户参与?如何邀请?</h2><ul><li><strong>选择客户</strong>：选择对公司业务有重大贡献的客户，以及那些有潜力在未来增加业务量的客户。</li><li><strong>个性化邀请</strong>：通过个性化的邀请函或直接电话联系来邀请他们，表达对他们过去支持的感激之情，同时说明活动的意义和期待他们的参与。</li></ul><h2 id="4-你的上级给了你一份电话清单，上面有500个客户的联系方式，他要求你在接下来的3天内，打完这500个电话。请问接下来你会怎么做"><a href="#4-你的上级给了你一份电话清单，上面有500个客户的联系方式，他要求你在接下来的3天内，打完这500个电话。请问接下来你会怎么做" class="headerlink" title="4.你的上级给了你一份电话清单，上面有500个客户的联系方式，他要求你在接下来的3天内，打完这500个电话。请问接下来你会怎么做?"></a>4.你的上级给了你一份电话清单，上面有500个客户的联系方式，他要求你在接下来的3天内，打完这500个电话。请问接下来你会怎么做?</h2><ul><li><strong>时间管理</strong>：将500个电话分成3天完成，每天约166个电话，规划每天的时间段。</li><li><strong>分类优先</strong>：根据客户的重要性和紧急程度对名单进行分类，优先联系最重要的客户。</li><li><strong>简化沟通</strong>：预先准备一个简洁明了的沟通模板，确保每个电话都能高效传达核心信息。</li></ul><h2 id="5-请分享一件你觉得很有成就感的事情，以及你从中的收获是什么"><a href="#5-请分享一件你觉得很有成就感的事情，以及你从中的收获是什么" class="headerlink" title="5.请分享一件你觉得很有成就感的事情，以及你从中的收获是什么?"></a>5.请分享一件你觉得很有成就感的事情，以及你从中的收获是什么?</h2><p>分享一件具有个人成就感的事情，以及从中学到的经验或收获，可以帮助反映个人的价值观和工作态度。这个例子应当根据个人经历来选择。</p><h2 id="6-如果大学时光可以重来一次，你最希望改变的是什么"><a href="#6-如果大学时光可以重来一次，你最希望改变的是什么" class="headerlink" title="6.如果大学时光可以重来一次，你最希望改变的是什么?"></a>6.如果大学时光可以重来一次，你最希望改变的是什么?</h2><p>许多人希望能在大学时光做出一些改变，如更多参与课外活动、建立更广泛的社交网络或专注于某个特定领域的深入学习。反思希望改变的方面有助于个人成长和未来规划。</p><h2 id="7-对于销售这份工作，除了工作经验不足，你还有哪些可预见的困难"><a href="#7-对于销售这份工作，除了工作经验不足，你还有哪些可预见的困难" class="headerlink" title="7.对于销售这份工作，除了工作经验不足，你还有哪些可预见的困难?"></a>7.对于销售这份工作，除了工作经验不足，你还有哪些可预见的困难?</h2><p>除了工作经验不足之外，销售人员可能面临的困难包括高强度的工作压力、保持与客户的持续关系、不断变化的市场和产品知识的更新等。面对这些挑战，持续学习和适应变化是关键。</p><p>yol:<br>ToB和ToC的区别</p><p>yol:<br>决策权的不同</p><p>yol:<br>tob的中间人的利益是不大的，最重要的是解决问题</p><p>yol:<br>三层决策人：需求方，技术方。高层</p><p>yol:<br>了解企业的发展需求</p><p>yol:<br>决策流程，付款流程</p><p>yol:<br>对于忠诚度来说，ToB的复购效果会更好</p><p>更需要销售对行业比较理解</p><p>两个问题：报错价格了，该怎么办，解决：中心放在产品，能给你解决什么样的需求</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;深圳众云面试&quot;&gt;&lt;a href=&quot;#深圳众云面试&quot; class=&quot;headerlink&quot; title=&quot;深圳众云面试&quot;&gt;&lt;/a&gt;深圳众云面试&lt;/h1&gt;&lt;h2 id=&quot;一-自我介绍&quot;&gt;&lt;a href=&quot;#一-自我介绍&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
    <category term="-面试" scheme="https://xu-zi-kang.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>【面试】面试回答流程</title>
    <link href="https://xu-zi-kang.github.io/2024/03/20/%E3%80%90%E9%9D%A2%E8%AF%95%E3%80%91%E9%9D%A2%E8%AF%95%E5%9B%9E%E7%AD%94%E6%B5%81%E7%A8%8B/"/>
    <id>https://xu-zi-kang.github.io/2024/03/20/%E3%80%90%E9%9D%A2%E8%AF%95%E3%80%91%E9%9D%A2%E8%AF%95%E5%9B%9E%E7%AD%94%E6%B5%81%E7%A8%8B/</id>
    <published>2024-03-20T13:36:51.000Z</published>
    <updated>2024-03-20T13:57:49.940Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-你还有什么问题想问的吗？"><a href="#1-你还有什么问题想问的吗？" class="headerlink" title="1.你还有什么问题想问的吗？"></a>1.你还有什么问题想问的吗？</h1><p><strong>您觉得我是否符合这个岗位的预期？</strong></p><p><strong>交流的还不错</strong>：</p><ol><li>如果我有幸任职咱们公司，我的岗位具体会负责哪些内容？</li><li>需要跟公司的哪些人哪些部门进行工作的对接？公司现在的发展重心是在哪里？</li><li>未来发展方向的重点会放在哪里？</li><li>能介绍一下公司当前的业务和产品的侧重点吗？</li><li>团队规模？</li></ol><hr><p><strong>交流的不行</strong>：</p><ol><li>您觉得我今天有哪些不足，感觉您也是特别有经验的所以也特别想听听您的建议。</li><li>您觉得我对于这个岗位还有哪些差距？并且您觉得我在这个岗位上都要重点提升哪些方面？</li></ol><h1 id="2-自我介绍的思路"><a href="#2-自我介绍的思路" class="headerlink" title="2.自我介绍的思路"></a>2.自我介绍的思路</h1><p><strong>如果发现自己说的话偏离主题了</strong>：所以针对您刚才提出的问题，我是这样考虑的。</p><p><strong>问</strong>：请简单介绍一下你做的项目。当你拿到一个需求之后都会做些什么？怎么处理？哪些步骤？</p><p><strong>讲故事的方式进行回答</strong>：</p><ol><li>做这个事情的背景&#x2F;大前提是什么？你的动机是什么？需求的来源是什么？</li></ol><p>​是为了追逐市场空间，流量增长，变现能力。</p><ol start="2"><li><p>分析了哪些数据？对比了哪些竞品？他们是怎么做的？实际的业务场景和哪些业务人员是怎么样沟通的？</p><p>做了哪些工作？得出了什么样的结论？最后决定是怎么样去做的？</p></li></ol><p>​制作产品的简单介绍以及简单功能—流程</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-你还有什么问题想问的吗？&quot;&gt;&lt;a href=&quot;#1-你还有什么问题想问的吗？&quot; class=&quot;headerlink&quot; title=&quot;1.你还有什么问题想问的吗？&quot;&gt;&lt;/a&gt;1.你还有什么问题想问的吗？&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;您觉得我是否符合这个岗位的预</summary>
      
    
    
    
    
    <category term="-面试" scheme="https://xu-zi-kang.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>【hexo】评论系统总结</title>
    <link href="https://xu-zi-kang.github.io/2024/03/18/%E3%80%90hexo%E3%80%91%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/"/>
    <id>https://xu-zi-kang.github.io/2024/03/18/%E3%80%90hexo%E3%80%91%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/</id>
    <published>2024-03-18T09:13:47.000Z</published>
    <updated>2024-03-18T13:14:02.745Z</updated>
    
    <content type="html"><![CDATA[<hr><p>我的主要参考借鉴了：Twikoo 评论系统<a href="https://nickxu.me/2022/02/19/Hexo-Butterfly-%E5%BB%BA%E7%AB%99%E6%8C%87%E5%8D%97%EF%BC%88%E5%9B%9B%EF%BC%89Twikoo-%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/">相关教程</a></p><p>在搭建的过程中我遇到的一些问题：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">comments:</span></span><br><span class="line">  <span class="comment"># Up to two comments system, the first will be shown as default</span></span><br><span class="line">  <span class="comment"># Choose: Disqus/Disqusjs/Livere/Gitalk/Valine/Waline/Utterances/Facebook Comments/Twikoo/Giscus/Remark42/Artalk</span></span><br><span class="line">  <span class="attr">use:</span> <span class="string">Twikoo</span> <span class="comment"># Valine,Disqus</span></span><br><span class="line">  <span class="attr">text:</span> <span class="literal">true</span> <span class="comment"># Display the comment name next to the button</span></span><br><span class="line">  <span class="comment"># lazyload: The comment system will be load when comment element enters the browser&#x27;s viewport.</span></span><br><span class="line">  <span class="comment"># If you set it to true, the comment count will be invalid</span></span><br><span class="line">  <span class="attr">lazyload:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">count:</span> <span class="literal">false</span> <span class="comment"># Display comment count in post&#x27;s top_img</span></span><br><span class="line">  <span class="attr">card_post_count:</span> <span class="literal">false</span> <span class="comment"># Display comment count in Home Page</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># Twikoo</span></span><br><span class="line"><span class="comment"># https://github.com/imaegoo/twikoo</span></span><br><span class="line"><span class="attr">twikoo:</span></span><br><span class="line">  <span class="attr">envId:</span> <span class="string">https://twikoo.yolus.top/</span></span><br><span class="line">  <span class="attr">region:</span> <span class="string">ap-shanghai</span></span><br><span class="line">  <span class="attr">visitor:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">option:</span></span><br></pre></td></tr></table></figure><p>在填写自己twikoo的<code>envId</code>时，最开始填写的是自己通过vercel绑定的域名<code>twikoo.yolus.top</code>出现问题页面只显示Comment，并没有下面的twikoo的评论系统框。</p><p><img src="https://jsd.cdn.zzko.cn/gh/Asakushen/pic/2024/03/18/a131e7.png" alt="图片"></p><p>最后发现使用vercel自带的域名是可以解决这个问题，那就说明时我的解析域名遇到了问题，但是在浏览器中却是可以正常访问的</p><p>在最后是因为没有加<code>http://</code>导致无法访问到，O.o????</p><p>最后将<code>envId</code>改为<code>envId: https://twikoo.yolus.top/</code>即可正常访问ovo</p><p><img src="https://jsd.cdn.zzko.cn/gh/Asakushen/pic/2024/03/18/b50623.png" alt="图片"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;我的主要参考借鉴了：Twikoo 评论系统&lt;a href=&quot;https://nickxu.me/2022/02/19/Hexo-Butterfly-%E5%BB%BA%E7%AB%99%E6%8C%87%E5%8D%97%EF%BC%88%E5%9B%9B%EF%</summary>
      
    
    
    
    
    <category term="-hexo" scheme="https://xu-zi-kang.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>【hexo】引入Aplayer播放音乐</title>
    <link href="https://xu-zi-kang.github.io/2024/03/16/%E3%80%90hexo%E3%80%91%E5%BC%95%E5%85%A5Aplayer%E6%92%AD%E6%94%BE%E9%9F%B3%E4%B9%90/"/>
    <id>https://xu-zi-kang.github.io/2024/03/16/%E3%80%90hexo%E3%80%91%E5%BC%95%E5%85%A5Aplayer%E6%92%AD%E6%94%BE%E9%9F%B3%E4%B9%90/</id>
    <published>2024-03-15T16:19:25.000Z</published>
    <updated>2024-03-28T11:21:54.591Z</updated>
    
    <content type="html"><![CDATA[<p>Jelly的文章：<a href="https://www.guodongblog.com/posts/91597d56b19f/#%E6%8F%92%E4%BB%B6%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE">Hexo-Butterfly音乐播放器的添加</a></p><p>Akilarの马卡龙的博客文章： <a href="https://akilar.top/posts/3afa069a/">引入Aplayer播放音乐</a></p><p>Twikoo 评论系统<a href="https://nickxu.me/2022/02/19/Hexo-Butterfly-%E5%BB%BA%E7%AB%99%E6%8C%87%E5%8D%97%EF%BC%88%E5%9B%9B%EF%BC%89Twikoo-%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/">相关教程</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Jelly的文章：&lt;a href=&quot;https://www.guodongblog.com/posts/91597d56b19f/#%E6%8F%92%E4%BB%B6%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%A</summary>
      
    
    
    
    
    <category term="-hexo" scheme="https://xu-zi-kang.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>【hexo】hexo指令</title>
    <link href="https://xu-zi-kang.github.io/2024/03/15/%E3%80%90hexo%E3%80%91hexo%E6%8C%87%E4%BB%A4/"/>
    <id>https://xu-zi-kang.github.io/2024/03/15/%E3%80%90hexo%E3%80%91hexo%E6%8C%87%E4%BB%A4/</id>
    <published>2024-03-15T15:36:17.000Z</published>
    <updated>2024-03-16T04:15:50.862Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-hexo文章的提交"><a href="#一-hexo文章的提交" class="headerlink" title="一.hexo文章的提交"></a>一.hexo文章的提交</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure><p><strong>1.清理网页缓存数据</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure><p><strong>2.</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure><p><strong>3.部署到github</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><p>4.新建一篇文章</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo n 文章名</span><br></pre></td></tr></table></figure><blockquote><p>这是一段引用</p></blockquote><p><em>斜体</em></p><p><img src="https://cdn.jsdelivr.us/gh/Asakushen/pic/2024/03/07/be2bab.png" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello world 代码块</span><br></pre></td></tr></table></figure><p>这是一串代码<code>hello world</code>,你好</p><p>Yol的博客：[点击进入](</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一-hexo文章的提交&quot;&gt;&lt;a href=&quot;#一-hexo文章的提交&quot; class=&quot;headerlink&quot; title=&quot;一.hexo文章的提交&quot;&gt;&lt;/a&gt;一.hexo文章的提交&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="-hexo" scheme="https://xu-zi-kang.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>【面试】一知智能</title>
    <link href="https://xu-zi-kang.github.io/2024/03/15/%E3%80%90%E9%9D%A2%E8%AF%95%E3%80%91%E4%B8%80%E7%9F%A5%E6%99%BA%E8%83%BD/"/>
    <id>https://xu-zi-kang.github.io/2024/03/15/%E3%80%90%E9%9D%A2%E8%AF%95%E3%80%91%E4%B8%80%E7%9F%A5%E6%99%BA%E8%83%BD/</id>
    <published>2024-03-15T14:53:57.000Z</published>
    <updated>2024-03-31T08:00:48.876Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Spring的bean的生命周期，spring-boot的生命周期？"><a href="#1-Spring的bean的生命周期，spring-boot的生命周期？" class="headerlink" title="1.Spring的bean的生命周期，spring boot的生命周期？"></a>1.Spring的bean的生命周期，spring boot的生命周期？</h1><p><strong>理解</strong>：</p><p>1.实例化bean，就是先创建一个bean，可以根据xml或者@bean注解创建</p><p>2.属性赋值阶段，将配置的属性或者依赖注入到bean中，可以通过配置文件或者注解的方式进行实现</p><p>3.初始化阶段，可以通过@PostConstuct或者bean的接口来定义初始化方法</p><p>4.使用阶段，Bean可以被使用</p><p>5.销毁阶段，当应用程序或者容器销毁的时候，调用销毁方法</p><hr><p>实例化，属性赋值，初始化，使用，销毁</p><p>在 Spring 框架中，Bean 的生命周期包括以下几个阶段：</p><ol><li>实例化（Instantiation）：在这个阶段，Spring 容器会根据配置信息或注解创建一个 Bean 的实例。可以通过构造函数实例化或使用工厂方法创建 Bean。</li><li>属性赋值（Population）：在实例化之后，Spring 容器会将配置的属性值或依赖注入到 Bean 实例中。这可以通过 XML 配置、注解或自动装配等方式完成。</li><li>初始化（Initialization）：在属性赋值完成后，Spring 容器会调用 Bean 的初始化方法，进行一些自定义的初始化逻辑。可以通过实现 InitializingBean 接口或使用 @PostConstruct 注解来定义初始化方法。</li><li>使用（In Use）：在初始化完成后，Bean 可以被应用程序使用。它可以响应应用程序的请求，提供所需的功能。</li><li>销毁（Destruction）：在应用程序关闭或容器销毁时，Spring 容器会调用 Bean 的销毁方法，执行一些清理操作。可以通过实现 DisposableBean 接口或使用 @PreDestroy 注解来定义销毁方法。</li></ol><h1 id="2-mysql中的索引都有哪些？你用过哪些索引？怎么样能用索引更快的查询？"><a href="#2-mysql中的索引都有哪些？你用过哪些索引？怎么样能用索引更快的查询？" class="headerlink" title="2.mysql中的索引都有哪些？你用过哪些索引？怎么样能用索引更快的查询？"></a>2.mysql中的索引都有哪些？你用过哪些索引？怎么样能用索引更快的查询？</h1><p>答：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 创建主键索引</span><br><span class="line">CREATE INDEX empno_index ON emp(empno)</span><br><span class="line">-- 其中empno_index为索引名称</span><br><span class="line">-- 在emp这张表的empno列创建</span><br><span class="line">-- 只对创建索引的列有效</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>索引的原理（二叉树）：</p><p><img src="https://jsd.cdn.zzko.cn/gh/Asakushen/pic/2024/03/15/c49483.png" alt="图片"><br>索引的类型：<br>主键索引，主键自动的为主索引(类型Primary key)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create table t1 (</span><br><span class="line">id int primary key,-- 主键，同时也是索引，称为主键索引</span><br><span class="line">name varchar(32));</span><br></pre></td></tr></table></figure><p>唯一索引(UNIQUE)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table t2(</span><br><span class="line">id int unique,-- id是唯一的，同时也是索引，称为unique索引</span><br><span class="line">name varchar(32));</span><br><span class="line">-- 一般是在某列的值不会重复的情况下使用，否则使用普通索引（inedx）</span><br></pre></td></tr></table></figure><p>普通索引(INDEX)</p><p>全文索引 (FULLTEXT)[适用于MyISAM]开发中考虑使用: 全文搜索 Solr 和 ElasticSearch (ES)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 删除索引</span><br><span class="line">DROP INDEX id_index ON t25 -- id_index为索引名称,t25为表名</span><br><span class="line">-- 删除主键索引</span><br><span class="line">ALTER TABLE t26 DROP PRIMARY KEY</span><br></pre></td></tr></table></figure><h1 id="3-请说一下线程和进程的区别？对于一个操作系统来说怎么实现线程和进程"><a href="#3-请说一下线程和进程的区别？对于一个操作系统来说怎么实现线程和进程" class="headerlink" title="3.请说一下线程和进程的区别？对于一个操作系统来说怎么实现线程和进程"></a>3.请说一下线程和进程的区别？对于一个操作系统来说怎么实现线程和进程</h1><p>线程是进程内部，</p><h3 id="进程比作工厂"><a href="#进程比作工厂" class="headerlink" title="进程比作工厂"></a>进程比作工厂</h3><p>想象一个进程像是一个工厂。每个工厂（进程）拥有它自己的资源：建筑物（内存空间）、电力供应（CPU时间）、原料（程序代码和数据）等。每个工厂独立运作，生产产品（执行程序）。工厂之间互不干扰，它们各自管理自己的资源。如果一个工厂发生故障（进程崩溃），它不会影响到其他工厂的运作。</p><h3 id="线程比作工人"><a href="#线程比作工人" class="headerlink" title="线程比作工人"></a>线程比作工人</h3><p>在每个工厂内部，有许多工人（线程）在工作。这些工人共享工厂的资源：他们在同一建筑内工作，使用相同的电力供应和原料。但每个工人负责完成特定的任务（执行特定的代码段）。一些工人可能在装配线上工作（执行计算任务），而其他工人可能在包装部门（处理输入&#x2F;输出任务）。</p><p>工人之间可以轻松地互相沟通（线程间通信），因为他们处于同一个工厂内。他们可以直接交谈，交换工具或材料，而不需要通过外部邮递服务（进程间通信需要更复杂的机制）。</p><p>如果一个工人遇到问题（线程崩溃），这可能会影响到同一工厂内的其他工人，因为他们共享同样的工作环境。在最坏的情况下，这可能导致整个工厂停工（进程崩溃）。</p><h3 id="创建和管理"><a href="#创建和管理" class="headerlink" title="创建和管理"></a>创建和管理</h3><p>创建一个新工厂（进程）需要大量的资源和时间，因为你需要建造建筑物，安装设备，招聘员工等。相比之下，雇佣一个新工人（创建一个线程）成本较低，因为工厂的基础设施已经就绪，只需要为新工人提供一些个人工具和工作空间即可。</p><hr><h2 id="线程的创建方式"><a href="#线程的创建方式" class="headerlink" title="线程的创建方式"></a>线程的创建方式</h2><h3 id="1、继承-Thread-类"><a href="#1、继承-Thread-类" class="headerlink" title="1、继承 Thread 类"></a>1、继承 Thread 类</h3><p>通过继承 Thread 类，并重写它的 run 方法，我们就可以创建一个线程。</p><ul><li>首先定义一个类来继承 Thread 类，重写 run 方法。</li><li>然后创建这个子类对象，并调用 start 方法启动线程。</li></ul><p><img src="https://jsd.cdn.zzko.cn/gh/Asakushen/pic/2024/03/18/021b34.png" alt="图片"></p><h3 id="2、实现-Runnable-接口"><a href="#2、实现-Runnable-接口" class="headerlink" title="2、实现 Runnable 接口"></a>2、实现 Runnable 接口</h3><p>通过实现 Runnable ，并实现 run 方法，也可以创建一个线程。</p><ul><li>首先定义一个类实现 Runnable 接口，并实现 run 方法。</li><li>然后创建 Runnable 实现类对象，并把它作为 target 传入 Thread 的构造函数中</li><li>最后调用 start 方法启动线程。</li></ul><p><img src="https://jsd.cdn.zzko.cn/gh/Asakushen/pic/2024/03/18/c4b9b0.png" alt="图片"></p><h3 id="3、实现-Callable-接口，并结合-Future-实现"><a href="#3、实现-Callable-接口，并结合-Future-实现" class="headerlink" title="3、实现 Callable 接口，并结合 Future 实现"></a>3、实现 Callable 接口，并结合 Future 实现</h3><ul><li>首先定义一个 Callable 的实现类，并实现 call 方法。call 方法是带返回值的。</li><li>然后通过 FutureTask 的构造方法，把这个 Callable 实现类传进去。</li><li>把 FutureTask 作为 Thread 类的 target ，创建 Thread 线程对象。</li><li>通过 FutureTask 的 get 方法获取线程的执行结果。</li></ul><p><img src="https://jsd.cdn.zzko.cn/gh/Asakushen/pic/2024/03/18/f6dfee.png" alt="图片"></p><h3 id="4、通过线程池创建线程"><a href="#4、通过线程池创建线程" class="headerlink" title="4、通过线程池创建线程"></a>4、通过线程池创建线程</h3><p>此处用 JDK 自带的 Executors 来创建线程池对象。</p><ul><li>首先，定一个 Runnable 的实现类，重写 run 方法。</li><li>然后创建一个拥有固定线程数的线程池。</li><li>最后通过 ExecutorService 对象的 execute 方法传入线程对象。</li></ul><p><img src="https://jsd.cdn.zzko.cn/gh/Asakushen/pic/2024/03/18/77b066.png" alt="图片"></p><h1 id="4-你用过哪些数据库连接池？数据库的连接池是怎样运作的？"><a href="#4-你用过哪些数据库连接池？数据库的连接池是怎样运作的？" class="headerlink" title="4.你用过哪些数据库连接池？数据库的连接池是怎样运作的？"></a>4.你用过哪些数据库连接池？数据库的连接池是怎样运作的？</h1><p><img src="https://jsd.cdn.zzko.cn/gh/Asakushen/pic/2024/03/15/c52aaa.png" alt="图片"></p><p><strong>使用方法</strong>：maven引入druid的外部依赖，然后再yml或者是properties中配置数据库连接即可。可以设置最大连接数量</p><h1 id="5-你是如何使用HashMap的？（HashMap与HashTable-的区别）"><a href="#5-你是如何使用HashMap的？（HashMap与HashTable-的区别）" class="headerlink" title="5.你是如何使用HashMap的？（HashMap与HashTable 的区别）"></a>5.你是如何使用HashMap的？（HashMap与HashTable 的区别）</h1><p><strong>理解</strong>：</p><p>HashMap是线程不安全的，里面有containsVaule,containsKey两个方法，而且HashMap的key只能有一个为空，且key对应的多个vaule为空。</p><p>HashTable的线程是安全的，里面有containsVaule，containsKey，contains三种方法。containsVaule和contains功能相同，<strong>适合在多线程并发的情况下使用</strong></p><hr><p><strong>（1</strong>）线程安全性不同</p><p>HashMap是线程不安全的，HashTable是线程安全的，其中的方法大多数是Synchronize的，在多线程并发的情况下，可以直接使用HashTable，但是使用HashMap时必须自己增加同步处理。</p><p><strong>（2</strong>）是否提供<strong>contains</strong>方法</p><p>HashMap只有containsValue和containsKey方法；HashTable有contains、containsKey和containsValue三个方法，其中contains和containsValue方法功能相同。</p><p><strong>（3</strong>）<strong>key</strong>和<strong>value</strong>是否允许<strong>null</strong>值</p><p>Hashtable中，key和value都不允许出现null值。HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。</p><h1 id="6-事务隔离级别"><a href="#6-事务隔离级别" class="headerlink" title="6.事务隔离级别"></a>6.事务隔离级别</h1><p><a href="https://www.bilibili.com/video/BV1pm4y1b74V">视频说明</a></p><p><strong>脏读</strong>：开启两个事务，事务A读到了事务B还没有提交的数据</p><p><strong>幻读</strong>：事务A的操作是修改了数据表中全部的数据行，与此同时事务B插入了一条新的数据，最后事务A去查看数据表的时候发现有一条数据没被修改，就像产生了幻觉一样</p><p><strong>不可重复读</strong>：在一个事物里面执行了两次select语句，在此期间没有执行DDL语句，但是前后查看的数据结果却不相同</p><p><img src="https://jsd.cdn.zzko.cn/gh/Asakushen/pic/2024/03/15/3f4e85.png" alt="图片"></p><h1 id="7、-和-equals的区别"><a href="#7、-和-equals的区别" class="headerlink" title="7、 &#x3D;&#x3D; 和 equals的区别"></a>7、 &#x3D;&#x3D; 和 equals的区别</h1><p>&#x3D;&#x3D; 既可以比较基本数据类型,也可以比较引用数据类型,比较基本数据类型,比较的是具体的值,比较引用数据类型比较是地址值。</p><p>equals只能比较引用数据类型,重写之前比较的是引用数据类型的地址值,重写之后,根据重自定义写的规则，比较的是引用数据类型的内容。</p><hr><p><strong>理解</strong>：</p><p>&#x3D;&#x3D;既可以比较基本数据类型也可以比较引用数据类型，基本数据类型比较的是具体的值，引用数据类型比较的是地址值</p><p>equals只能比较引用数据类型，比较的是引用数据类型地址的值，重写后有可以根据规则比较引用数据类型的内容</p><h1 id="8-String-StringBuffer-和-StringBuilder-的区别是什么"><a href="#8-String-StringBuffer-和-StringBuilder-的区别是什么" class="headerlink" title="8.String StringBuffer 和 StringBuilder 的区别是什么"></a>8.String StringBuffer 和 StringBuilder 的区别是什么</h1><p><strong>理解</strong>：</p><p>StringBuffer对方法加了同步锁，或者对调用方法加了同步锁，线程是安全的<br>StringBuilder是没有对方法加同步锁，线程是不安全的<br>大批量数据单线程用StringBuilder<br>大批量数据多线程用StringBuffer</p><hr><p>String、StringBuilder、StringBuffer是不可变的字符串序列,因此该类不可以被继承，也即没有子类。</p><p><strong>相同点</strong>：</p><p><strong>String类</strong>：</p><p><img src="https://jsd.cdn.zzko.cn/gh/Asakushen/pic/2024/03/16/defdee.png" alt="图片"></p><p><strong>StringBuilder类：</strong></p><p><img src="https://jsd.cdn.zzko.cn/gh/Asakushen/pic/2024/03/16/9a57c0.png" alt="图片"></p><p><strong>StringBuffer类：</strong></p><p><img src="https://jsd.cdn.zzko.cn/gh/Asakushen/pic/2024/03/16/d903c2.png" alt="图片"></p><p><strong>不同点：</strong></p><p>StringBuilder类中的大多数方法没有加Synchronized关键字修饰。而StringBuffer类中的大多数方法都是加了Synchronized关键字修饰，正因为如此，在多线程操作的时候，StringBuffer会比StringBuilder安全，但是其效率会偏低。</p><h1 id="9-Spring-Boot-的核心注解是哪个？它主要由哪几个注解组成的？"><a href="#9-Spring-Boot-的核心注解是哪个？它主要由哪几个注解组成的？" class="headerlink" title="9.Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？"></a>9.Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？</h1><p> 启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：<br><strong>@SpringBootConfiguration</strong>：组合了@Configuration 注解，实现配置文件的功能。<br><strong>@EnableAutoConfiguration</strong>：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源 自动配置功能  <strong>@ComponentScan</strong>：Spring组件扫描。</p><h1 id="10-写出Java的四类八种基本数据类"><a href="#10-写出Java的四类八种基本数据类" class="headerlink" title="10.写出Java的四类八种基本数据类"></a>10.写出Java的四类八种基本数据类</h1><p>整数                      byte short int long</p><p>小数(浮点)             float double</p><p>布尔                      boolean</p><p>字符                      char</p><h2 id="11-String-类的常用方法都有那些？"><a href="#11-String-类的常用方法都有那些？" class="headerlink" title="11.String 类的常用方法都有那些？"></a>11.String 类的常用方法都有那些？</h2><p>equals:比较字符串<br>split:分割字符串<br>subString:截取字符串<br>length:返回字符串长度<br>indexOf:返回指定字符的索引<br>charAt:返回指定索引处的字符<br>replace:字符串的替换<br>trim:去除字符串两端的空白<br>getBytes:返回字符串的byte类型数组<br>toLowerCase:将字符串转换成小写字母<br>toUpperCase:将字符串转换成大写字母</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-Spring的bean的生命周期，spring-boot的生命周期？&quot;&gt;&lt;a href=&quot;#1-Spring的bean的生命周期，spring-boot的生命周期？&quot; class=&quot;headerlink&quot; title=&quot;1.Spring的bean的生命周期，s</summary>
      
    
    
    
    
    <category term="-面试" scheme="https://xu-zi-kang.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>【git】如何查找本机ssh秘钥或文件路径及git拉取代码</title>
    <link href="https://xu-zi-kang.github.io/2024/03/11/%E3%80%90git%E3%80%91%E5%A6%82%E4%BD%95%E6%9F%A5%E6%89%BE%E6%9C%AC%E6%9C%BAssh%E7%A7%98%E9%92%A5%E6%88%96%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E5%8F%8Agit%E6%8B%89%E5%8F%96%E4%BB%A3%E7%A0%81/"/>
    <id>https://xu-zi-kang.github.io/2024/03/11/%E3%80%90git%E3%80%91%E5%A6%82%E4%BD%95%E6%9F%A5%E6%89%BE%E6%9C%AC%E6%9C%BAssh%E7%A7%98%E9%92%A5%E6%88%96%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E5%8F%8Agit%E6%8B%89%E5%8F%96%E4%BB%A3%E7%A0%81/</id>
    <published>2024-03-11T12:54:02.000Z</published>
    <updated>2024-03-16T04:17:59.856Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何查找本机ssh秘钥或文件路径"><a href="#如何查找本机ssh秘钥或文件路径" class="headerlink" title="如何查找本机ssh秘钥或文件路径"></a>如何查找本机ssh秘钥或文件路径</h1><p>在安装Git前提下，打开Git Bash Here</p><p><img src="https://cdn.jsdelivr.us/gh/Asakushen/pic/2024/03/11/15f50d.png" alt="图片"></p><p>1、输入 cd ~&#x2F;.ssh 进入到.ssh 文件夹</p><p>2、输入 ls 查看.ssh 文件夹里面的文件，有 id_rsa id_rsa.pub known_hosts ，ssh秘钥就在 id_rsa.pub文件里</p><p>3、输入vim id_rsa.pub编辑id_rsa.pub文件，直接复制ssh秘钥即可</p><p>4、若需要找秘钥文件路径的话，输入pwd，就可以看到路径了</p><p><img src="https://cdn.jsdelivr.us/gh/Asakushen/pic/2024/03/11/217877.png" alt="图片"></p><h1 id="git拉取克隆代码"><a href="#git拉取克隆代码" class="headerlink" title="git拉取克隆代码"></a>git拉取克隆代码</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//先创建git目录</span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line">//克隆</span><br><span class="line">git clone http://xxx</span><br><span class="line"></span><br><span class="line">//拉取</span><br><span class="line">git pull http://xxx</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;如何查找本机ssh秘钥或文件路径&quot;&gt;&lt;a href=&quot;#如何查找本机ssh秘钥或文件路径&quot; class=&quot;headerlink&quot; title=&quot;如何查找本机ssh秘钥或文件路径&quot;&gt;&lt;/a&gt;如何查找本机ssh秘钥或文件路径&lt;/h1&gt;&lt;p&gt;在安装Git前提下，打开Gi</summary>
      
    
    
    
    
    <category term="-git" scheme="https://xu-zi-kang.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>【面试】天津面试公司问题总结</title>
    <link href="https://xu-zi-kang.github.io/2024/03/09/%E3%80%90%E9%9D%A2%E8%AF%95%E3%80%91%E5%A4%A9%E6%B4%A5%E9%9D%A2%E8%AF%95%E5%85%AC%E5%8F%B8%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>https://xu-zi-kang.github.io/2024/03/09/%E3%80%90%E9%9D%A2%E8%AF%95%E3%80%91%E5%A4%A9%E6%B4%A5%E9%9D%A2%E8%AF%95%E5%85%AC%E5%8F%B8%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</id>
    <published>2024-03-09T15:54:35.000Z</published>
    <updated>2024-03-16T04:36:51.267Z</updated>
    
    <content type="html"><![CDATA[<h1 id="天津创博实习生面试"><a href="#天津创博实习生面试" class="headerlink" title="天津创博实习生面试"></a>天津创博实习生面试</h1><p>问题：</p><h4 id="1-什么是springboot-里面有什么注解"><a href="#1-什么是springboot-里面有什么注解" class="headerlink" title="1.什么是springboot?里面有什么注解?"></a>1.什么是springboot?里面有什么注解?</h4><p>启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下<br>3 个注解：<br>@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。<br>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源<br>自动配置功能： @SpringBootApplication(exclude<br>&#x3D; { DataSourceAutoConfiguration.class })。<br>@ComponentScan：Spring组件扫描。</p><p><strong>笔试题：</strong></p><p><img src="https://cdn.jsdelivr.us/gh/Asakushen/pic/2024/03/09/9a98da.png" alt="图片"></p><p>回答：</p><p>1.public是公用的，谁都可以去调用public。</p><h1 id="天津帮联科技实习生面试"><a href="#天津帮联科技实习生面试" class="headerlink" title="天津帮联科技实习生面试"></a>天津帮联科技实习生面试</h1><p><strong>笔试题：</strong><img src="https://cdn.jsdelivr.us/gh/Asakushen/pic/2024/03/10/4542d7.png" alt="图片"></p><p><img src="https://cdn.jsdelivr.us/gh/Asakushen/pic/2024/03/10/b4b3b2.png" alt="图片"></p><h1 id="天津正成科技"><a href="#天津正成科技" class="headerlink" title="天津正成科技"></a>天津正成科技</h1><p><img src="https://cdn.jsdelivr.us/gh/Asakushen/pic/2024/03/10/9c9dba.png" alt="图片"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;天津创博实习生面试&quot;&gt;&lt;a href=&quot;#天津创博实习生面试&quot; class=&quot;headerlink&quot; title=&quot;天津创博实习生面试&quot;&gt;&lt;/a&gt;天津创博实习生面试&lt;/h1&gt;&lt;p&gt;问题：&lt;/p&gt;
&lt;h4 id=&quot;1-什么是springboot-里面有什么注解&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="-面试" scheme="https://xu-zi-kang.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Typora尝试使用pandoc导入word文档</title>
    <link href="https://xu-zi-kang.github.io/2024/03/09/Typora%E5%B0%9D%E8%AF%95%E5%AF%BC%E5%85%A5pdf%E6%96%87%E6%A1%A3/"/>
    <id>https://xu-zi-kang.github.io/2024/03/09/Typora%E5%B0%9D%E8%AF%95%E5%AF%BC%E5%85%A5pdf%E6%96%87%E6%A1%A3/</id>
    <published>2024-03-09T15:49:23.000Z</published>
    <updated>2024-03-09T15:52:57.164Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本科生毕业论文（设计）</strong></p><p><strong>基于数据可视化的大学生就业管理系统设计与实现</strong></p><table><thead><tr><th>院（系）名称</th><th>：</th><th>计算机科学学院</th></tr></thead><tbody><tr><td>专业名称</td><td>：</td><td>计算机科学与技术</td></tr><tr><td>学生姓名</td><td>：</td><td>许子康</td></tr><tr><td>指导教师</td><td>：</td><td>董鸿燕</td></tr></tbody></table><p>二〇二四年四月十一日</p><p><strong>BACHELOR’S DEGREE THESIS OF WUHAN DONGHU UNIVERSITY</strong></p><p><strong>Design and implementation of college student employment management system based on data visualization</strong></p><p><strong>Candidate：Xu Zikang</strong></p><blockquote><p><strong>Supervisor：Dong Hongyan</strong></p></blockquote><p>Apr 11th, 2024</p><p><strong>独创性声明</strong></p><p>本人声明所呈交的学位论文是我个人在导师的指导下进行的研究工作及取得的研究成果。尽我所知，除文中已标明引用的内容外，本论文不包含任何其他人或集体已经发表或撰写过的研究成果。对本文的研究做出贡献的个人和集体，均已在文中以明确方式标明。本人完全意识到本声明的法律结果由本人承担。</p><p>学位论文作者签名：</p><p>日期： 年 月 日</p><p><strong>学位论文版权使用授权书</strong></p><p>本学位论文作者完全了解学校有关保留、使用学位论文的规定，同意学校保留并向国家有关部门或机构送交论文的复印件和电子版，允许论文被查阅和借阅。本人授权武汉东湖学院可以将本学位论文的全部或部分内容编入有关数据库进行检索，可以采用影印、缩印或扫描等复制手段保存和汇编本学位论文。</p><p>本论文属于 保密口， 在 年解密后适用本授权书。</p><p>不保密🗹</p><p>（请在以上方框内打“√”）</p><p>学位论文作者签名： 指导教师签名：</p><p>日期： 年 月 日 日期： 年 月 日</p><p><strong>基于数据可视化的大学生就业管理系统设计与实现</strong></p><p>摘　要</p><p>在当今信息技术迅猛发展的背景下，数据可视化技术在提升教育管理效率、优化就业指导服务等方面发挥着越来越重要的作用。本文围绕设计和实现一个基于数据可视化的大学生就业管理系统，该系统旨在通过现代化信息技术手段，有效提升高校就业指导的质量与效率。系统架构采用了SpringBoot作为主要的后端开发框架，利用MyBatis-Plus进行高效的数据持久化操作，并通过ECharts技术实现复杂数据的直观可视化展示。此外，系统通过引入Redis缓存技术，显著提高数据处理速度和系统响应能力。为了保证系统数据与用户信息的安全，本系统还集成了Spring Security安全框架，确保了系统的安全性。</p><p>系统主要分为前台的用户模块和后台的管理模块两大部分。前台用户模块面向大学生及教师，提供就业信息查询、简历管理、就业指导等服务，通过数据可视化技术呈现就业数据分析，帮助用户直观了解就业市场趋势，为学生就业决策提供科学依据。后台管理模块主要面向教育管理者，提供学生就业数据的录入、管理、分析等功能，通过数据可视化报表，为管理者提供决策支持，优化就业指导策略。系统的实现不仅提高了就业管理工作的效率和质量，也为学生提供了个性化、多维度的就业服务，具有明显的社会应用价值和广阔的发展前景。</p><p><strong>关键词</strong>：数据可视化；大学生就业管理系统；SpringBoot框架；MyBatis-Plus；ECharts可视化技术</p><p><strong>Design and implementation of college student employment management system based on data visualization</strong></p><p><strong>ABSTRACT</strong></p><p>Under the background of the rapid development of information technology, data visualization technology plays an increasingly important role in improving the efficiency of education management and optimizing employment guidance services. This paper focuses on the design and implementation of a university student employment management system based on data visualization, which aims to effectively improve the quality and efficiency of university employment guidance through modern information technology means. The system architecture adopts SpringBoot as the main back-end development framework, uses MyBatis Plus to carry out efficient data persistence operation, and realizes the visual display of complex data through ECharts technology. In addition, by introducing Redis caching technology, the system significantly improves the data processing speed and system response ability. In order to ensure the Security of system data and user information, the system also integrates the Spring Security framework to ensure the security of the system.</p><p>The system is mainly divided into two parts: the user module and the management module of the background. The front desk user module is aimed at college students and teachers, providing employment information inquiry, resume management, employment guidance and other services. It presents employment data analysis through data visualization technology, helps users intuitively understand the job market trend, and provides scientific basis for students’ employment decision-making. The background management module is mainly for educational administrators, providing functions such as entry, management and analysis of student employment data. Through data visualization reports, it provides decision support for administrators and optimizes employment guidance strategies. The realization of the system not only improves the efficiency and quality of employment management, but also provides personalized and multi-dimensional employment services for students, which has obvious social application value and broad prospects for development.</p><p><strong>Key words</strong>: data visualization; College student employment management system; SpringBoot framework; MyBatis Plus; ECharts visualization technology;</p><p>**<br>**</p><p><strong>目　录</strong></p><p><a href="#%E7%BB%AA-%E8%AE%BA">1　绪　论 <a href="#%E7%BB%AA-%E8%AE%BA">7</a></a></p><p><a href="#%E8%AF%BE%E9%A2%98%E7%9A%84%E6%9D%A5%E6%BA%90%E6%84%8F%E4%B9%89">1.1　课题的来源、意义 <a href="#%E8%AF%BE%E9%A2%98%E7%9A%84%E6%9D%A5%E6%BA%90%E6%84%8F%E4%B9%89">7</a></a></p><p><a href="#%E8%AF%BE%E9%A2%98%E7%9A%84%E7%A0%94%E7%A9%B6%E6%9D%A5%E6%BA%90">1.1.1　课题的研究来源 <a href="#%E8%AF%BE%E9%A2%98%E7%9A%84%E7%A0%94%E7%A9%B6%E6%9D%A5%E6%BA%90">7</a></a></p><p><a href="#%E8%AF%BE%E9%A2%98%E7%9A%84%E7%A0%94%E7%A9%B6%E6%84%8F%E4%B9%89">1.1.2　课题的研究意义 <a href="#%E8%AF%BE%E9%A2%98%E7%9A%84%E7%A0%94%E7%A9%B6%E6%84%8F%E4%B9%89">7</a></a></p><p><a href="#%E8%AF%BE%E9%A2%98%E7%9A%84%E7%A0%94%E7%A9%B6%E7%9B%AE%E6%A0%87">1.2　课题的研究目标 <a href="#%E8%AF%BE%E9%A2%98%E7%9A%84%E7%A0%94%E7%A9%B6%E7%9B%AE%E6%A0%87">7</a></a></p><p><a href="#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%96%BD%E6%96%B9%E6%A1%88">2　需求分析与实施方案 <a href="#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%96%BD%E6%96%B9%E6%A1%88">9</a></a></p><p><a href="#%E5%8F%AF%E8%A1%8C%E6%80%A7%E5%88%86%E6%9E%90">2.1　可行性分析 <a href="#%E5%8F%AF%E8%A1%8C%E6%80%A7%E5%88%86%E6%9E%90">9</a></a></p><p><a href="#%E6%8A%80%E6%9C%AF%E5%8F%AF%E8%A1%8C%E6%80%A7">2.1.1　技术可行性 <a href="#%E6%8A%80%E6%9C%AF%E5%8F%AF%E8%A1%8C%E6%80%A7">9</a></a></p><p><a href="#%E6%93%8D%E4%BD%9C%E5%8F%AF%E8%A1%8C%E6%80%A7">2.1.2　操作可行性 <a href="#%E6%93%8D%E4%BD%9C%E5%8F%AF%E8%A1%8C%E6%80%A7">10</a></a></p><p><a href="#%E7%BB%8F%E6%B5%8E%E5%8F%AF%E8%A1%8C%E6%80%A7">2.1.3　经济可行性 <a href="#%E7%BB%8F%E6%B5%8E%E5%8F%AF%E8%A1%8C%E6%80%A7">10</a></a></p><p><a href="#%E8%B0%83%E5%BA%A6%E5%8F%AF%E8%A1%8C%E6%80%A7">2.1.4　调度可行性 <a href="#%E8%B0%83%E5%BA%A6%E5%8F%AF%E8%A1%8C%E6%80%A7">10</a></a></p><p><a href="#%E5%8A%9F%E8%83%BD%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90">2.2　功能需求分析 <a href="#%E5%8A%9F%E8%83%BD%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90">10</a></a></p><p><a href="#%E8%A7%92%E8%89%B2%E8%AF%B4%E6%98%8E">2.2.1　角色说明 <a href="#%E8%A7%92%E8%89%B2%E8%AF%B4%E6%98%8E">10</a></a></p><p><a href="#%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%E7%9B%AE%E6%A0%87">2.2.2　系统实现目标 <a href="#%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%E7%9B%AE%E6%A0%87">11</a></a></p><p><a href="#%E6%AF%95%E4%B8%9A%E7%94%9F%E6%B1%82%E8%81%8C%E9%9C%80%E6%B1%82">2.2.3　毕业生求职需求 <a href="#%E6%AF%95%E4%B8%9A%E7%94%9F%E6%B1%82%E8%81%8C%E9%9C%80%E6%B1%82">12</a></a></p><p><a href="#%E4%BC%81%E4%B8%9A%E6%8B%9B%E8%81%98%E9%9C%80%E6%B1%82">2.2.4　企业招聘需求 <a href="#%E4%BC%81%E4%B8%9A%E6%8B%9B%E8%81%98%E9%9C%80%E6%B1%82">13</a></a></p><p><a href="#%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E9%9C%80%E6%B1%82">2.2.5　后台管理需求 <a href="#%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E9%9C%80%E6%B1%82">15</a></a></p><p><a href="#%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1">3　系统设计 <a href="#%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1">17</a></a></p><p><a href="#%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87">3.1　系统设计目标 <a href="#%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87">17</a></a></p><p><a href="#%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3">3.1.1系统设计思想 <a href="#%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3">17</a></a></p><p><a href="#%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1">3.2体系结构设计 <a href="#%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1">18</a></a></p><p><a href="#%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">3.2.1软件体系结构 <a href="#%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">18</a></a></p><p><a href="#%E6%80%BB%E4%BD%93%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1">3.3总体功能模块结构设计 <a href="#%E6%80%BB%E4%BD%93%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1">19</a></a></p><p><a href="#%E7%B3%BB%E7%BB%9Fer%E5%9B%BE">3.4系统ER图 <a href="#%E7%B3%BB%E7%BB%9Fer%E5%9B%BE">19</a></a></p><p><a href="#%E6%A8%A1%E5%9D%97%E5%8A%9F%E8%83%BD%E5%85%B7%E4%BD%93%E8%AE%BE%E8%AE%A1">3.2　模块功能具体设计 <a href="#%E6%A8%A1%E5%9D%97%E5%8A%9F%E8%83%BD%E5%85%B7%E4%BD%93%E8%AE%BE%E8%AE%A1">20</a></a></p><p><a href="#%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE">3.2.1系统设置 <a href="#%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE">20</a></a></p><p><a href="#%E4%BC%81%E4%B8%9A%E7%AE%A1%E7%90%86">3.2.2 企业管理 <a href="#%E4%BC%81%E4%B8%9A%E7%AE%A1%E7%90%86">21</a></a></p><p><a href="#%E6%AF%95%E4%B8%9A%E7%94%9F%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86">3.2.3毕业生信息管理 <a href="#%E6%AF%95%E4%B8%9A%E7%94%9F%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86">22</a></a></p><p><a href="#%E5%B0%B1%E4%B8%9A%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86">3.2.4就业信息管理 <a href="#%E5%B0%B1%E4%B8%9A%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86">23</a></a></p><p><a href="#%E4%BC%81%E4%B8%9A%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86">3.2.5企业用户信息管理 <a href="#%E4%BC%81%E4%B8%9A%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86">24</a></a></p><p><a href="#%E5%89%8D%E5%8F%B0%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B">3.2.6前台业务流程 <a href="#%E5%89%8D%E5%8F%B0%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B">25</a></a></p><p><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1">3.3　数据库设计 <a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1">27</a></a></p><p><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E4%BD%93%E5%85%B3%E7%B3%BBe-r%E5%9B%BE%E8%AE%BE%E8%AE%A1">3.3.1　数据库实体关系E-R图设计 <a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E4%BD%93%E5%85%B3%E7%B3%BBe-r%E5%9B%BE%E8%AE%BE%E8%AE%A1">27</a></a></p><p><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E8%AE%BE%E8%AE%A1">3.3.2数据库表设计 <a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E8%AE%BE%E8%AE%A1">31</a></a></p><p><a href="#%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9E%E7%8E%B0">4　系统的实现 <a href="#%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9E%E7%8E%B0">51</a></a></p><p><a href="#%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD">4.1　登录功能 <a href="#%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD">51</a></a></p><p><a href="#%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD">4.2　注册功能 <a href="#%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD">51</a></a></p><p><a href="#%E5%AD%A6%E7%94%9F%E6%B3%A8%E5%86%8C">4.2.1学生注册 <a href="#%E5%AD%A6%E7%94%9F%E6%B3%A8%E5%86%8C">51</a></a></p><p><a href="#%E4%BC%81%E4%B8%9A%E6%B3%A8%E5%86%8C">4.2.2企业注册 <a href="#%E4%BC%81%E4%B8%9A%E6%B3%A8%E5%86%8C">52</a></a></p><p><a href="#%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E9%A1%B5%E9%9D%A2%E5%8A%9F%E8%83%BD">4.3　学生管理页面功能 <a href="#%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E9%A1%B5%E9%9D%A2%E5%8A%9F%E8%83%BD">53</a></a></p><p><a href="#%E5%AD%A6%E7%94%9F%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86">4.3.1　学生基本信息管理 <a href="#%E5%AD%A6%E7%94%9F%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86">53</a></a></p><p><a href="#%E6%B1%82%E8%81%8C%E6%84%8F%E5%90%91%E7%AE%A1%E7%90%86">4.3.3求职意向管理 <a href="#%E6%B1%82%E8%81%8C%E6%84%8F%E5%90%91%E7%AE%A1%E7%90%86">54</a></a></p><p><a href="#%E5%9F%B9%E8%AE%AD%E7%BB%8F%E5%8E%86%E7%AE%A1%E7%90%86">4.3.4培训经历管理 <a href="#%E5%9F%B9%E8%AE%AD%E7%BB%8F%E5%8E%86%E7%AE%A1%E7%90%86">54</a></a></p><p><a href="#%E8%AF%81%E4%B9%A6%E7%AE%A1%E7%90%86">4.3.5证书管理 <a href="#%E8%AF%81%E4%B9%A6%E7%AE%A1%E7%90%86">55</a></a></p><p><a href="#%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C%E7%AE%A1%E7%90%86">4.3.6项目经验管理 <a href="#%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C%E7%AE%A1%E7%90%86">55</a></a></p><p><a href="#%E6%96%B0%E5%A2%9E%E5%AE%9E%E4%B9%A0%E7%BB%8F%E5%8E%86">4.3.7新增实习经历 <a href="#%E6%96%B0%E5%A2%9E%E5%AE%9E%E4%B9%A0%E7%BB%8F%E5%8E%86">56</a></a></p><p><a href="#%E8%81%8C%E4%BD%8D%E6%94%B6%E8%97%8F">4.3.8职位收藏 <a href="#%E8%81%8C%E4%BD%8D%E6%94%B6%E8%97%8F">56</a></a></p><p><a href="#%E7%AE%80%E5%8E%86%E7%9A%84%E6%8A%95%E9%80%92%E6%83%85%E5%86%B5%E6%9F%A5%E7%9C%8B">4.3.9简历的投递情况查看 <a href="#%E7%AE%80%E5%8E%86%E7%9A%84%E6%8A%95%E9%80%92%E6%83%85%E5%86%B5%E6%9F%A5%E7%9C%8B">57</a></a></p><p><a href="#%E7%AE%A1%E7%90%86%E5%91%98%E7%AE%A1%E7%90%86%E9%A1%B5%E9%9D%A2%E5%8A%9F%E8%83%BD">4.4　管理员管理页面功能 <a href="#%E7%AE%A1%E7%90%86%E5%91%98%E7%AE%A1%E7%90%86%E9%A1%B5%E9%9D%A2%E5%8A%9F%E8%83%BD">57</a></a></p><p><a href="#%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86">4.4.1　用户信息管理 <a href="#%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86">57</a></a></p><p><a href="#%E5%AD%A6%E7%94%9F%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86">4.4.2学生账号管理 <a href="#%E5%AD%A6%E7%94%9F%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86">58</a></a></p><p><a href="#%E4%BC%81%E4%B8%9A%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86">4.4.3企业账号管理 <a href="#%E4%BC%81%E4%B8%9A%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86">58</a></a></p><p><a href="#%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0%E7%9A%84%E5%AE%A1%E6%A0%B8%E5%8F%8A%E7%AE%A1%E7%90%86">4.4.4发布文章的审核及管理 <a href="#%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0%E7%9A%84%E5%AE%A1%E6%A0%B8%E5%8F%8A%E7%AE%A1%E7%90%86">59</a></a></p><p><a href="#%E4%BC%81%E4%B8%9A%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD">4.5企业账号管理功能 <a href="#%E4%BC%81%E4%B8%9A%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD">59</a></a></p><p><a href="#%E4%BC%81%E4%B8%9A%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86">4.5.1企业基本信息管理 <a href="#%E4%BC%81%E4%B8%9A%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86">59</a></a></p><p><a href="#%E8%81%8C%E4%BD%8D%E7%AE%A1%E7%90%86">4.5.2职位管理 <a href="#%E8%81%8C%E4%BD%8D%E7%AE%A1%E7%90%86">60</a></a></p><p><a href="#%E7%B3%BB%E7%BB%9F%E9%A1%B5%E9%9D%A2">4.6系统页面 <a href="#%E7%B3%BB%E7%BB%9F%E9%A1%B5%E9%9D%A2">60</a></a></p><p><a href="#%E7%B3%BB%E7%BB%9F%E9%A6%96%E9%A1%B5">4.6.1系统首页 <a href="#%E7%B3%BB%E7%BB%9F%E9%A6%96%E9%A1%B5">60</a></a></p><p><a href="#%E6%96%B0%E9%97%BB%E5%8A%A8%E6%80%81%E6%A0%87%E9%A2%98%E6%9F%A5%E7%9C%8B">4.6.2新闻动态标题查看 <a href="#%E6%96%B0%E9%97%BB%E5%8A%A8%E6%80%81%E6%A0%87%E9%A2%98%E6%9F%A5%E7%9C%8B">61</a></a></p><p><a href="#%E6%96%87%E7%AB%A0%E8%AF%A6%E6%83%85%E7%9A%84%E6%9F%A5%E7%9C%8B">4.6.3文章详情的查看 <a href="#%E6%96%87%E7%AB%A0%E8%AF%A6%E6%83%85%E7%9A%84%E6%9F%A5%E7%9C%8B">61</a></a></p><p><a href="#%E5%BC%80%E6%94%BE%E8%81%8C%E4%BD%8D">4.6.4开放职位 <a href="#%E5%BC%80%E6%94%BE%E8%81%8C%E4%BD%8D">62</a></a></p><p><a href="#_Toc160899385">5　系统测试 <a href="#_Toc160899385">63</a></a></p><p><a href="#%E5%AD%A6%E7%94%9F%E7%AB%AF%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95%E5%86%85%E5%AE%B9">5.1学生端功能测试内容 <a href="#%E5%AD%A6%E7%94%9F%E7%AB%AF%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95%E5%86%85%E5%AE%B9">63</a></a></p><p><a href="#%E5%AD%A6%E7%94%9F%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95">5.1.1学生登录功能测试 <a href="#%E5%AD%A6%E7%94%9F%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95">63</a></a></p><p><a href="#%E5%AD%A6%E7%94%9F%E7%AE%80%E5%8E%86%E4%BF%AE%E6%94%B9%E6%B5%8B%E8%AF%95">5.1.2　学生简历修改测试 <a href="#%E5%AD%A6%E7%94%9F%E7%AE%80%E5%8E%86%E4%BF%AE%E6%94%B9%E6%B5%8B%E8%AF%95">64</a></a></p><p><a href="#%E5%AD%A6%E7%94%9F%E6%96%B0%E5%A2%9E%E6%B1%82%E8%81%8C%E6%84%8F%E5%90%91%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95">5.1.3　学生新增求职意向功能测试 <a href="#%E5%AD%A6%E7%94%9F%E6%96%B0%E5%A2%9E%E6%B1%82%E8%81%8C%E6%84%8F%E5%90%91%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95">64</a></a></p><p><a href="#%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C%E4%BF%AE%E6%94%B9%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95">5.1.4　项目经验修改功能测试 <a href="#%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C%E4%BF%AE%E6%94%B9%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95">65</a></a></p><p><a href="#%E8%AF%81%E4%B9%A6%E6%9F%A5%E8%AF%A2%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95">5.1.5　证书查询功能测试 <a href="#%E8%AF%81%E4%B9%A6%E6%9F%A5%E8%AF%A2%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95">65</a></a></p><p><a href="#%E4%BC%81%E4%B8%9A%E7%AB%AF%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95%E5%86%85%E5%AE%B9">5.2企业端功能测试内容 <a href="#%E4%BC%81%E4%B8%9A%E7%AB%AF%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95%E5%86%85%E5%AE%B9">66</a></a></p><p><a href="#%E4%BC%81%E4%B8%9Alogo%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95">5.2.1　企业logo文件上传功能测试 <a href="#%E4%BC%81%E4%B8%9Alogo%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95">66</a></a></p><p><a href="#%E7%BB%93-%E8%AE%BA">6　结　论 <a href="#%E7%BB%93-%E8%AE%BA">67</a></a></p><p><a href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE">参考文献 <a href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE">68</a></a></p><p><a href="#%E8%87%B4%E8%B0%A2">致谢 <a href="#%E8%87%B4%E8%B0%A2">69</a></a></p><h1 id="1-绪-论"><a href="#1-绪-论" class="headerlink" title="1　绪　论"></a>1　绪　论</h1><h2 id="1-1-课题的来源、意义"><a href="#1-1-课题的来源、意义" class="headerlink" title="1.1　课题的来源、意义"></a>1.1　课题的来源、意义</h2><h3 id="1-1-1-课题的研究来源"><a href="#1-1-1-课题的研究来源" class="headerlink" title="1.1.1　课题的研究来源"></a>1.1.1　课题的研究来源</h3><p>在当前的就业市场中，大学生就业一直是社会关注的热点问题^([1])。随着互联网技术和信息化水平的不断提升，如何有效利用现代信息技术手段，提高大学生就业服务的效率和质量，成为了教育领域和社会发展的重要议题^([2])。特别是数据可视化技术的发展，为就业信息的分析和呈现提供了新的解决方案^([5])。基于此背景，开发一个集成了数据可视化技术的大学生就业管理系统^([4])，旨在通过高效、直观的数据展示方式，为大学生就业提供更加科学、合理的管理与决策支持^([6])。</p><h3 id="1-1-2-课题的研究意义"><a href="#1-1-2-课题的研究意义" class="headerlink" title="1.1.2　课题的研究意义"></a>1.1.2　课题的研究意义</h3><p>该研究课题的重要性在于它能够充分利用数据可视化技术，对大量就业数据进行有效管理和分析，帮助管理者和学生从复杂的数据中提取有价值的信息，优化就业指导服务，提升学生就业率^([7])。通过该系统，可以实现对学生就业信息的实时监控、分析和预测，为学生提供更加个性化、精准的就业指导和建议。此外，系统还能够帮助高校就业指导部门改进就业服务流程，提高工作效率，加强与企业的信息交流和合作，为大学生提供更多、更好的就业机会^([8])。</p><h2 id="1-2-课题的研究目标"><a href="#1-2-课题的研究目标" class="headerlink" title="1.2　课题的研究目标"></a>1.2　课题的研究目标</h2><p>本文旨在设计并实现一个基于数据可视化的大学生就业管理系统，该系统主要目标包括：</p><p>（1）数据可视化展示：利用数据可视化技术，直观展现大学生就业信息和市场趋势，包括就业率、行业分布、薪资水平等关键指标，帮助用户快速理解就业情况^([9])。</p><p>（2）实时信息更新与管理：系统能够实时更新和管理学生就业信息，确保信息的准确性和时效性。包括学生个人信息、就业进展、企业招聘信息等^([10])。</p><p>（3）高效便捷的用户体验：为学生、教师和管理者提供简洁、易用的操作界面，实现高效便捷的信息查询、数据分析和报告生成等功能^([11])。</p><p>（4）安全稳定的系统运行：确保系统的安全性和稳定性，采用先进的安全技术保护用户数据不被泄露，同时保证系统的高可用性和可靠性^([12])。</p><p>通过实现这些目标，该系统将为大学生就业管理提供一个全面、高效、便捷的信息化平台，促进学生就业与社会需求的有效匹配，提升就业服务的质量和水平^([13])。</p><h1 id="2-需求分析与实施方案"><a href="#2-需求分析与实施方案" class="headerlink" title="2　需求分析与实施方案"></a>2　需求分析与实施方案</h1><h2 id="2-1-可行性分析"><a href="#2-1-可行性分析" class="headerlink" title="2.1　可行性分析"></a>2.1　可行性分析</h2><h3 id="2-1-1-技术可行性"><a href="#2-1-1-技术可行性" class="headerlink" title="2.1.1　技术可行性"></a>2.1.1　技术可行性</h3><ol><li>后端框架：Spring Boot</li></ol><p>Spring Boot是一个开源的Java-based框架，用于创建微服务。它提供快速的项目搭建和简化的配置过程，同时具有强大的社区支持和广泛的文档资源。Spring Boot易于集成其他Java框架如MyBatis，且与Redis和MySQL的兼容性良好，有助于提高系统的整体性能和稳定性^([14])。</p><ol start="2"><li>缓存技术：Redis</li></ol><p>Redis作为一个内存中的数据结构存储，常用于实现数据库缓存，提高数据访问速度。Redis与Spring Boot结合使用时，可以有效地减少数据库的访问次数，提高系统响应速度^([15])。</p><ol start="3"><li>数据库：MySQL</li></ol><p>MySQL是一个广泛使用的关系型数据库管理系统，以其稳定性和高效性而闻名。MySQL与Spring Boot和MyBatis&#x2F;MyBatis Plus的整合为系统的数据存储提供了可靠保障^([16])。</p><ol start="4"><li>持久层框架：MyBatis和MyBatis Plus</li></ol><p>MyBatis是一个半自动的ORM（对象关系映射）框架，MyBatis Plus作为其增强版，提供了更多便捷功能。两者可以有效地简化代码，提高开发效率，特别是在与Spring Boot结合时，可以实现更高效的数据操作^([17])。</p><ol start="5"><li>前端数据可视化：ECharts</li></ol><p>ECharts是一个基于JavaScript的开源可视化库，能够创建清晰、交互性强的图表。ECharts与Vue3结合，可以在前端展示复杂的数据可视化，提升用户体验。</p><ol start="6"><li>前端框架：Vue3</li></ol><p>Vue3是一个渐进式JavaScript框架，用于构建用户界面，以其易用、灵活和高效著称。Vue3的响应式和组件化特性使得开发大型应用变得更简单，与ECharts的结合将进一步增强前端的数据展示能力^([18])。</p><ol start="7"><li>安全框架：Spring Security</li></ol><p>在任何在线系统中，安全性都是不可忽视的要素。Spring Security提供了一套全面的安全和认证功能，能够有效地保护系统免受常见的安全威胁^([19])。</p><ol start="8"><li>接口调试工具：Swagger2</li></ol><p>Swagger2用于设计、构建、记录和使用RESTful Web服务。Swagger2可以与Spring Boot无缝整合，为开发和测试API提供了极大的便利。</p><ol start="9"><li>开发环境：IntelliJ IDEA</li></ol><p>IntelliJ IDEA是一个强大的Java集成开发环境，提供智能编码辅助和自动化的功能。IDEA支持上述所有技术栈，能够提高开发效率和代码质量^([20])。</p><p>这种多技术结合的方法不仅可以实现一个功能齐全、响应快速的系统，还能确保系统的稳定性和安全性。</p><h3 id="2-1-2-操作可行性"><a href="#2-1-2-操作可行性" class="headerlink" title="2.1.2　操作可行性"></a>2.1.2　操作可行性</h3><p>操作可行性主要指系统运行之后，需要用户配合进行的人工操作是否能够顺利进行。本学生就业管理系统的设计基于 B&#x2F;S 结构，界面设计力求简洁友好，符合一般大众使用浏览器对网站的访问的习惯。用户使用时只需要根据界面的提示或简单阅读系统说明，不需要进行专门的培训，因此该系统具有良好的操作可行性。</p><h3 id="2-1-3-经济可行性"><a href="#2-1-3-经济可行性" class="headerlink" title="2.1.3　经济可行性"></a>2.1.3　经济可行性</h3><p>在讨论经济可行性时，一个常用的方法是成本&#x2F;效益分析。项目的初始投资主要集中在软件开发、硬件配置（或云服务费用）以及人员培训上。通过利用开源技术和优化资源配置，可以在一定程度上降低这些成本。项目的运营成本涉及到系统维护、服务费用等，但通过系统实施后带来的工作效率提升、决策支持能力增强和用户满意度提高，预期将产生显著的收益，不仅能够覆盖这些成本，还有望在合理的时间内回收投资并实现盈利。</p><h3 id="2-1-4-调度可行性"><a href="#2-1-4-调度可行性" class="headerlink" title="2.1.4　调度可行性"></a>2.1.4　调度可行性</h3><p>调度可行性主要关注系统交付给用户的期限。对于学生就业管理系统，从问题定义、可行性分析、需求分析到编码实现、系统部署和测试总共需要的时间为三至六个月，成熟系统的部署则需要一至两天，因而可以满足一般系统的需求。</p><h2 id="2-2-功能需求分析"><a href="#2-2-功能需求分析" class="headerlink" title="2.2　功能需求分析"></a>2.2　功能需求分析</h2><h3 id="2-2-1-角色说明"><a href="#2-2-1-角色说明" class="headerlink" title="2.2.1　角色说明"></a>2.2.1　角色说明</h3><p>本系统主要角色分为系统管理员，企业账号管理员，学生账号</p><ol><li>系统管理员：系统管理员是本高校学科竞赛管理系统拥有维护管理整个系统最高权限的用户。系统管理员用户可以修改自己的个人信息，并且拥有查看企业管理员账户的权限（本系统的规则是，企业管理员即代表着各大企业，有系统给各大企业发放一个作为代表其企业的管理员账号），对招聘信息进行管理和编写，不需要进行审批，可以直接添加。查看所有的开放职业。系统管理员可以查看所有跟自己相关的信息提示汇总。可以设置行业，字典，可以增添学生账号，企业账号，及其他管理员账号。可以管理发布咨询的分类</li></ol><p>2.企业账号：企业账号可以编辑自己企业的基本介绍信息供学生查看，其中包括自己的公司类型，公司规模，公司logo图片，公司网址联系电话，邮箱等信息。可以管理自己开放的招聘职位，编辑该职位的学历要求，职位薪水，职位名称和职位需要的技术描述等信息。可以查看是否有学生投递简历到本公司，查看投递人的姓名和投递职业等信息。</p><p>3.学生账号：学生账号可以查看毕业意向调研图。编写自己的基本信息例如姓名、出生日期、毕业院校、电话、学历、性别、照片、毕业时间等。可以编写制作自己的简历。可以填写自己的求职意向，其中要选择自己的简历，可以写自己的期望行业，其中包括期望薪资，期望工作性质，期望行业，工作城市等内容。可以管理增删改查自己的简历。可以在自己的详情页增加自己的证书。可以编写自己的项目经验。可以编写自己的实习经历。可以查看自己在首页收藏的职业。可以查看自己已经投递的简历。可以查看自己的职业预测结果。</p><h3 id="2-2-2-系统实现目标"><a href="#2-2-2-系统实现目标" class="headerlink" title="2.2.2　系统实现目标"></a>2.2.2　系统实现目标</h3><p>大学生就业管理系统的开发应达到如下几个目标:</p><p>1.招聘信息发布:可以为企业提供一个快速发布最新招聘信息的平台，方便求职者求职，给企业招聘提供一个良好信息管理窗口。</p><p>2.求职信息发布:方便毕业生进行求职信息的发布，能够减少毕业生求职所需时间，使毕业生求职变的更加方便、快捷、有效。</p><p>3.快速注册:为毕业生和企业提供一个快速注册用户的窗口，用户登录后可以进行更加详细的信息管理。</p><p>4.相关文件发布:学校、政府不时的有一些相关政策，法规发布，通过毕业生就业管理系统，可以很容易的将这些文件进行发布，以供毕业生查看</p><p>5.信息查询: 通过高校毕业生就业管理系统，企业可以快速的查找最新求职信息，以找到符合公司要求的毕业生。毕业生通过该平台，可以快速查询最新招聘信息，使投简历有的放矢，这样就极大的提高了毕业生求职以及企业招聘效率</p><p>6.操作简单方便:高校毕业生就业管理系统全部采用现在最流行的浏览器查询方式，这样对客户端要求很低，只要连上网络，客户端安装 谷歌浏览器即可。用户只要会简单的鼠标和键盘操作就可以了。后台管理:管理员可以对所有信息进行统一管理，对求职信息、招聘信息进行增、删、改操作，及时发布最新新闻。</p><h3 id="2-2-3-毕业生求职需求"><a href="#2-2-3-毕业生求职需求" class="headerlink" title="2.2.3　毕业生求职需求"></a>2.2.3　毕业生求职需求</h3><p>1.个人资料管理</p><p>在面对毕业生用户时，当用户登录成功以后，有四个功能需求个人资料管理，主要用于个人资料的更新、修改、删除和添加等。这些资料就是毕业生注册时所填写的基本资料，在这个模块中还可以查看管理员提出对自己的警告如果存在的话。</p><p>2.求职信息发布</p><p>可以发布个人信息简介，提供企业用户查看，并且可以对已经发布的个人信息进行更新、修改、删除和添加等操作</p><p>3.信息查询</p><p>主要用来查询招聘信息，可以提供各种的关键字搜索，如行业、规模和薪酬等进行搜索其用例图如图2-1所示:</p><p>图<strong>2-1</strong>　毕业生用例图<img src="D:/HEXO/source/_posts/media/image3.png"></p><p>毕业生可通过用户登录界面，输入用户名和密码进行登录，若此用户名存在则进行下列毕业生用户管理界面的相关查询，如果不存在则提示该用户不存在，并返回到用户登录界面，登录成功后，可查询发布信息，并编辑简历，若简历编辑成功则完成操作，若编辑失败，则返回毕业生用户管理界面，并可重新发布更新简历，毕业生用户的系统操作流程图如图 2-2所示：</p><p><img src="D:/HEXO/source/_posts/media/image4.png"></p><p>图<strong>2-2</strong>　毕业生操作流程图</p><h3 id="2-2-4-企业招聘需求"><a href="#2-2-4-企业招聘需求" class="headerlink" title="2.2.4　企业招聘需求"></a>2.2.4　企业招聘需求</h3><p>在面对企业用户时，当企业登录成功以后，通常有四个功能需求。</p><p>1.企业资料管理</p><p>主要用于企业资料的更新、修改、删除和添加等操作。这些资料就是企业注册时企业所填写的基本资料。</p><p>2.发布招聘信息</p><p>可以发布企业招聘信息，提供给毕业生用户查看，并且可以对已经发布的招聘信息模块进行更新、修改、删除和添加等操作。</p><p>3.毕业生信息查询</p><p><img src="D:/HEXO/source/_posts/media/image5.png">主要用来查询毕业生用户发布的个人资料信息。可以提供各种的关键字搜索，如专业、年龄、学历等其用例图如图2-3 所示:</p><p>图<strong>2-3</strong>　企业用户用例图</p><p><img src="D:/HEXO/source/_posts/media/image6.png">企业可通过用户登录界面，输入用户名和密码进行登录，若此用户名存在则进行下列企业用户管理界面的相关查询，如果不存在则提示该用户不存在，并返回到用户登录界面，登录成功后，可查看企业用户管理界面，并有发布招聘信息，更新用户信息等功能，若发布信息操作，成功则提示完成，若发布失败，则会提示操作失败，并返回到企业用户管理界面，用户可进行重新发布企业用户的系统操作流程图如图2-4所示：</p><p>图<strong>2-4</strong>　企业用户系统操作流程图</p><h3 id="2-2-5-后台管理需求"><a href="#2-2-5-后台管理需求" class="headerlink" title="2.2.5　后台管理需求"></a>2.2.5　后台管理需求</h3><p>管理员用户需要以下功能:</p><p>1.新闻公告管理</p><p>新闻公告发布管理模块，主要为管理员提供一个发布信息的界面，当信息发布后，用户在登录后或没有登录将会看到管理员所发布的信息求职信息管理。</p><p>2.求职信息管理</p><p>主要用于管理所有毕业生用户所发布的个人信息简介，可以对其中不实和不存在的内容进行修改、删除和添加等操作。</p><p>3.招聘信息管理</p><p>主要用来管理企业型用户发布的招聘信息，可以对其中不实和不存在的内容进行修改、删除和添加等操作。</p><p>4.企业资料管理</p><p>主要用来编写企业用户资料：管理企业的用户名密码，编辑企业规模，编辑企业名称，设置企业的相关介绍等内容。</p><p>5.毕业生资料管理</p><p>主要用来核实毕业生用户资料、管理毕业生账号的用户名密码的权限和删除毕业生型用户。</p><p><img src="D:/HEXO/source/_posts/media/image7.png">管理员可管理毕业生账户资料、企业账户资料、发布新闻公告、发布招聘信息和求职信息等功能，管理员用户用例图如图2-5所示:</p><p>图<strong>2-5</strong>　管理员用户用例图</p><p><img src="D:/HEXO/source/_posts/media/image8.png">管理员进入后台登录窗口输入用户名和密码若登录成功则进入后台管理页面若失败则提示用户名或密码错误，进入后台管理页面后，可统一管理招聘信息求职信息新闻发布信息，若信息发布成功则提示操作成功，若发布失败，则返回后台管理页面可进行重新的内容编辑，管理员用户系统操作流程如图2-6所示：</p><p>图<strong>2-6</strong>　管理员用户系统操作流程图</p><h1 id="3-系统设计"><a href="#3-系统设计" class="headerlink" title="3　系统设计"></a>3　系统设计</h1><h2 id="3-1-系统设计目标"><a href="#3-1-系统设计目标" class="headerlink" title="3.1　系统设计目标"></a>3.1　系统设计目标</h2><p>系统根据毕业生就业工作业务而设计，希望能够设计并实现一个界面简洁安全性高、效益高的毕业生就业信息管理系统。系统需要达到如下设计目标。</p><p>1、进一步优化信息系统，达到网络化，提高效率，提高工作水平。</p><p>2、完善就业管理体制，使得就业管理工作更加简洁、快速、有效，及时有效地调查分析大学毕业生的择业趋势和引发的心理问题并进行及时有效的就业指导。</p><h2 id="3-1-1系统设计思想"><a href="#3-1-1系统设计思想" class="headerlink" title="3.1.1系统设计思想"></a>3.1.1系统设计思想</h2><p>软件系统的设计工作按照设计和开发思想可以大大提高系统研究的工作效率，本系统设计和开发思想本着系统扩展性强、功能添加灵活、性能优异的角度进行自定，主要体现在以下几个方面:</p><p>第一，系统编码思想</p><p>按照面向对象的编程思想进行系统开发，面向对象思想是在系统设计之处就要考虑的问题，本系统的分析和设计工作以“对象”为出发点，设计出系统业务处理过程的主要对象，并描述出业务处理对象的属性和方法。应用面向对象的编程思想确定系统架构模型，形成以“类”为单元的技术底层</p><p>第二，系统业务设计</p><p>按照软件工程对系统业务流程的要求，兼顾软件系统的操作过程，设计出符合高校教师、学生等用户操作习惯的业务流程，根据就业工作的具体安排对系统处理的每项就业工作进行逻辑上的重新制定，通过流程图描述出系统业务流程的执行顺序</p><p>第三，系统安全性设计</p><p>系统设计过程中要考虑系统安全性，从网络环境安全性、校园网安全性、系统程序安全性、客户端安全性、数据库安全性等方面出发，既要有硬件投入又要从软件环节入手，通过路由器等网络设备、数据加密等手段实现安全性[211</p><p>第四，系统UI设计</p><p>系统UI设计就是对B&#x2F;S结构中的客户端展示效果的设计过程，通过系统需求分析确定的分析成果为基础条件，设计出符合用户体验度高的交互界面操作平台。</p><h2 id="3-2体系结构设计"><a href="#3-2体系结构设计" class="headerlink" title="3.2体系结构设计"></a>3.2体系结构设计</h2><h3 id="3-2-1软件体系结构"><a href="#3-2-1软件体系结构" class="headerlink" title="3.2.1软件体系结构"></a>3.2.1软件体系结构</h3><p>系统采用现在主流的三层体系结构，从下到上分别是数据访问层、业务逻辑</p><p><img src="D:/HEXO/source/_posts/media/image9.png">层、用户工作层。图3-1是该系统的软件体系结构。用户工作层:主要是用户进行操作，网页显示数据信息，用户的操作包括用户需要录入的信息，数据的校验等用户层面的管理，然后再传送给业务逻辑层网页显示的数据信息首先由用户提交一定的请求，业务逻辑层根据请求，从数据访问层中获取数据，然后通过使用相应的HTML、CSS标记和动态脚本语言来实现。业务逻辑层:提供功能调用给用户界面层，其主要功能是核对，验证，如查询、新增、删除等操作进行对话框提示，如不能为空，只能输入数字，数据类型不一致等等，从而保证程序的健壮性，判断用户权限的合法性。并且可以访问数据库,数据由业务逻辑层从数据层中抽取、数据操作等也可由业务逻辑层来实现，然后将由业务逻辑层将最终处理结果返回给用户界面层。另外，还要根据系统设二计，构造工程中关键的几个对象，实现工程中的大部分逻辑控制功能。数据访问层：直接访问存储数据的数据库，完成一些数据操作的基本功能，数据的插入、删除、和修改查询等。数据访问层根据中间层业务逻辑层的数据请求，展开对数据库的操作如查询、删除、修改等。在一个系统中，对数据库的操作是最频繁的，同时也是最消费资源的，因此对于数据访问层要进一步优化，从而提高其性能。</p><p>图<strong>3-1</strong>　系统软件体系结构</p><h2 id="3-3总体功能模块结构设计"><a href="#3-3总体功能模块结构设计" class="headerlink" title="3.3总体功能模块结构设计"></a>3.3总体功能模块结构设计</h2><p>根据系统的功能需求，毕业生就业信息管理系统由六大模板组成，这六大模块分别是招聘管理、系统管理、注册管理、就业政策管理、就业动态管理、留言板管理。每个模板完成相当的功能，其设计均依照毕业生就业管理日常工作，下来对每个模块的功能做简单介绍</p><p>1、系统管理模块。包括用户信息管理，角色授权管理、数据库管理等2、招聘管理模块。包括简历填写，简历提交，简历修改和企业招聘发布企业信息审核，企业招聘信息查询等。</p><p>3、注册管理模块。主要包括学生注册、企业用户注册。</p><p>4、就业政策管理模块。主要包括三支一扶、入伍、西部计划、内容审核</p><p>5、就业动态管理模块。包括洽谈会、供需会、工作动态。</p><p>6、留言板管理模块。</p><p><img src="D:/HEXO/source/_posts/media/image10.png">7、毕业生实习信息模块。实习信息作为招聘的一个特殊环节系统功能模块结构图如图3-2所示。</p><p>图<strong>3-2</strong>　系统功能模块结构图</p><h2 id="3-4系统ER图"><a href="#3-4系统ER图" class="headerlink" title="3.4系统ER图"></a>3.4系统ER图</h2><p>E-R图包含“实体”“联系”“属性”三个基本部分。在E-R图中矩形框代表一个实体，它是客观存在的，相互独立又相关联的事物，它们分为三大类，一对一关联(1.1表示)，一对多关联(1:N表示);多对多关联(M:N表示)。在E-R图中圆代表实体的属性，用线将其相应的实体矩形框连接起来代表其属性。在E-R图中菱形代表实体之间相互的联系，用线分别与实体矩形框连接起来代表其相互联系，在菱形框中写明联系名，同时在旁边标注联系的类型(1:1或1:或M:N)</p><p><img src="D:/HEXO/source/_posts/media/image11.png">根据对业务的分析，可以得出实体对象间的对应关系:一个大学毕业生可以面对多家用人企业，即一对多的关系。一个用人企业可以签订多个大学毕业生，也是一对多的关系。同时，一个大学毕业生只能与一家用人单位签订，就业协议书也只能与一家用人企业签订，因此是一对一的关系。毕业生与用人企业为多对多的关系。因此，得出以下的E-R图，如图3-3所示。</p><p>图<strong>3-3</strong>　就业管理系统E-R图</p><h2 id="3-2-模块功能具体设计"><a href="#3-2-模块功能具体设计" class="headerlink" title="3.2　模块功能具体设计"></a>3.2　模块功能具体设计</h2><p>模块功能设计分别对就业队伍管理、就业跟踪管理、就业基地管理、就业统计与 分析、系统设置模块的部分重点子模块进行分析，以给出的子模块设计过程为实例确 定本系统所有模块的设计思路和方案。</p><h2 id="3-2-1系统设置"><a href="#3-2-1系统设置" class="headerlink" title="3.2.1系统设置"></a>3.2.1系统设置</h2><p>系统设置功能模块包含的子功能也相对校对，其中学生信息的添加是本系统运作的前提，学生信息也是系统应该具备的基础信息。学生用户在使用本系统时应该提前具备账户信息，只具有修改或查询自身用户信息的权限，这就涉及到学生信息批量导入的工作。学生信息批量导入源于高校已经具备的学生基础信息，当学生入学阶段高校就已经收集到学生的第一手入学资料，只不过这时的信息可能是办公常用格式，大多以Excel格式为准，因此本系统需要设计出可以实现通过学生批量导入信息功能完成的信息插入功能。该功能业务流程设计如下：第一步，管理员进行登录操作；第二步，管理员选择学生管理并进入学生信息添加操作页面，支持手动添加和批量添加操作，手动添加过程与其它信息添加过程一致；第三步，从本地计算机中选择可导入的学生格式文件，选中该文件；第四步，系统将首先对文件的格式进行检查，确定Excel文件与数据库系统文件中的类型是否兼容；第五步，如果兼容性满足条件则执行批量的Insert语句。系统设置中的<img src="D:/HEXO/source/_posts/media/image12.png">学生信息手动添加和批量导入操作流程设计如图3-4所示：</p><p>图<strong>3-4</strong>　学生信息添加与导入流程图</p><h2 id="3-2-2-企业管理"><a href="#3-2-2-企业管理" class="headerlink" title="3.2.2 企业管理"></a>3.2.2 企业管理</h2><p>就业基地管理主要是对企业信息进行维护，由企业用户完成这一操作过程，企 业就业基地管理模块以用工申请描述其业务：第一步，企业用户登陆到系统； 第二步，企业用户发现有用工需求时，可以进入系统填写用工申请，并提交给学校；第三步，学校查看到此类信息后给予消息反馈，最终达到满足企业用工的目的。 就业基地用工需求申请操作流程设计如图 3-5所示：</p><p><img src="D:/HEXO/source/_posts/media/image13.png">图<strong>3-5</strong>　企业用工申请流程图</p><h3 id="3-2-3毕业生信息管理"><a href="#3-2-3毕业生信息管理" class="headerlink" title="3.2.3毕业生信息管理"></a>3.2.3毕业生信息管理</h3><p>企业用户登录系统，必须提前向学校就业指导中心申请登录权限，提交学校需要的单位信息及资质，学校就业管理部门通过对企业的资质审查，给予企业登录权限。企业用户通过已授权的用户名登录成功，就可以进行就业信息的发布、修改、查询等操作。完成操作后，点击退出，就会退出系统。毕业生信息管理的具体流程图如图 3-6 所示。</p><p><img src="D:/HEXO/source/_posts/media/image14.png">图<strong>3-6</strong>　毕业生信息管理流程图</p><h3 id="3-2-4就业信息管理"><a href="#3-2-4就业信息管理" class="headerlink" title="3.2.4就业信息管理"></a>3.2.4就业信息管理</h3><p>在用户登录系统的过程中，要选择相应的身份途径，选择不同的身份途径也就意味着其登录后所面临的系统界面不一样，其进行的相关操作也就不一样。系统会根据不同的身份，赋予其不同的权限，各类用户必须在权限的范围内进行相关操作。企业用户在发布招聘信息时，首先登录系统，系统通过身份验证后，企业用户才能进入系统。进入系统后，企业用户选择就业信息管理，在就业信息管理模块中依次完成就业信息的填写和提交，提价后等待审核结果，审核通过后招聘信息发布成功，否则需要企业 用户重新填写招聘信息进行发布。如图 3-7 所示。</p><p><img src="D:/HEXO/source/_posts/media/image15.png">图<strong>3-7</strong>　就业信息管理流程图</p><h3 id="3-2-5企业用户信息管理"><a href="#3-2-5企业用户信息管理" class="headerlink" title="3.2.5企业用户信息管理"></a>3.2.5企业用户信息管理</h3><p>企业用户通过企业登录界面登录到就业管理系统，若用户登录成功，就可以进行其他 操作。在企业信息管理中，可以对企业相关信息进行修改；在学生信息查询中，可以发布 求职信息或者接收面试通知；在就业政策及指导总，可以了解目前的就业行情。完成相应 的操作，点击退出就业信息管理系统。具体的流程图如图 3-8所示。</p><p><img src="D:/HEXO/source/_posts/media/image16.png">图<strong>3-8</strong>　企业用户流程图</p><h3 id="3-2-6前台业务流程"><a href="#3-2-6前台业务流程" class="headerlink" title="3.2.6前台业务流程"></a>3.2.6前台业务流程</h3><p><img src="D:/HEXO/source/_posts/media/image17.png">不同用户在使用系统的过程中，第一步都是登录系统，然后根据用户 ID 的不 同分配的有不同的权限，根据权限的不同查看不同的信息和处理属于权限范围内 的操作。 用户进入本系统前台，可查看新闻，公告，下载资料，进行信息查询，成功 注册并登陆通过验证后可浏览企业招聘信息，发送求职申请递交个人简历。如图 3-9 所示。</p><p><strong>3-9</strong>　前台业务流程图</p><p><img src="D:/HEXO/source/_posts/media/image18.png">用户进入本系统首页可进行注册，通过信息验证，选择会员类型，填写详细 资料后，成功登陆可获得用户权限。也可以通过资料验证实现密码找回和修改密 码。如图 3-10 所示。</p><p><strong>3-10</strong>　注册登录流程图</p><h2 id="3-3-数据库设计"><a href="#3-3-数据库设计" class="headerlink" title="3.3　数据库设计"></a>3.3　数据库设计</h2><p>系统的数据库是设计是系统实施的关键步骤，前端的用户登录、数据提交和保存、数据的查询和统计都依赖与后台数据库的有力支撑。数据库和数据表的设计要符合一定的规范，以保证程序编写的统一性和规范化。除此以外，数据库的设计还要考虑到对客户端高并发性访问需求的性能优化，同时做好数据库的安全防护和备份，防止数据意外丢失或遭受病毒攻击而造成的系统瘫痪。</p><h3 id="3-3-1-数据库实体关系E-R图设计"><a href="#3-3-1-数据库实体关系E-R图设计" class="headerlink" title="3.3.1　数据库实体关系E-R图设计"></a>3.3.1　数据库实体关系E-R图设计</h3><p><img src="D:/HEXO/source/_posts/media/image19.png">如下图3-11为E-R 图由实体、实体的属性值和实体之间的关联关系三部分构成。关系模型 实际是表述的实体之间是怎么关联的以及其关系，通常能够根据 E-R 图描述的信 息理解为一个关联模型。比如模型的一端实体为 x，另一方实体为 y， x：y 的 关联模型就能理解成一种逻辑关系。</p><p><strong>3-11</strong>　E-R实体关系图</p><p><img src="D:/HEXO/source/_posts/media/image20.png">本服务的使用者主要有系统后台操作人员、用人部门、院系相关人员、班级管理员和毕业生这五类人。他们彼此之间是有相互关系的。例如说系统后台操作 人员与院系相关人员、用人部门以及毕业生三种使用者在使用中都是精心统一操 作的，三者之间的关联性比较重，其中用人单位与毕业生之间的关系要更为紧密， 用人单位与学生之间要进行平等交流，他们之间的关系如下图3-12所示</p><p><strong>3-12</strong>毕业生应聘实体关系图</p><p><img src="D:/HEXO/source/_posts/media/image21.png">管理员主要的工作就是对于用户的信息、需求进行管理，其中包括了用户的 ID、密码和真实姓名，定期对于系统中的信息进行更新管理，其中包括了删除非 法用户、更改用户权限以及考核管理平台上的信息等等。具体流程如下表图 3-13 所示</p><p><strong>3-13</strong>管理员实体图</p><p>许多的公司构成了招聘公司，招聘公司首先注册自己的账号，注册成功后登入自己的账号信息公开自己的相关信息，可以看到毕业生在系统中注册的自己的个人简历，这样公司可以选择学生，学生也可以选择公司，针对内部推荐，在系<img src="D:/HEXO/source/_posts/media/image22.png">统的右上方专门开发了链接供用户使用，如图3-14</p><p><strong>3-14</strong>用人单位实体图</p><p><img src="D:/HEXO/source/_posts/media/image23.png">根据不同的高校对于就业系统提出的需求，毕业生们通常只有一个简历，但 是可以通过对于自己感兴趣的公司发布多个面试申请，从而收到多个面试或者笔 试的预约。所以，一个毕业生的初始通过的简历预约会有很多个，同时不同的毕 业生可以投递到不同的岗位。通过上面的描述，上面几个涉及的实体组成了下图 中的实体关系图，如图 3-15</p><p><strong>3-15</strong>毕业生相关实体关系</p><p>毕业生部分主要由高校应届毕业生构成，进入系统后能够把个人的工作经历 学习经历进行发布。因为这个服务平台只为本校的学生提供服务， 这样就可以直接将学生的资料信息从毕业生的学籍档案库中输入。如图 3-16 所示</p><p><img src="D:/HEXO/source/_posts/media/image24.png"><strong>3-16</strong>学生实体图</p><p><img src="D:/HEXO/source/_posts/media/image25.png">招聘信息部分主要是由招聘职位招聘人数学历，要求专业要求入职工资外语要求职业要求来构成企业通过发布招聘信息，将如上字段录入到数据库中，并最后过数据库的查询展示到对应页面，如图3-17所示</p><p><strong>3-17</strong>招聘信息实体图</p><p><img src="D:/HEXO/source/_posts/media/image26.png">公告信息实体图，包括公告编号、公告标题、公告内￥、发布日期和发布人五个属性，其主要用于管理系统的公告信息数据。具体如图3-18所示</p><p><strong>3-18</strong>公告实体图</p><p><img src="D:/HEXO/source/_posts/media/image27.png">简历部分主要分为简历的编号、名称、个人评价、项目经历、工作经历、社会实践、特长、爱好、获奖信息、证书信息、主要课程，学生通过录入以上的数据可编写一份自己的简历，并最后通过数据库查询返回数据，在前端页面上显示方便学生，用人单位对简历的查看，如图3-19所示</p><p><strong>3-19</strong>简历实体图</p><h3 id="3-3-2数据库表设计"><a href="#3-3-2数据库表设计" class="headerlink" title="3.3.2数据库表设计"></a>3.3.2数据库表设计</h3><p><img src="D:/HEXO/source/_posts/media/image28.png">在就业管理信息系统中，根据主辅数据库规范，为了加大操作各类数据的查 询效率，满足用户获取数据的输出速度，一个大的 job 数据库成为了最终的数据 库。依据服务平台不同的使用者和使用者的工作内容，对就业管理服务平台的持 久层进行了分析规划，就业管理服务系统数据库关系图的设计如图 3-20所示</p><p><strong>3-20</strong>数据库关系图</p><p>数据库关系图很明了的展现了服务平台中相关的重要模块结构关系。结合实际业务逻辑，对各类数据库表，如学生数据表、用人单位信息表、招聘职位表、毕业生简历表、就业签约表，进行了详细的设计，包括字段名、数据说明、字段类型、字段长度等说明。</p><ol><li>文章表</li></ol><p>文章表包括标题、作者、内容、创建时间等。通过这些字段，可以方便地对文章进行分类、检索和展示。根据需求如表3-1所示表</p><blockquote><p><strong>3-1　tb_article</strong>表</p></blockquote><p>[TABLE]</p><p>**id (文章表id)**：这是一个整型字段，长度为20。作为主键，它不应该为空，并且会自动为每篇文章分配一个唯一的标识符。通常，这个字段不需要默认值，因为其值在插入新记录时会自动生成（如果设置了自增）。</p><p>**channel_id (栏目id)**：整型，长度为20，可以为空。这表明文章可以归属于可选的栏目或类别中，用于对文章进行分类。</p><p>**title (题目)**：字符串类型（varchar），最大长度为100字符，不能为空。存储文章的标题。</p><p>**title_img (题目图片)**：字符串类型，最大长度为100字符，不能为空。存储与文章标题相关联的图片的URL或路径。</p><p>**summary (总结)**：字符串类型，最大长度为200字符，不能为空。存储文章的简短总结或描述。</p><p>**author (作者名)**：字符串类型，最大长度为100字符，不能为空。存储文章作者的名字。</p><p>**url (地址)**：字符串类型，最大长度为100字符，不能为空。可能存储文章可访问的URL或表示文章网页的唯一标识符。</p><p>**content (内容)**：文本类型，虽然长度标为255字符，但对于文本类型，这个长度通常不是约束。不能为空，保证文章必须包含内容。</p><p>**sort (种类)**：整型，长度为20，不能为空，有一个默认值0。这可能用于在栏目或类别内对文章进行排序，指示它们的显示顺序或优先级。</p><p>**create_date (创建时间)**：日期类型，不能为空，确保记录文章的创建日期。没有指定默认值，需要在文章创建时提供。</p><p>**create_user (创建角色)**：整型，长度为20，不能为空，记录创建文章的用户ID。这对于追踪作者身份或管理目的很有用。</p><p>**update_date (更新时间)**：日期类型，不能为null，保证记录文章最后的更新时间。这个字段对于追踪文章最近的更改非常重要。</p><p>(2)认证表</p><p>总体而言，这个数据表设计用于跟踪个人简历相关的认证信息，包括认证的名称、相关文件、获得认证的日期，以及认证所属的简历。允许某些字段为空（如认证名称、文件名和获取日期）提供了灵活性，以便于在还没有详细信息的情况下先行记录认证，根据需求如表3-2所示。</p><p>表<strong>3-2　tb_certificate</strong>表</p><table><thead><tr><th>字段名称</th><th>字段类型</th><th>长度</th><th>非空</th><th>默认值</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>5</td><td>true</td><td></td><td>认证表id</td></tr><tr><td>name</td><td>varchar</td><td>100</td><td>false</td><td></td><td>名字</td></tr><tr><td>file</td><td>varchar</td><td>100</td><td>false</td><td></td><td>文件名</td></tr><tr><td>obtain_date</td><td>date</td><td>0</td><td>false</td><td></td><td>认证日期</td></tr><tr><td>resume_id</td><td>int</td><td>5</td><td>false</td><td></td><td>简历id</td></tr></tbody></table><p>**id (认证表id)**：整型，不允许为空（非空为true），这意味着每条认证记录都会有一个唯一的标识符。作为表的主键，这个字段不需要默认值，通常在插入新记录时由数据库自动生成（如设置为自增ID）。</p><p>**name (名字)**：字符串类型（varchar），最大长度为100字符，允许为空（非空为false）。这个字段可能用于存储认证或证书的名称。</p><p>**file (文件名)**：字符串类型，最大长度为100字符，同样允许为空。这可能用于存储认证文件的名称或路径，如证书的电子版。</p><p>**obtain_date (认证日期)**：日期类型，允许为空。用于记录获取认证的日期。</p><p>**resume_id (简历id)**：整型，允许为空。这个字段可能用于关联到特定的简历记录，表明这个认证是属于哪份简历的。这样可以方便地将认证信息与相应的简历联系起来。</p><p>(3)栏目表</p><p>此数据表设计考虑到了栏目管理的多样性，包括层级结构、内容管理、显示排序和状态标记等，根据需求如表3-3所示。</p><p>表<strong>3-3　tb_channel</strong>表</p><table><thead><tr><th>字段名称</th><th>字段类型</th><th>长度</th><th>非空</th><th>默认值</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>10</td><td>true</td><td></td><td>栏目表id</td></tr><tr><td>name</td><td>varchar</td><td>100</td><td>false</td><td></td><td>栏目名字</td></tr><tr><td>parent_id</td><td>int</td><td>5</td><td>false</td><td></td><td>父id</td></tr><tr><td>channel_img</td><td>varchar</td><td>100</td><td>false</td><td></td><td>栏目图片</td></tr><tr><td>summary</td><td>varchar</td><td>200</td><td>false</td><td></td><td>总结</td></tr><tr><td>single</td><td>char</td><td>1</td><td>false</td><td></td><td>单身</td></tr><tr><td>url</td><td>varchar</td><td>100</td><td>false</td><td></td><td>url地址</td></tr><tr><td>content</td><td>text</td><td>255</td><td>false</td><td></td><td>内容</td></tr><tr><td>sort</td><td>int</td><td>5</td><td>false</td><td></td><td>种类</td></tr><tr><td>create_date</td><td>date</td><td>0</td><td>false</td><td></td><td>创建日期</td></tr><tr><td>create_user</td><td>int</td><td>5</td><td>false</td><td></td><td>创建用户</td></tr><tr><td>deleted_flag</td><td>char</td><td>1</td><td>false</td><td></td><td>是否删除</td></tr><tr><td>postion</td><td>int</td><td>5</td><td>false</td><td></td><td>职位</td></tr></tbody></table><p>**id (栏目表id)**：整型，长度为10，非空。作为主键，这个字段唯一标识每个栏目记录。</p><p>**name (栏目名字)**：字符串类型（varchar），最大长度为100字符，可以为空。存储栏目的名称。</p><p>**parent_id (父id)**：整型，长度为5，可以为空。用于实现栏目的层级结构，存储上一级栏目的id。</p><p>**channel_img (栏目图片)**：字符串类型，最大长度为100字符，可以为空。存储与栏目相关联的图片文件名或路径。</p><p>**summary (总结)**：字符串类型，最大长度为200字符，可以为空。提供栏目的简短描述或总结。</p><p>**single (单身)**：字符类型，长度为1，可以为空。这个字段可能用于标识栏目是否为“单页”栏目，常用于不需要子页面的栏目，如公司介绍页面。值可能为“Y”表示是单页，或“N”表示不是单页。</p><p>**url (url地址)**：字符串类型，最大长度为100字符，可以为空。可能用于存储栏目或相关页面的URL地址。</p><p>**content (内容)**：文本类型，长度为255，可以为空。用于存储栏目的详细内容或介绍。</p><p>**sort (种类)**：整型，长度为5，可以为空。用于指定栏目在列表或菜单中的排序顺序。</p><p>**create_date (创建日期)**：日期类型，可以为空。记录栏目创建的日期。</p><p>**create_user (创建用户)**：整型，长度为5，可以为空。记录创建栏目的用户id。</p><p>**deleted_flag (是否删除)**：字符类型，长度为1，可以为空。用于标识栏目是否已被删除，通常“Y”表示已删除，“N”表示未删除。</p><p>**postion (职位)**：整型，长度为5，可以为空。</p><p>(4)企业表</p><p>此数据表设计涵盖了企业信息管理的基本需求，包括企业的基本识别信息、联系方式、业务描述等，根据需求如表3-4所示。</p><p>表<strong>3-4　tb_company</strong>表</p><table><thead><tr><th>字段名称</th><th>字段类型</th><th>长度</th><th>非空</th><th>默认值</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>10</td><td>true</td><td></td><td>企业表id</td></tr><tr><td>name</td><td>varchar</td><td>100</td><td>false</td><td></td><td>企业名称</td></tr><tr><td>account</td><td>varchar</td><td>100</td><td>false</td><td></td><td>企业账户</td></tr><tr><td>password</td><td>varchar</td><td>100</td><td>false</td><td></td><td>密码</td></tr><tr><td>contact</td><td>varchar</td><td>100</td><td>false</td><td></td><td>联系</td></tr><tr><td>telephone</td><td>varchar</td><td>100</td><td>false</td><td></td><td>电话</td></tr><tr><td>email</td><td>varchar</td><td>100</td><td>false</td><td></td><td>电子邮件</td></tr><tr><td>addr</td><td>varchar</td><td>200</td><td>false</td><td></td><td>地址</td></tr><tr><td>url</td><td>varchar</td><td>100</td><td>false</td><td></td><td>图片url</td></tr><tr><td>size</td><td>varchar</td><td>100</td><td>false</td><td></td><td>大小</td></tr><tr><td>type</td><td>varchar</td><td>100</td><td>false</td><td></td><td>类型</td></tr><tr><td>logo</td><td>varchar</td><td>100</td><td>false</td><td></td><td>标志</td></tr><tr><td>description</td><td>text</td><td>255</td><td>false</td><td></td><td>描述</td></tr></tbody></table><p>**id (企业表id)**：整型，长度为10，非空。作为主键，这个字段为每个企业记录提供唯一标识。</p><p>**name (企业名称)**：字符串类型（varchar），最大长度为100字符，可以为空。存储企业的正式名称。</p><p>**account (企业账户)**：字符串类型，最大长度为100字符，可以为空。用于企业用户登录的账户名。</p><p>**password (密码)**：字符串类型，最大长度为100字符，可以为空。存储企业账户的登录密码。</p><p>**contact (联系)**：字符串类型，最大长度为100字符，可以为空。指定企业的主要联系人。</p><p>**telephone (电话)**：字符串类型，最大长度为100字符，可以为空。存储企业联系电话。</p><p>**email (电子邮件)**：字符串类型，最大长度为100字符，可以为空。用于企业的电子邮件地址。</p><p>**addr (地址)**：字符串类型，最大长度为200字符，可以为空。记录企业的物理地址。</p><p>**url (图片url)**：字符串类型，最大长度为100字符，可以为空。可能用于存储企业标志或其他相关图片的URL地址。</p><p>**size (大小)**：字符串类型，最大长度为100字符，可以为空。描述企业的规模，例如“小型”、“中型”、“大型”。</p><p>**type (类型)**：字符串类型，最大长度为100字符，可以为空。指示企业的业务类型或行业分类，例如“制造”、“服务”。</p><p>**logo (标志)**：字符串类型，最大长度为100字符，可以为空。存储企业标志图片的文件名或路径。</p><p>**description (描述)**：文本类型，长度标记为255，可以为空。用于提供关于企业的详细描述信息。</p><p>(5)字典表</p><p>这个数据表设计提供了一个灵活的方式来存储和管理键值对信息。这种设计允许系统动态地使用这些数据，而不是硬编码，从而提高了系统的可配置性和可维护性，根据需求如表3-5所示。</p><p>表<strong>3-5　tb_dict</strong>表</p><table><thead><tr><th>字段名称</th><th>字段类型</th><th>长度</th><th>非空</th><th>默认值</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>10</td><td>true</td><td></td><td>字典表id</td></tr><tr><td>dict_key</td><td>varchar</td><td>100</td><td>false</td><td></td><td>字典密匙</td></tr><tr><td>dict_val</td><td>varchar</td><td>100</td><td>false</td><td></td><td>动态视图</td></tr><tr><td>sort</td><td>int</td><td>10</td><td>false</td><td></td><td>大小</td></tr><tr><td>status</td><td>int</td><td>1</td><td>false</td><td>0</td><td>状态</td></tr><tr><td>type_id</td><td>int</td><td>10</td><td>false</td><td></td><td>类型id</td></tr></tbody></table><p>**id (字典表id)**：整型，长度为10，非空。作为主键，这个字段为每条字典记录提供唯一标识。</p><p>**dict_key (字典密匙)**：字符串类型（varchar），最大长度为100字符，可以为空。用作字典项的键，存储识别字典项的唯一标识符或名称。</p><p><strong>dict_val (动态视图)<strong>：字符串类型，最大长度为100字符，可以为空。虽然命名为“动态视图”，这里可能更多的是指存储与</strong>dict_key</strong>对应的值，用于各种用途，如配置项的值、显示名称等。</p><p>**sort (大小)**：整型，长度为10，可以为空。这个字段可能用于指定字典项的排序顺序，使得在展示或处理时可以按照一定的顺序进行。</p><p>**status (状态)**：整型，长度为1，可以为空，带有默认值0。这个字段用于标示字典项的状态，例如是否启用。0可能表示禁用，1表示启用，这样的设计使得可以轻松启用或禁用字典项而不需要删除记录。</p><p>**type_id (类型id)**：整型，长度为10，可以为空。这个字段用于关联字典项到一个特定的类型或分类，允许将字典项分组，这在有多个不同类型的字典项需要被区分时非常有用。</p><p>(6)实习经历表</p><p>这个数据表设计用于存储个人的实习经历信息，能够有效地记录和管理个人的实习经历信息，为简历提供丰富的背景资料，根据需求如表3-6所示。</p><p>表<strong>3-6　tb_experience</strong>表</p><table><thead><tr><th>字段名称</th><th>字段类型</th><th>长度</th><th>非空</th><th>默认值</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>10</td><td>true</td><td></td><td>实习经历id</td></tr><tr><td>company</td><td>varchar</td><td>100</td><td>false</td><td></td><td>公司名称</td></tr><tr><td>post</td><td>varchar</td><td>100</td><td>false</td><td></td><td>职位</td></tr><tr><td>salary</td><td>varchar</td><td>100</td><td>false</td><td></td><td>薪水</td></tr><tr><td>description</td><td>text</td><td>255</td><td>false</td><td></td><td>描述</td></tr><tr><td>join_date</td><td>date</td><td>0</td><td>false</td><td></td><td>开始日期</td></tr><tr><td>leave_date</td><td>date</td><td>0</td><td>false</td><td></td><td>离开日期</td></tr><tr><td>resume_id</td><td>int</td><td>10</td><td>false</td><td></td><td>简历标识</td></tr></tbody></table><p>**id (实习经历id)**：整型，长度为10，非空。作为主键，这个字段为每条实习记录提供唯一标识。</p><p>**company (公司名称)**：字符串类型（varchar），最大长度为100字符，可以为空。存储实习生所在公司的名称。</p><p>**post (<strong>职位</strong>)**：字符串类型，最大长度为100字符，可以为空。</p><p>**salary (薪水)**：字符串类型，最大长度为100字符，可以为空。记录实习期间的薪酬情况，可能是月薪或总薪水。</p><p>**description (描述)**：文本类型，长度为255，可以为空。用于提供实习经历的详细描述，包括工作职责、成就等。</p><p>**join_date (开始日期)**：日期类型，可以为空。记录实习开始的日期。</p><p>**leave_date (离开日期)**：日期类型，可以为空。记录实习结束的日期。</p><p>**resume_id (简历标识)**：整型，长度为10，可以为空。这个字段用于将实习经历关联到特定的简历上，使得每份简历可以包含多条实习经历。</p><p>(7)收藏表</p><p>这个数据表设计用于存储学生对职位的收藏信息，此数据表的设计允许求职平台或校园招聘系统追踪用户（学生）的收藏行为，包括收藏的公司和职位，以及收藏的时间。这样的设计对于分析用户偏好、优化推荐算法、提供个性化的职位推送等方面非常有用。通过分析收藏数据，平台可以更好地理解用户的兴趣和需求，从而提高用户体验和满意度，根据需求如表3-7所示。</p><p>表<strong>3-7　favor</strong>表</p><table><thead><tr><th>字段名称</th><th>字段类型</th><th>长度</th><th>非空</th><th>默认值</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>10</td><td>true</td><td></td><td>收藏表id</td></tr><tr><td>company_id</td><td>int</td><td>10</td><td>false</td><td></td><td>关联公司表id</td></tr><tr><td>post_id</td><td>int</td><td>10</td><td>false</td><td></td><td>关联post_id</td></tr><tr><td>student_id</td><td>int</td><td>10</td><td>false</td><td></td><td>关联学生id</td></tr><tr><td>favor_date</td><td>date</td><td>0</td><td>false</td><td></td><td>收藏日期</td></tr></tbody></table><p>**id (收藏表id)**：整型，长度为10，非空。作为主键，这个字段为每条收藏记录提供唯一标识。</p><p>**company_id (关联公司表id)**：整型，长度为10，可以为空。这个字段用于关联到一个特定的公司记录，表示用户收藏的职位所属的公司。</p><p>**post_id (关联post_id)**：整型，长度为10，可以为空。用于关联到具体的职位记录，指明用户收藏的是哪一个职位。</p><p>**student_id (关联学生id)**：整型，长度为10，可以为空。表示进行收藏操作的学生用户，通过这个字段可以查询到哪些学生收藏了某个职位或公司。</p><p>**favor_date (收藏日期)**：日期类型，可以为空。记录用户收藏职位的日期。</p><p>(8)意向表</p><p>这个数据表设计用于存储求职者的工作意向信息，是简历或个人资料管理系统中的一个重要组成部分。此数据表的设计使得简历管理系统能够详细记录求职者的工作偏好，包括期望的薪酬、工作地点、工作类型以及行业领域。这样的信息对于求职者来说非常重要，因为它帮助雇主更好地了解求职者的职业目标和期望，从而提高匹配的准确性和效率，根据需求如表3-8所示。</p><p>表<strong>3-8　intention</strong>表</p><table><thead><tr><th>字段名称</th><th>字段类型</th><th>长度</th><th>非空</th><th>默认值</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>10</td><td>true</td><td></td><td>意向表id</td></tr><tr><td>name</td><td>varchar</td><td>100</td><td>false</td><td></td><td>姓名</td></tr><tr><td>salary</td><td>varchar</td><td>100</td><td>false</td><td></td><td>期望薪水</td></tr><tr><td>city</td><td>varchar</td><td>100</td><td>false</td><td></td><td>期望城市</td></tr><tr><td>type</td><td>varchar</td><td>100</td><td>false</td><td></td><td>期望工作类型</td></tr><tr><td>industry</td><td>varchar</td><td>100</td><td>false</td><td></td><td>期望行业</td></tr><tr><td>resume_id</td><td>int</td><td>10</td><td>false</td><td></td><td>简历id</td></tr></tbody></table><p>**id (意向表id)**：整型，长度为10，非空。作为主键，这个字段为每条工作意向记录提供唯一标识。</p><p>**name (姓名)**：字符串类型（varchar），最大长度为100字符，可以为空。存储表达工作意向的求职者的姓名。</p><p>**salary (期望薪水)**：字符串类型，最大长度为100字符，可以为空。记录求职者期望的薪水范围或具体数额。</p><p>**city (期望城市)**：字符串类型，最大长度为100字符，可以为空。表示求职者希望工作的城市或地区。</p><p>**type (期望工作类型)**：字符串类型，最大长度为100字符，可以为空。指求职者期望的工作性质，如全职、兼职、远程工作等。</p><p>**industry (期望行业)**：字符串类型，最大长度为100字符，可以为空。描述求职者希望进入的工作行业，如信息技术、教育、金融等。</p><p>**resume_id (简历id)**：整型，长度为10，可以为空。用于将工作意向信息关联到具体的简历记录上，使得每份简历可以包含一条或多条工作意向信息。</p><p>(9)菜单表</p><p>此数据表的设计提供了一个灵活的方式来管理系统菜单，支持层级结构的菜单项、带有图标的菜单显示、权限控制以及链接跳转功能。通过<strong>parent_id</strong>字段实现的菜单层级结构允许构建从简单到复杂的菜单体系，而<strong>perms</strong>字段的权限标识则使得可以根据用户的权限动态显示菜单项，增强了系统的安全性和个性化体验，根据需求如表3-9所示。</p><p>表<strong>3-9　menu</strong>表</p><table><thead><tr><th>字段名称</th><th>字段类型</th><th>长度</th><th>非空</th><th>默认值</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>10</td><td>true</td><td></td><td>菜单id</td></tr><tr><td>name</td><td>varchar</td><td>100</td><td>false</td><td></td><td>菜单名称</td></tr><tr><td>icon</td><td>varchar</td><td>100</td><td>false</td><td></td><td>图标</td></tr><tr><td>href</td><td>varchar</td><td>100</td><td>false</td><td></td><td>跳转</td></tr><tr><td>perms</td><td>varchar</td><td>100</td><td>false</td><td></td><td>权限</td></tr><tr><td>parent_id</td><td>int</td><td>10</td><td>false</td><td></td><td>父id</td></tr><tr><td>type</td><td>int</td><td>10</td><td>false</td><td></td><td>类型</td></tr></tbody></table><p>**id (菜单id)**：整型，长度为10，非空。作为主键，这个字段为每个菜单项提供唯一标识。</p><p>**name (菜单名称)**：字符串类型（varchar），最大长度为100字符，可以为空。存储菜单项的显示名称。</p><p>**icon (图标)**：字符串类型，最大长度为100字符，可以为空。用于存储显示在菜单名称旁的图标的标识或路径。</p><p>**href (跳转)**：字符串类型，最大长度为100字符，可以为空。记录点击菜单项后的跳转链接，指向菜单项关联的页面或操作。</p><p>**perms (权限)**：字符串类型，最大长度为100字符，可以为空。指定访问该菜单项所需的权限标识，用于控制不同用户访问菜单的权限。</p><p><strong>parent_id (父id)<strong>：整型，长度为10，可以为空。用于实现菜单的层级结构，存储上一级菜单的id。顶级菜单的</strong>parent_id</strong>可能为0或特定的空值表示。</p><p>**type (类型)**：整型，长度为10，可以为空。表示菜单项的类型，通常用于区分不同种类的菜单项，如目录、页面链接、功能操作等。具体的类型值需要根据系统设计确定，例如，0可以表示目录，1表示页面链接，2表示功能操作等。</p><p>(10)职位表</p><p>此数据表的设计能够有效地记录和管理招聘帖子的关键信息，包括职位名称、学历要求、薪水范围以及详细的职位描述。这些信息对于求职者来说是非常重要的，因为它们帮助求职者了解职位详情并决定是否申请，根据需求如表3-10所示。</p><p>表<strong>3-10　tb_post</strong>表</p><table><thead><tr><th>字段名称</th><th>字段类型</th><th>长度</th><th>非空</th><th>默认值</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>10</td><td>true</td><td></td><td>职位id</td></tr><tr><td>name</td><td>varchar</td><td>100</td><td>false</td><td></td><td>帖子名称</td></tr><tr><td>education</td><td>varchar</td><td>100</td><td>false</td><td></td><td>学历</td></tr><tr><td>salary</td><td>varchar</td><td>100</td><td>false</td><td></td><td>薪水</td></tr><tr><td>description</td><td>text</td><td>255</td><td>false</td><td></td><td>描述</td></tr><tr><td>company_id</td><td>int</td><td>5</td><td>false</td><td></td><td>公司id</td></tr></tbody></table><p>**id (职位id)**：整型，长度为10，非空。作为主键，这个字段为每条帖子提供唯一标识。</p><p>**name (帖子名称)**：字符串类型（varchar），最大长度为100字符，可以为空。存储帖子的标题或名称，通常用于简要描述招聘职位。</p><p>**education (学历)**：字符串类型，最大长度为100字符，可以为空。记录应聘该职位所需的最低学历要求，如“本科”、“硕士”等。</p><p>**salary (薪水)**：字符串类型，最大长度为100字符，可以为空。描述该职位的薪资范围或具体薪资，帮助求职者了解薪酬情况。</p><p><strong>description (描述)<strong>：文本类型，长度为255（实际上，</strong>text</strong>类型字段通常用于存储较长文本，所以这个长度限制可能是非必要的），可以为空。用于提供职位的详细描述，包括职责、要求、工作环境等信息。</p><p>**company_id (公司id)**：整型，长度为5，可以为空。用于将招聘帖子关联到发布该帖子的公司记录上，使得可以查询到该公司发布的所有招聘帖子。</p><p>(11)预测表</p><p>此数据表的设计能够有效地记录学生的职业倾向和期望，包括期望的工作、城市、公司以及薪资等信息。这些信息对于提供个性化的职业规划建议、教育咨询服务以及职业发展指导非常有价值，根据需求如表3-11所示。</p><p>表<strong>3-11　tb_predict</strong>表</p><table><thead><tr><th>字段名称</th><th>字段类型</th><th>长度</th><th>非空</th><th>默认值</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>5</td><td>true</td><td></td><td>预测id</td></tr><tr><td>sex</td><td>varchar</td><td>255</td><td>false</td><td></td><td>性别</td></tr><tr><td>profession</td><td>varchar</td><td>255</td><td>false</td><td></td><td>专业</td></tr><tr><td>job</td><td>varchar</td><td>255</td><td>false</td><td></td><td>期望工作</td></tr><tr><td>city</td><td>varchar</td><td>255</td><td>false</td><td></td><td>期望城市</td></tr><tr><td>company</td><td>varchar</td><td>255</td><td>false</td><td></td><td>公司</td></tr><tr><td>salary</td><td>varchar</td><td>255</td><td>false</td><td></td><td>薪水</td></tr><tr><td>score</td><td>varchar</td><td>255</td><td>false</td><td></td><td>分数</td></tr><tr><td>student_id</td><td>int</td><td>5</td><td>false</td><td></td><td>学生id</td></tr></tbody></table><p>**id (预测id)**：整型，长度为5，非空。作为主键，这个字段为每条预测记录提供唯一标识。</p><p>**sex (性别)**：字符串类型（varchar），最大长度为255字符，可以为空。记录学生的性别。</p><p>**profession (专业)**：字符串类型，最大长度为255字符，可以为空。记录学生的专业领域。</p><p>**job (期望工作)**：字符串类型，最大长度为255字符，可以为空。描述学生期望从事的工作职位。</p><p>**city (期望城市)**：字符串类型，最大长度为255字符，可以为空。表示学生希望工作的城市或地区。</p><p>**company (公司)**：字符串类型，最大长度为255字符，可以为空。记录学生期望加入的公司或组织。</p><p>**salary (薪水)**：字符串类型，最大长度为255字符，可以为空。描述学生期望的薪资范围或具体薪资。</p><p>**score (分数)**：字符串类型，最大长度为255字符，可以为空。可能用于记录某种评估或预测算法给出的分数，该分数可能反映学生的职业倾向强度、成功概率等。</p><p>**student_id (学生id)**：整型，长度为5，可以为空。用于将职业预测信息关联到特定的学生记录上，使得可以查询到某个学生的所有职业预测信息。</p><p>(12)专业表</p><p>此数据表的设计允许构建一个多层级的专业分类体系，支持从广泛的领域到具体的专业细分的层级关系。这种层级结构对于教育机构来说非常有用，因为它能够清晰地组织和展示不同专业及其子专业的关系，帮助学生和教师更好地了解和选择专业，根据需求如表3-12所示。</p><p>表<strong>3-12　tb_profession</strong>表</p><table><thead><tr><th>字段名称</th><th>字段类型</th><th>长度</th><th>非空</th><th>默认值</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>5</td><td>true</td><td></td><td>专业id</td></tr><tr><td>name</td><td>varchar</td><td>100</td><td>false</td><td></td><td>专业名称</td></tr><tr><td>parent_id</td><td>int</td><td>5</td><td>false</td><td></td><td>父id</td></tr></tbody></table><p>**id (专业id)**：整型，长度为5，非空。作为主键，这个字段为每个专业提供唯一标识。</p><p>**name (专业名称)**：字符串类型（varchar），最大长度为100字符，可以为空。存储专业的正式名称。</p><p><strong>parent_id (父id)<strong>：整型，长度为5，可以为空。用于实现专业层级结构，存储上一级专业的id。顶级专业的</strong>parent_id</strong>可能为0或特定的空值表示，表示该专业没有上级专业，即它是一个顶级分类。</p><p>(13)项目表</p><p>此数据表的设计能够有效地记录和管理个人简历中的项目经验信息，为求职者提供一个展示其项目参与和贡献的平台。通过详细的项目描述以及清晰的开始和结束时间，求职者可以向潜在雇主展示其项目管理和技术实施能力，根据需求如表3-13所示。</p><p>表<strong>3-13　tb_project</strong>表</p><table><thead><tr><th>字段名称</th><th>字段类型</th><th>长度</th><th>非空</th><th>默认值</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>5</td><td>true</td><td></td><td>项目id</td></tr><tr><td>name</td><td>varchar</td><td>100</td><td>false</td><td></td><td>项目名称</td></tr><tr><td>description</td><td>text</td><td>255</td><td>false</td><td></td><td>项目描述</td></tr><tr><td>start_date</td><td>date</td><td>0</td><td>false</td><td></td><td>开始时间</td></tr><tr><td>end_date</td><td>date</td><td>0</td><td>false</td><td></td><td>结束时间</td></tr><tr><td>resume_id</td><td>int</td><td>5</td><td>false</td><td></td><td>简历id</td></tr></tbody></table><p>**id (项目id)**：整型，长度为5，非空。作为主键，这个字段为每个项目提供唯一标识。</p><p>**name (项目名称)**：字符串类型（varchar），最大长度为100字符，可以为空。存储项目的正式名称，为项目经验提供简要识别信息。</p><p><strong>description (项目描述)<strong>：文本类型，虽然标注长度为255，但实际上</strong>text</strong>类型通常用于存储较长的文本，所以这个长度限制可能是非必要的。用于提供关于项目的详细描述，包括项目目标、主要成就、使用技术等。</p><p>**start_date (开始时间)**：日期类型，可以为空。记录项目开始的日期，帮助说明项目的时间线。</p><p>**end_date (结束时间)**：日期类型，可以为空。记录项目结束的日期，进一步明确项目的持续时间。</p><p>**resume_id (简历id)**：整型，长度为5，可以为空。用于将项目经验信息关联到特定的简历记录上，使得每份简历可以包含一条或多条项目经验信息。</p><p>(14)简历表</p><p>此数据表的设计能够有效地管理求职者的简历信息，支持简历的创建、编辑、查看和管理等功能。通过<strong>student_id</strong>字段的关联，系统可以轻松管理每个学生或求职者的多份简历，同时<strong>status</strong>字段允许求职者根据需要控制简历的公开状态和完成度，根据需求如表3-14所示。</p><p>表<strong>3-14　tb_resume</strong>表</p><table><thead><tr><th>字段名称</th><th>字段类型</th><th>长度</th><th>非空</th><th>默认值</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>5</td><td>true</td><td></td><td>简历id</td></tr><tr><td>name</td><td>varchar</td><td>100</td><td>false</td><td></td><td>简历名称</td></tr><tr><td>job_status</td><td>varchar</td><td>50</td><td>false</td><td></td><td>工作状态</td></tr><tr><td>evaluate</td><td>text</td><td>255</td><td>false</td><td></td><td>评价</td></tr><tr><td>skill</td><td>text</td><td>255</td><td>false</td><td></td><td>技能</td></tr><tr><td>student_id</td><td>int</td><td>5</td><td>false</td><td></td><td>学生id</td></tr><tr><td>status</td><td>int</td><td>5</td><td>false</td><td></td><td>状态</td></tr></tbody></table><p>**id (简历id)**：整型，长度为5，非空。作为主键，为每份简历记录提供唯一标识。</p><p>**name (简历名称)**：字符串类型（varchar），最大长度为100字符，可以为空。存储简历的标题或名称，便于用户区分和管理不同的简历版本或针对不同职位的简历。</p><p>**job_status (工作状态)**：字符串类型（varchar），最大长度为50字符，可以为空。描述求职者当前的工作状态，如“在职寻新机会”、“主动求职”、“离职”等，有助于雇主了解求职者的就业意向。</p><p><strong>evaluate (评价)<strong>：文本类型，长度为255（虽然标记为255，但</strong>text</strong>类型通常用于存储较长文本，实际长度限制可能更宽松），可以为空。用于求职者对自己的自我评价，包括个人的职业目标、优势、成就等，有助于向雇主展示个人的价值和特点。</p><p>**skill (技能)**：文本类型，长度为255，可以为空。列举求职者的专业技能、技术栈、语言能力等，对于职位匹配和筛选非常重要。</p><p>**student_id (学生id)**：整型，长度为5，可以为空。用于将简历关联到特定的学生或求职者记录上，使得每个学生或求职者可以有一个或多个简历。</p><p>**status (状态)**：整型，长度为5，可以为空。用于表示简历的状态</p><p>(15)关联表</p><p>此数据表的设计能够有效地追踪和管理求职者与职位之间的应聘关系，包括应聘的公司、职位、所用简历以及应聘的状态和时间。这种设计对于招聘网站和人才管理系统来说非常重要，因为它帮助求职者跟踪自己的应聘进度，同时也让雇主了解哪些求职者对他们的职位感兴趣，根据需求如表3-15所示。</p><p>表<strong>3-15　tb_send</strong>表</p><table><thead><tr><th>字段名称</th><th>字段类型</th><th>长度</th><th>非空</th><th>默认值</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>10</td><td>true</td><td></td><td>关联表id</td></tr><tr><td>company_id</td><td>int</td><td>10</td><td>false</td><td></td><td>公司id</td></tr><tr><td>post_id</td><td>int</td><td>10</td><td>false</td><td></td><td>post表id</td></tr><tr><td>resume_id</td><td>int</td><td>10</td><td>false</td><td></td><td>简历id</td></tr><tr><td>send_date</td><td>date</td><td>0</td><td>false</td><td></td><td>修改时间</td></tr><tr><td>status</td><td>int</td><td>10</td><td>false</td><td></td><td>状态</td></tr><tr><td>student_id</td><td>int</td><td>10</td><td>false</td><td></td><td>学生id</td></tr></tbody></table><p>**id (关联表id)**：整型，长度为10，非空。作为主键，为每条应聘记录提供唯一标识。</p><p>**company_id (公司id)**：整型，长度为10，可以为空。用于关联到特定的公司记录，表示学生向哪个公司发送了简历。</p><p>**post_id (post表id)**：整型，长度为10，可以为空。用于关联到具体的职位记录，指明学生应聘的是哪一个职位。</p><p>**resume_id (简历id)**：整型，长度为10，可以为空。用于关联到学生发送的具体简历记录。</p><p>**send_date (修改时间)**：日期类型，可以为空。记录学生发送简历的日期。字段名称“修改时间”可能有误，更准确的描述应该是“发送日期”或“应聘日期”。</p><p>**status (状态)**：整型，长度为10，可以为空。用于表示应聘记录的当前状态。</p><p>**student_id (学生id)**：整型，长度为10，可以为空。用于关联到发送简历的学生（求职者）记录。</p><p>(16)学生用户表</p><p>此数据表的设计能够详细记录学生的个人信息和学术背景，支持教育和招聘相关系统的核心功能，如账户管理、学生档案维护、职业规划等。通过<strong>profession_id</strong>字段的关联，系统可以清晰地管理学生的专业信息，而<strong>graduate_date</strong>和<strong>education</strong>字段有助于了解学生的学术进程和资历，根据需求如表3-16所示。</p><p>表<strong>3-16　tb_student</strong>表</p><table><thead><tr><th>字段名称</th><th>字段类型</th><th>长度</th><th>非空</th><th>默认值</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>20</td><td>true</td><td></td><td>学生id</td></tr><tr><td>name</td><td>varchar</td><td>100</td><td>false</td><td></td><td>姓名</td></tr><tr><td>account</td><td>varchar</td><td>100</td><td>false</td><td></td><td>账户</td></tr><tr><td>password</td><td>varchar</td><td>100</td><td>false</td><td></td><td>密码</td></tr><tr><td>birthday</td><td>date</td><td>0</td><td>false</td><td></td><td>生日</td></tr><tr><td>profession_id</td><td>int</td><td>20</td><td>false</td><td></td><td>专业id</td></tr><tr><td>college</td><td>varchar</td><td>100</td><td>false</td><td></td><td>大学</td></tr><tr><td>education</td><td>varchar</td><td>100</td><td>false</td><td></td><td>学历</td></tr><tr><td>phone</td><td>varchar</td><td>100</td><td>false</td><td></td><td>电话</td></tr><tr><td>sex</td><td>varchar</td><td>50</td><td>false</td><td></td><td>性别</td></tr><tr><td>photo</td><td>varchar</td><td>100</td><td>false</td><td></td><td>照片</td></tr><tr><td>graduate_date</td><td>date</td><td>0</td><td>false</td><td></td><td>毕业日期</td></tr></tbody></table><p>**id (学生id)**：整型，长度为20，非空。作为主键，为每位学生提供唯一标识。</p><p>**name (姓名)**：字符串类型（varchar），最大长度为100字符，可以为空。存储学生的全名。</p><p>**account (账户)**：字符串类型，最大长度为100字符，可以为空。用于学生登录系统的账户名。</p><p>**password (密码)**：字符串类型，最大长度为100字符，可以为空。存储账户的登录密码。</p><p>**birthday (生日)**：日期类型，可以为空。记录学生的出生日期。</p><p>**profession_id (专业id)**：整型，长度为20，可以为空。用于关联到学生所学专业的具体记录。</p><p>**college (大学)**：字符串类型，最大长度为100字符，可以为空。记录学生就读的大学或学院名称。</p><p>**education (学历)**：字符串类型，最大长度为100字符，可以为空。描述学生的最高学历，如“本科”、“硕士”等。</p><p>**phone (电话)**：字符串类型，最大长度为100字符，可以为空。存储学生的联系电话。</p><p>**sex (性别)**：字符串类型，最大长度为50字符，可以为空。记录学生的性别，如“男”、“女”等。</p><p>**photo (照片)**：字符串类型，最大长度为100字符，可以为空。用于存储学生照片的文件路径或URL。</p><p>**graduate_date (毕业日期)**：日期类型，可以为空。记录学生的预计或实际毕业日期。</p><p>(17)培训经历表</p><p>此数据表的设计允许求职者在简历中详细列出他们的培训经历，包括培训的时间、地点、课程等信息。这些信息对于展示求职者的持续学习和专业发展非常有价值，尤其是对于那些需要特定技能或知识的职位，根据需求如表3-17所示。</p><p>表<strong>3-17　tb_train</strong>表</p><table><thead><tr><th>字段名称</th><th>字段类型</th><th>长度</th><th>非空</th><th>默认值</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>20</td><td>true</td><td></td><td>培训id</td></tr><tr><td>start_date</td><td>date</td><td>0</td><td>false</td><td></td><td>开始时间</td></tr><tr><td>end_date</td><td>date</td><td>0</td><td>false</td><td></td><td>结束时间</td></tr><tr><td>company</td><td>varchar</td><td>100</td><td>false</td><td></td><td>公司名称</td></tr><tr><td>course</td><td>varchar</td><td>100</td><td>false</td><td></td><td>课程</td></tr><tr><td>resume_id</td><td>int</td><td>10</td><td>false</td><td></td><td>简历</td></tr></tbody></table><p>**id (培训id)**：整型，长度为20，非空。作为主键，为每条培训记录提供唯一标识。</p><p>**start_date (开始时间)**：日期类型，可以为空。记录培训开始的日期。</p><p>**end_date (结束时间)**：日期类型，可以为空。记录培训结束的日期。</p><p>**company (公司名称)**：字符串类型（varchar），最大长度为100字符，可以为空。存储提供培训的公司或机构名称。</p><p>**course (课程)**：字符串类型，最大长度为100字符，可以为空。描述参加的培训课程名称或内容。</p><p>**resume_id (简历)**：整型，长度为10，可以为空。用于将培训经历关联到特定的简历记录上，表明该培训经历属于哪份简历。</p><p>(18)企业字段表</p><p>这个数据表设计用于存储企业信息，根据需求如表3-18所示。</p><p>表<strong>3-18　tb_type</strong>表</p><table><thead><tr><th>字段名称</th><th>字段类型</th><th>长度</th><th>非空</th><th>默认值</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>20</td><td>true</td><td></td><td>企业id</td></tr><tr><td>name</td><td>varchar</td><td>100</td><td>false</td><td></td><td>企业名称</td></tr></tbody></table><p>**id (企业id)**：整型，长度为20，非空。作为主键，这个字段为每个企业提供唯一标识。在数据库中，这样的设计确保了每家企业都可以通过一个唯一的ID进行索引和引用，便于管理和查询。</p><p>**name (企业名称)**：字符串类型（varchar），最大长度为100字符，可以为空。存储企业的官方名称。在实际应用中，虽然此字段设置为可以为空，但考虑到企业名称是基本且关键的信息，实际操作时可能会要求此字段非空，以确保每条企业记录都有明确的识别信息。</p><p>(19)管理员用户表</p><p>此数据表的设计能够有效管理系统管理员的基本账户信息，支持身份验证、权限控制和安全监控等功能。通过<strong>user_name</strong>和<strong>password</strong>字段实现基本的登录验证，而<strong>login_time</strong>字段有助于跟踪管理员的活动，增强系统安全，根据需求如表3-19所示。</p><p>表<strong>3-19　tb_user</strong>表</p><table><thead><tr><th>字段名称</th><th>字段类型</th><th>长度</th><th>非空</th><th>默认值</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>20</td><td>true</td><td></td><td>管理员id</td></tr><tr><td>user_name</td><td>varchar</td><td>100</td><td>false</td><td></td><td>用户名</td></tr><tr><td>name</td><td>varchar</td><td>100</td><td>false</td><td></td><td>名字</td></tr><tr><td>password</td><td>varchar</td><td>100</td><td>false</td><td></td><td>密码</td></tr><tr><td>login_time</td><td>date</td><td>0</td><td>false</td><td></td><td>登陆时间</td></tr></tbody></table><p>**id (管理员id)**：整型，长度为20，非空。作为主键，这个字段为每个管理员账户提供唯一标识，确保每位管理员都可以通过一个唯一的ID进行索引和引用。</p><p>**user_name (用户名)**：字符串类型（varchar），最大长度为100字符，可以为空。用于管理员登录系统的用户名。在实际应用中，通常要求此字段非空且唯一，以避免登录时的混淆和安全问题。</p><p>**name (名字)**：字符串类型，最大长度为100字符，可以为空。存储管理员的真实姓名或昵称，用于系统内部显示或日志记录。</p><p>**password (密码)**：字符串类型，最大长度为100字符，可以为空。用于账户登录的密码。出于安全考虑，密码应通过加密存储，并在实际操作时要求非空。</p><p>**login_time (登陆时间)**：日期类型，可以为空。记录管理员最后一次登录系统的时间，有助于监控账户使用情况和安全管理。</p><h1 id="4-系统的实现"><a href="#4-系统的实现" class="headerlink" title="4　系统的实现"></a>4　系统的实现</h1><h2 id="4-1-登录功能"><a href="#4-1-登录功能" class="headerlink" title="4.1　登录功能"></a>4.1　登录功能</h2><p><img src="D:/HEXO/source/_posts/media/image29.png">输入 <a href="http://localhost:8080/">http://localhost:8080/</a> 后 打 开管理 系 统 ，在进行系统登录过程中，登录首页会将账号、密码和身份传入到后台的业务逻辑当 中，同时与数据库中已有的数据进行对比，如果数据比对相同，会检查数据库中的该数 据的状态是否符合登录的条件，如果符合登录的条件，则登录成功，如果不符合登录的 条件，则登录失败，给出提示条件，以便用户正确的登陆。用户登录成功后，不同用户 登录到各自对于的系统当中，进行相应的系统操作，管理员身份的用户登录后系统首页 显示的是系统相关的基本信息，如图4-1所示。</p><p>图<strong>4-1</strong>　登录功能界面</p><h2 id="4-2-注册功能"><a href="#4-2-注册功能" class="headerlink" title="4.2　注册功能"></a>4.2　注册功能</h2><h3 id="4-2-1学生注册"><a href="#4-2-1学生注册" class="headerlink" title="4.2.1学生注册"></a>4.2.1学生注册</h3><p>注册功能需要使用人员输入姓名、账号、密码、确认密码、手机号后才能成功注册用户。如果输入的姓名为空，提示请输入姓名，输入密码为空，提示请输入密码，确认密码若不正确则会提示请输入正确的密码，输入的电话为空或电话格式不正确，提示请输入正确的电话格式；如果输入姓名、电话和邮箱不为空且格式正确，会提示注册用户成功，并且返回用户的初始账号和员工号，使用初始账号就可以在登录界面登录进入管理后台。如图4-2所示。</p><p><img src="D:/HEXO/source/_posts/media/image30.png"> 图<strong>4-2</strong>　学生账号注册界面</p><h3 id="4-2-2企业注册"><a href="#4-2-2企业注册" class="headerlink" title="4.2.2企业注册"></a>4.2.2企业注册</h3><p><img src="D:/HEXO/source/_posts/media/image31.png">企业注册功能需要使用人员输入姓名、账号、密码、确认密码、联系人、联系电话后才能成功注册用户。如果输入的姓名为空，提示请输入姓名，输入密码为空，提示请输入密码，确认密码若不正确则会提示请输入正确的密码，输入的电话为空或电话格式不正确，提示请输入正确的电话格式；如果输入姓名、电话和邮箱不为空且格式正确，会提示注册用户成功，并且返回用户的初始账号和员工号，使用初始账号就可以在登录界面登录进入管理后台，如图4-3所示。</p><p>图<strong>4-3</strong>　企业账号注册界面</p><h2 id="4-3-学生管理页面功能"><a href="#4-3-学生管理页面功能" class="headerlink" title="4.3　学生管理页面功能"></a>4.3　学生管理页面功能</h2><h3 id="4-3-1-学生基本信息管理"><a href="#4-3-1-学生基本信息管理" class="headerlink" title="4.3.1　学生基本信息管理"></a>4.3.1　学生基本信息管理</h3><p><img src="D:/HEXO/source/_posts/media/image32.png">此页面为学生基本信息填写页面，学生可以在这里编辑自己的姓名、出生日期、毕业院校，也可以选择学历，编写电话，性别等信息上传自己的照片，点击保存按钮，即可将填写的信息保存到数据库的学生信息表中，也可以点击重置按钮清空所有选项重新填写，如图4-4所示。</p><p>图<strong>4-4</strong>　学生基本信息编辑界面</p><p>4.3.2学生简历管理</p><p><img src="D:/HEXO/source/_posts/media/image33.png">学生简历管理可以查看已编写好的简历。点击新增按钮即可添加简历，可在添加简历页面编写简历的名称，当前的求职状态，自我评价技能描述和当前简历是否为开放状态，其中求职状态分为待业，可立即上岗和在岗考虑新工作两个选项，编写简历的所有选项不能为空，若为空则提示：该项为空请填写，如图4-5所示。</p><p>图<strong>4-5</strong>　简历管理界面</p><h3 id="4-3-3求职意向管理"><a href="#4-3-3求职意向管理" class="headerlink" title="4.3.3求职意向管理"></a>4.3.3求职意向管理</h3><p><img src="D:/HEXO/source/_posts/media/image34.png">求职意向界面可查看当前中国就业率的分布情况的可视化数据图和自己已填写的就业意向，点击新增按钮即可编辑添加意向，需选择自己以编写好的简历，若简历为空则此项不可填写，还需要填写自己的意向职位，意向薪资，意向工作城市，工作性质和期望的行业，点击保存按钮即可添加此条数据到数据库，并展示在求职意向界面中，如图4-6所示。</p><p>图<strong>4-6</strong>　求职意向管理界面</p><h3 id="4-3-4培训经历管理"><a href="#4-3-4培训经历管理" class="headerlink" title="4.3.4培训经历管理"></a>4.3.4培训经历管理</h3><p><img src="D:/HEXO/source/_posts/media/image35.png">培训经历管理页面可查看培训经历的可视化图和自己已编写好的培训经历，点击新增按钮可添加，其中必须有自己的简历，培训的开始时间结束时间，培训机构和培训的课程名称等信息，且如上信息为必填选项，若未填写则会提示，该选项为空请填写，如图4-7所示。</p><p>图<strong>4-7</strong>　培训经历管理界面</p><h3 id="4-3-5证书管理"><a href="#4-3-5证书管理" class="headerlink" title="4.3.5证书管理"></a>4.3.5证书管理</h3><p><img src="D:/HEXO/source/_posts/media/image36.png">证书管理界面可查看自己的获奖证书，可以点击新增按钮添加证书。需填写证书名称，也可上传不超过2m的文件，还需填写证书的获奖时间等信息。也可以勾选需要修改的正书信息进行修改，如图4-8所示。</p><p>图<strong>4-8</strong>　证书管理界面</p><h3 id="4-3-6项目经验管理"><a href="#4-3-6项目经验管理" class="headerlink" title="4.3.6项目经验管理"></a>4.3.6项目经验管理</h3><p><img src="D:/HEXO/source/_posts/media/image37.png">项目经验管理可查看自己写过的项目信息和项目占比的可视化图，点击新增按钮可添加项目，其中项目中需包含简历，可填写项目的名称开始时间结束时间和项目的描述，如图4-9所示。</p><p>图<strong>4-9</strong>　项目经验管理界面</p><h3 id="4-3-7新增实习经历"><a href="#4-3-7新增实习经历" class="headerlink" title="4.3.7新增实习经历"></a>4.3.7新增实习经历</h3><p><img src="D:/HEXO/source/_posts/media/image38.png">可在实习经历页面中新增自己的实习经历。其中需要有已编写好的简历，需填写公司名称，职位，薪水，描述入职时间和离职时间，其中公司名称和职位为必填项，若为空则会显示，该项为空请填写，如图4-10所示。</p><p>图<strong>4-10</strong>　实习经历编辑界面</p><h3 id="4-3-8职位收藏"><a href="#4-3-8职位收藏" class="headerlink" title="4.3.8职位收藏"></a>4.3.8职位收藏</h3><p><img src="D:/HEXO/source/_posts/media/image39.png">职位收藏页面可以查看学生在企业发布的职位中添加的已收藏职位，并可以通过勾选进行职业的删除，可以查看该职位的名称及发布职位的公司和收藏的日期等信息，如图4-11所示。</p><p>图<strong>4-11</strong>　职位收藏界面</p><h3 id="4-3-9简历的投递情况查看"><a href="#4-3-9简历的投递情况查看" class="headerlink" title="4.3.9简历的投递情况查看"></a>4.3.9简历的投递情况查看</h3><p><img src="D:/HEXO/source/_posts/media/image40.png">简历投递界面可查看学生在首页中投递的职位内容并可以查看该职位的名称和职位对应的公司，该公司是否已查看自己简历和投递日期等信息，也可以管理投递信息进行删除操作，如图4-12所示。</p><p>图<strong>4-12</strong>　简历投递查看界面</p><h2 id="4-4-管理员管理页面功能"><a href="#4-4-管理员管理页面功能" class="headerlink" title="4.4　管理员管理页面功能"></a>4.4　管理员管理页面功能</h2><h3 id="4-4-1-用户信息管理"><a href="#4-4-1-用户信息管理" class="headerlink" title="4.4.1　用户信息管理"></a>4.4.1　用户信息管理</h3><p><img src="D:/HEXO/source/_posts/media/image41.png">在系统管理员用户的权限下登录，拥有添加管理员用户，并查看已添加的管理员用户的账号和密码。也可以点击修改按钮，对已有的管理员用户的权限及账号密码进行修改，点击新增按钮输入新增管理员的用户名姓名及密码即可添加管理员用户，如图4-13所示。</p><p>图<strong>4-13</strong>　管理员账号信息界面</p><h3 id="4-4-2学生账号管理"><a href="#4-4-2学生账号管理" class="headerlink" title="4.4.2学生账号管理"></a>4.4.2学生账号管理</h3><p>在系统管理员用户的权限下登录，拥有管理学生账号的功能，进入页面即可查看每个学生账号的对应信息，根据学生信息查询并搜索学生账号。可以对学生账号的密码进行修改和删除学生账号，如图4-14所示。</p><p><img src="D:/HEXO/source/_posts/media/image42.png">图<strong>4-14</strong>　学生账号信息查看界面</p><h3 id="4-4-3企业账号管理"><a href="#4-4-3企业账号管理" class="headerlink" title="4.4.3企业账号管理"></a>4.4.3企业账号管理</h3><p><img src="D:/HEXO/source/_posts/media/image43.png">在系统管理员用户的权限下登录，拥有查看企业账户信息的功能，并可以通过输入关键词对企业账户进行精确的搜索，勾选单个企业用户点击修改可以修改企业账户的密码，也可以删除企业账户，如图4-15所示。</p><p>图<strong>4-15</strong>　企业账号信息查看界面</p><h3 id="4-4-4发布文章的审核及管理"><a href="#4-4-4发布文章的审核及管理" class="headerlink" title="4.4.4发布文章的审核及管理"></a>4.4.4发布文章的审核及管理</h3><p><img src="D:/HEXO/source/_posts/media/image44.png">在系统管理员用户的权限下登录，拥有对每个企业已发布的招聘文章进行查看和相应的修改删除操作。用于审核企业发布的文章是否符合规定。手动修改企业发布文章的栏目属性分类，如图4-16所示。</p><p>图<strong>4-16</strong>　文章信息发布界面</p><h2 id="4-5企业账号管理功能"><a href="#4-5企业账号管理功能" class="headerlink" title="4.5企业账号管理功能"></a>4.5企业账号管理功能</h2><h3 id="4-5-1企业基本信息管理"><a href="#4-5-1企业基本信息管理" class="headerlink" title="4.5.1企业基本信息管理"></a>4.5.1企业基本信息管理</h3><p><img src="D:/HEXO/source/_posts/media/image45.png">在企业账户的权限下登录。拥有编辑并修改企业基本信息的功能。可修改该企业的网址、名称、联系人、联系电话、邮箱、地址、规模、公司类型、logo及公司描述等信息，如图4-17所示。</p><p>图<strong>4-17</strong>　企业基本信息编辑界面</p><h3 id="4-5-2职位管理"><a href="#4-5-2职位管理" class="headerlink" title="4.5.2职位管理"></a>4.5.2职位管理</h3><p><img src="D:/HEXO/source/_posts/media/image46.png">在企业账户的权限下登录，点击职位管理页面，可查看自己已添加的招聘职位信息，并可以修改这些信息，通过点击新增按钮添加需要招聘的职位名称，需填写学历，要求职位，薪水，职位，描述职位等信息，也可以对自己发布的职位进行删除，如图4-18所示。</p><p>图<strong>4-18</strong>　企业职位管理界面</p><h2 id="4-6系统页面"><a href="#4-6系统页面" class="headerlink" title="4.6系统页面"></a>4.6系统页面</h2><h3 id="4-6-1系统首页"><a href="#4-6-1系统首页" class="headerlink" title="4.6.1系统首页"></a>4.6.1系统首页</h3><p><img src="D:/HEXO/source/_posts/media/image47.png">通过浏览器访问系统主页即可看到主页页面，在主页页面的右上角设置有管理中心入口，用户可以根据自己的身份选择相应的入口。主页页面主要展示了和招聘就业有关的新闻信息，根据时间排序，此外，在主页的菜单栏还可以选择查看招聘信息和求职信息，点击管理中心则可以登录系统。 为了方便用户查看信息，主页右侧还设置了轮播图。由于招聘信息是用户广泛关注的内容，因此在右侧边栏还可以看到最新 的招聘信息，如图4-19所示。</p><p>图<strong>4-19</strong>　系统首页</p><h3 id="4-6-2新闻动态标题查看"><a href="#4-6-2新闻动态标题查看" class="headerlink" title="4.6.2新闻动态标题查看"></a>4.6.2新闻动态标题查看</h3><p><img src="D:/HEXO/source/_posts/media/image48.png">点击首页导航栏中新闻动态选项，即可跳转到查看文章列表的相应内容。本页面可查看各大企业发布的招聘信息文章，并且在右侧的网站公示栏中查看相应的招聘会内容，如图4-20所示。</p><p>图<strong>4-20</strong>　新闻动态查看界面</p><h3 id="4-6-3文章详情的查看"><a href="#4-6-3文章详情的查看" class="headerlink" title="4.6.3文章详情的查看"></a>4.6.3文章详情的查看</h3><p><img src="D:/HEXO/source/_posts/media/image49.png">在招聘信息文章中，点击相应的文章即可查看到具体的文章内容。其中可以看到本文章的发布时间，作者及当前浏览量等内容，如图4-21所示。</p><p>图<strong>4-21</strong>　文章界面</p><h3 id="4-6-4开放职位"><a href="#4-6-4开放职位" class="headerlink" title="4.6.4开放职位"></a>4.6.4开放职位</h3><p><img src="D:/HEXO/source/_posts/media/image50.png">点击首页导航栏中职位搜索功能。即可查看到各大企业开放的对应职位。如果是学生用户登录的此界面。则可以点击职位申请和职位收藏按钮。并将对应收藏的职位添加到学生信息页面中职位收藏页面，如图4-22所示。</p><p>图<strong>4-22</strong>　开放职位信息界面</p><h1 id="5-系统测试"><a href="#5-系统测试" class="headerlink" title="5　系统测试"></a>5　系统测试</h1><p><img src="D:/HEXO/source/_posts/media/image51.png">系统测试（System Testing）是将已经确认的软件、硬件、外设、网络等多种元素结 合起来，针对整个系统进行测试。目的就是要验证就业管理系统能否满足测试要求，找 到不足原因和有差异的地方，并加以修正。系统测试应基于系统整体需求的黑盒测试， 应覆盖整个系统全部的功能测试。系统测试的对象不仅要包括测试的软件稳定的运行， 而且还要包括系统对硬件和数据接口的指标测试等。系统测试流程图见 5-1所示。</p><p>图<strong>5-1</strong>　登录功能界面</p><p>系统测试主要为功能测试，即验证软件功能执行的是否正确，主要依据是需求文档和设计文档，由 于系统功能正确性是软件最重要指标，因此功能测试的好坏直接影响到系统的应用。</p><h2 id="5-1学生端功能测试内容"><a href="#5-1学生端功能测试内容" class="headerlink" title="5.1学生端功能测试内容"></a>5.1学生端功能测试内容</h2><p>由于就业管理系统的前台功能模块过于复杂，并且各个模块下的功能过于繁 多，由于篇幅有限，因此只测试以下几个常用和关键的核心模块。</p><h3 id="5-1-1学生登录功能测试"><a href="#5-1-1学生登录功能测试" class="headerlink" title="5.1.1学生登录功能测试"></a>5.1.1学生登录功能测试</h3><p>就业学生登入测试主要是验证就业学生登陆系统的用户名和密码的一致性是 否正确。如表 5-1 所示</p><p>表**5-1　**登陆测试表</p><table><thead><tr><th>测试内容</th><th>测试结果</th><th>是否通过</th></tr></thead><tbody><tr><td>用户名为空</td><td>请输入用户名</td><td>通过</td></tr><tr><td>密码未输入</td><td>请输入密码</td><td>通过</td></tr><tr><td>密码不正确</td><td>你输入的密码有误，请重新输入</td><td>通过</td></tr></tbody></table><p>（2）就业者进行注册的数据测试结果如表 5-2 所示:</p><p>表**5-2　**注册测试表</p><table><thead><tr><th>登录号</th><th>密码</th><th>再次输入密码</th><th></th><th>预期结果</th><th>实际结果</th></tr></thead><tbody><tr><td>张三</td><td>1234</td><td></td><td>123456</td><td>注册成功</td><td>密码不一致注册失败</td></tr><tr><td>李四</td><td>142555</td><td></td><td>142555</td><td>注册成功</td><td>注册成功</td></tr></tbody></table><h3 id="5-1-2-学生简历修改测试"><a href="#5-1-2-学生简历修改测试" class="headerlink" title="5.1.2　学生简历修改测试"></a>5.1.2　学生简历修改测试</h3><p>学生简历修改功能测试用例如表5-3学生简历修改功能测试用例表所示。如果输入编号顺序不同，则会弹出失败提示，输入简历名称则可以修改成功，并且页面跳转。</p><p>表**5-3　**学生简历修改功能测试用例表</p><table><thead><tr><th>功能</th><th>操作</th><th>预期结果</th><th>实际结果</th><th>是否通过</th></tr></thead><tbody><tr><td>学生简历修改功能</td><td>修改简历的编号</td><td>未修改成功，页面不跳转，提示信息为“简历修改失败，请检查编号是否输入正确！”</td><td>与预期结果相同</td><td>通过</td></tr><tr><td></td><td>修改简历的名称，点击确定</td><td>修改成功，页面跳转，提示信息为“简历信息更改成功！”</td><td>与预期结果相同</td><td>通过</td></tr></tbody></table><h3 id="5-1-3-学生新增求职意向功能测试"><a href="#5-1-3-学生新增求职意向功能测试" class="headerlink" title="5.1.3　学生新增求职意向功能测试"></a>5.1.3　学生新增求职意向功能测试</h3><p>学生新增求职意向功能测试用例如表5-4所示，登录系统管理员用户以后，拥有新增求职意向的功能，在学生管理页面点击“新增”，弹出新增求职意向页面，填写相关的求职意向信息，点击保存，页面的求职意向列表则会实时显示该新增的数据，并在页面上部分弹出“添加成功”。</p><p>表<strong>5-4</strong>　新增求职意向功能测试用例表</p><table><thead><tr><th>功能</th><th>操作</th><th>预期结果</th><th>实际结果</th><th>是否通过</th></tr></thead><tbody><tr><td>新增求职意向功能</td><td>选择已编写好的简历</td><td>无法创建成功，并且提示“请选择简历”</td><td>与预期结果相同</td><td>通过</td></tr><tr><td></td><td>输入选择简历、职位名称、薪资、工作城市等必选项，并点击保存按钮</td><td>意向添加成功，并且提示“该求职意向添加成功”</td><td>与预期结果相同</td><td>通过</td></tr></tbody></table><h3 id="5-1-4-项目经验修改功能测试"><a href="#5-1-4-项目经验修改功能测试" class="headerlink" title="5.1.4　项目经验修改功能测试"></a>5.1.4　项目经验修改功能测试</h3><p>项目经验修改功能测试用例如表5-5项目经验修改功能测试用例表所示，学生用户可以在项目经验列表查看到已添加的项目经验的同时，点击已添加的项目经验选项，并点击修改即可跳转到项目经验修改的界面，该界面可从数据库中查询到选择的项目数据学生可修改简历、项目名称、开始时间、结束时间、项目描述等信息，并点击保存按钮，若填写信息无误则提示保存成功</p><p>表<strong>5-5</strong>　项目经验修改功能测试用例表</p><table><thead><tr><th>功能</th><th>操作</th><th>预期结果</th><th>实际结果</th><th>是否通过</th></tr></thead><tbody><tr><td>项目经验修改功能</td><td>修改选项漏填项目名称</td><td>无法提交修改，并且提示“项目名称不能为空”</td><td>与预期结果相同</td><td>通过</td></tr><tr><td></td><td>修改选项漏简历</td><td>无法提交修改，并且提示“简历不能为空，请创建简历”</td><td>与预期结果相同</td><td>通过</td></tr><tr><td></td><td>填写所有打星号的内容，并点击保存按钮</td><td>项目经验添加成功，并在前端页面进行数据的回显</td><td>与预期结果相同</td><td>通过</td></tr></tbody></table><h3 id="5-1-5-证书查询功能测试"><a href="#5-1-5-证书查询功能测试" class="headerlink" title="5.1.5　证书查询功能测试"></a>5.1.5　证书查询功能测试</h3><p>证书查询功能测试用例如表5-6证书查询功能测试用例表所示，在证书管理模块，可以在搜索栏中输入不同的内容来查询证书是否存在，而且可进行模糊查询输入证书的部分内容可查询到单条和多条有关证书的信息，其中包括证书ID、系统编号、证书名称，获得时间及附件等内容。</p><p>表**5-6　**证书查询功能测试用例表</p><table><thead><tr><th>功能</th><th>操作</th><th>预期结果</th><th>实际结果</th><th>是否通过</th></tr></thead><tbody><tr><td>证书查询功能</td><td>输入一个没有的证书名称，并点击查询</td><td>显示“暂无数据，请输入有效证书”</td><td>与预期结果相同</td><td>通过</td></tr><tr><td></td><td>输入已有证书的部分名称进行模糊查询操作</td><td>显示对应证书的单条或多条数据</td><td>与预期结果相同</td><td>通过</td></tr><tr><td></td><td>输入已有证书的完整名称进行精准查询</td><td>显示对应的单条证书名称、ID、获得时间等信息</td><td>与预期结果相同</td><td>通过</td></tr></tbody></table><h2 id="5-2企业端功能测试内容"><a href="#5-2企业端功能测试内容" class="headerlink" title="5.2企业端功能测试内容"></a>5.2企业端功能测试内容</h2><h3 id="5-2-1-企业logo文件上传功能测试"><a href="#5-2-1-企业logo文件上传功能测试" class="headerlink" title="5.2.1　企业logo文件上传功能测试"></a>5.2.1　企业logo文件上传功能测试</h3><p>企业logo文件上传功能测试用例如表5-7企业logo文件上传功能测试用例表所示，在企业用户登录，并查看基本信息模块中，对企业logo图片文件的上传进行了测试，若上传一个大于2M，或者文件格式不符合要求的文件则会上传失败，上传的文件必须符合要求即可上传成功并提示logo上传成功，并在页面上显示该logo图片。</p><p>表**5-7　**企业logo文件上传功能测试用例表</p><table><thead><tr><th>功能</th><th>操作</th><th>预期结果</th><th>实际结果</th><th>是否通过</th></tr></thead><tbody><tr><td>企业logo文件上传功能</td><td>上传一个非jpg&#x2F;png格式文件</td><td>无法提交文件，提示“文件格式有误，请检查文件格式”</td><td>与预期结果相同</td><td>通过</td></tr><tr><td></td><td>上传一个大于2M的png图片</td><td>无法提交文件，提示“文件大小不能超过2M，请重新上传！”</td><td>与预期结果相同</td><td>通过</td></tr><tr><td></td><td>格式正确且大小正确，并上传文件</td><td>文件上传成功，数据存储在数据库中，并更新信息列表</td><td>与预期结果相同</td><td>通过</td></tr></tbody></table><h1 id="6-结-论"><a href="#6-结-论" class="headerlink" title="6　结　论"></a>6　结　论</h1><p>高校毕业生的就业工作是每年学校工作的重头戏，社会关注度高，关系着毕业生的前途也影响到学校的形象和发展。本系统的开发和使用推动了校园的信息化建设，很大程度上提高了高校毕业生就业工作的工作效率，对就业工作的工作流程进行了梳理和规范。本系统的服务对象主要是毕业生、用人单位和高校就业管理人员。在系统的分析过程中，紧紧围绕着学生充分就业为中心，为毕业生和用人单位提供充分了解和沟通的信息渠道，及时有效的进行信息更新，同时最大程度上减轻就业工作的工作负担。系统建设过程充分了解各方需求，对系统功能进行优化，保证了用户管理、在线交流、应聘双选、发布信息等功能的实现。在设计过程中，采用Java和MySQL进行B&#x2F;S三层架构设计，降低了系统开发的成本，提高了系统的实用性。该系统在试用过程中基本满足了各方需求，有效的提高了就业工作的工作效率。2012年全国近2000所高校的680多万毕业生将面临求职择业，2014年全国普通高校毕业生690万，2015年724万人，并且这一数字还将逐年上升，高校毕业生就业压力还将进一步增大。因此，高校就业系统的开发，能够在一定程度上对高校就业工作起到引导作用，促进校园信息化建设。</p><p>本系统实现了对系统信息功能的管理，就业者信息功能的管理，用人单位信息功能的管理，就业信息功能的管理。本系统的实现意义是为了解决当前就业者与用人单位不能及时的做相互交流与沟通，这样就会使得就业者可以及时地得到用人单位的邀请信息，从而找到适合个人的用人单位；用人单位也能及时地招聘到适合的就业者，从而获得双赢。而且这种形式的系统也会使得就业服务机构的管理得到完善和快速、准确。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol><li><p>张晨祥,宁璐,冯明歌.高校就业数据可视化管理系统设计与实现[J].电脑编程技巧与维护,2022,(09):74-77</p></li><li><p>刘雪峰.大数据时代高校就业管理精细化研究[J&#x2F;OL].内蒙古大学学报(哲学社会科学版), 2023,(12): 1-7</p></li><li><p>周常志,甘恒.基于SpringBoot的智慧就业服务平台的设计与实现[J].电脑知识与技术,2021,17(28):182-184+187</p></li><li><p>陈颖灵,朱映辉,江玉珍等.基于SpringBoot学生实训管理系统的设计与实现[J].电脑知识与技术,2022,18(19):49-51</p></li><li><p>沈懿卓.基于数据挖掘技术的高校《就业指导》网络课程建设研究[D].上海师范大学,2023(12)</p></li><li><p>白旭东.大学生就业信息智能分析系统的研究与开发[D].北方工业大学,2020</p></li><li><p>王子静,刘思雨.基于ECharts的交易数据可视化系统的设计与实现[J].集成电路应用, 2023, 40(5):244-245. [8]尚衍亮.基于推荐系统的大学生就业的研究[J].山东青年, 2019(5):3.</p></li><li><p>周刚,黄继红,严亚雄.基于WEB的高校就业信息系统设计与实现[J].山西电子技术, 2022, 000(004):65-67</p></li><li><p>[贺晓敏.基于J2EE的高校毕业生就业信息管理系统的开发[D].南昌大学,2023</p></li><li><p>郭佳.数据挖掘技术在高校学生就业信息管理系统中的应用研究[J].桂林师范高等专科学校学报, 2019, 029(003):148-150.</p></li><li><p>郗盛兰刘海兰.我国高校毕业生就业研究的知识图谱——基于中国知网CSSCI(2010-2020)数据库[J].中国大学生就业（理论版）, 2021, 000(001):47-54.</p></li><li><p>李艳,丁国强,张庆.网络招聘数据可视化系统的设计与实现[J].信息与电脑, 2021, 033(001):112-115.</p></li><li><p>王晓东,吴文广,左风云,等.基于全流程管理大学生创新创业项目管理系统[J].内蒙古医科大学学报, 2019(S2)</p></li><li><p>季震,苏白,李杰,等.基于校园卡数据的大学生消费特征分析[C]&#x2F;&#x2F;2019年(第四届)全国大学生统计建模大赛论文.2019.</p></li><li><p>杜英魁,王杨,关屏,等.基于Spring Boot的云端数据监控管理与可视化应用系统[J].计算机系统应用, 2020, 29(5):5</p></li><li><p>王鑫,冯程,曹江波,等.基于Spring Boot的数据可视化方法,装置以及存储介质:CN202111328095.6[P].CN202111328095.6.2023</p></li><li><p>姜楠,庄新庆,李宣廷.基于SpringBoot的成绩可视化系统设计与实现[J].大连民族学院学报, 2020, 022(005):448-452.</p></li><li><p>郝希亮,张海鹏.基于Web的多维数据可视化系统设计[J].软件导刊, 2020, 17(8):4</p></li><li><p>杜英魁,王杨,关屏,et al.基于Spring Boot的云端数据监控管理与可视化应用系统[J].计算机系统应用, 29(5).2023(12)</p></li><li><p>王颖瑞.药房信息管理系统的设计与实现[D].北京：北京邮电大学，2020.</p></li></ol><h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;本科生毕业论文（设计）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基于数据可视化的大学生就业管理系统设计与实现&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;院（系）名称&lt;/th&gt;
&lt;th&gt;：&lt;/th&gt;
&lt;th&gt;计算机科学</summary>
      
    
    
    
    
    <category term="工具" scheme="https://xu-zi-kang.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>【面试】面试题总结</title>
    <link href="https://xu-zi-kang.github.io/2024/03/03/%E3%80%90%E9%9D%A2%E8%AF%95%E3%80%91%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>https://xu-zi-kang.github.io/2024/03/03/%E3%80%90%E9%9D%A2%E8%AF%95%E3%80%91%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</id>
    <published>2024-03-03T08:09:17.000Z</published>
    <updated>2024-03-16T04:36:35.174Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-JDK和JRE-有什么区别？"><a href="#1-JDK和JRE-有什么区别？" class="headerlink" title="1.JDK和JRE 有什么区别？"></a>1.JDK和JRE 有什么区别？</h2><p>jvm是java虚拟机。JRE有核心类库：java.lang 包。JDK里包含JRE，给java开发人员使用</p><h2 id="2-和equals的区别是什么？"><a href="#2-和equals的区别是什么？" class="headerlink" title="2.&#x3D;&#x3D;和equals的区别是什么？"></a>2.&#x3D;&#x3D;和equals的区别是什么？</h2><p>&#x3D;&#x3D;是判断两个对象的地址是不是相等(基本数据类型&#x3D;&#x3D;比较的是值相等，引用行数据类型&#x3D;&#x3D;比较的是内存地址，即是否来自同一个对象)<br>equals也是判断两个对象是否相等：<br>类没有覆盖equals方法比较的是两个对象是否为同一对象，等价于通过&#x3D;&#x3D;比较两个对象<br>类覆盖方法的话比较的是两对象的内容是否相等（一般是两个对象）<br>String中的equals方法是被重写过了的</p><p>&#x3D;&#x3D; : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同 一个对象。(基本数据类型 &#x3D;&#x3D; 比较的是值，引用数据类型 &#x3D;&#x3D; 比较的是内存地址) equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况： 情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时， 等价于通过“&#x3D;&#x3D;”比较这两个对象。 情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象 的内容相等；若它们的内 容相等，则返回 true (即，认为这两个对象相等)。 举个例子：</p><p><img src="https://cdn.jsdelivr.us/gh/Asakushen/pic/2024/03/07/36f500.png" alt="image-20230817135932905"><br>说明：<br>String中的equals方法是被重写过的，因为object的equals方法是比较的对象的 内存地址，而 String的equals方法比较的是对象的值。 当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要 创建的值相同的对 象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建 一个String对象。</p><h2 id="3-String-类的常用方法都有那些？"><a href="#3-String-类的常用方法都有那些？" class="headerlink" title="3.String 类的常用方法都有那些？"></a>3.String 类的常用方法都有那些？</h2><p>equals:比较字符串<br>split:分割字符串<br>subString:截取字符串<br>length:返回字符串长度<br>indexOf:返回指定字符的索引<br>charAt:返回指定索引处的字符<br>replace:字符串的替换<br>trim:去除字符串两端的空白<br>getBytes:返回字符串的byte类型数组<br>toLowerCase:将字符串转换成小写字母<br>toUpperCase:将字符串转换成大写字母</p><h2 id="4-接口和抽象类的区别？"><a href="#4-接口和抽象类的区别？" class="headerlink" title="4.接口和抽象类的区别？"></a>4.接口和抽象类的区别？</h2><ul><li>接口默认是public的</li><li>方法在接口中不能实现</li><li>接口不能new实例化，只能声明</li><li>一个类实现接口需要实现接口中所有的方法，而抽象类不一定</li><li>一个类可以实现多个接口，但只能实现一个抽象类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getSpeed</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; is sleeping.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，<code>Vehicle</code> 是一个接口，它定义了 <code>start()</code>、<code>stop()</code> 和 <code>getSpeed()</code> 三个方法。接口中的方法默认是抽象的，因此没有具体的实现。</p><p><code>Animal</code> 是一个抽象类，它包含了一个私有的字段 <code>name</code> 和一个构造方法用于初始化该字段。抽象类中可以包含抽象方法和具体方法。在上面的例子中，<code>makeSound()</code> 是一个抽象方法，没有具体的实现，而 <code>sleep()</code> 是一个具体方法，它有一个默认的实现。抽象类可以有字段、构造方法、具体方法和抽象方法的组合。</p><p>接口和抽象类都是用来定义类的结构和行为的，但它们有一些区别。接口只能定义抽象方法和常量，而抽象类可以包含字段和具体方法。一个类可以实现多个接口，但只能继承一个抽象类。接口用于描述类的行为，而抽象类通常用于作为其他具体类的基类，提供一些通用的方法和字段。</p><h2 id="5-Java-中i0-流分为几种？"><a href="#5-Java-中i0-流分为几种？" class="headerlink" title="5.Java 中i0 流分为几种？"></a>5.Java 中i0 流分为几种？</h2><p>按功能来分：输入流 (input）、输出流 (output)。<br>按类型来分：字节流和字符流。<br>字节流和字符流的区别是：字节流按8位传输以字节为单位输入输出数据，宇符流按16位传输以字符为单位输入输出数据。</p><h2 id="6-Java-容器（集合）都有哪些？"><a href="#6-Java-容器（集合）都有哪些？" class="headerlink" title="6.Java 容器（集合）都有哪些？"></a>6.Java 容器（集合）都有哪些？</h2><p>list，set，map。<br>list有序的，可重复，允许有多个null。set是无序的，不可重复，只能有一个null。map只能在key上有一个null，value可以有多个null</p><h2 id="7-HashMap-和Hashtable-有什么区别？"><a href="#7-HashMap-和Hashtable-有什么区别？" class="headerlink" title="7.HashMap 和Hashtable 有什么区别？"></a>7.HashMap 和Hashtable 有什么区别？</h2><ul><li>HashTable是线程同步，HashMap非线程同步</li><li>HashTable不允许&lt;key,value&gt;有空值，HashMap允许&lt;key,value&gt;有空值</li><li>HashTable使用Enumeration，HashMap使用Iterator。</li><li>TreeMap能够把它保存的记录根据键排序，默认是按升序排序。</li><li>HashTable中hash数组的默认大小是11，增加方式的old*2+1，HashMap中hash数组的默认大小 是16，增长方式一定是2的指数倍。</li></ul><h2 id="8-有哪些方式可以遍历一个-Map"><a href="#8-有哪些方式可以遍历一个-Map" class="headerlink" title="8.有哪些方式可以遍历一个 Map?"></a>8.有哪些方式可以遍历一个 Map?</h2><p>keySet，entrySet，迭代器</p><ol><li><p>使用 <code>keySet()</code> 方法遍历键：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;K, V&gt; map = ...; <span class="comment">// 假设为要遍历的 Map</span></span><br><span class="line"><span class="keyword">for</span> (K key : map.keySet()) &#123;</span><br><span class="line">    <span class="comment">// 获取键对应的值</span></span><br><span class="line">    <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">    <span class="comment">// 处理键值对</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>entrySet()</code> 方法遍历键值对：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;K, V&gt; map = ...; <span class="comment">// 假设为要遍历的 Map</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;K, V&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">    <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">    <span class="comment">// 处理键值对</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用迭代器遍历键值对：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;K, V&gt; map = ...; <span class="comment">// 假设为要遍历的 Map</span></span><br><span class="line">Iterator&lt;Map.Entry&lt;K, V&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;K, V&gt; entry = iterator.next();</span><br><span class="line">    <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">    <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">    <span class="comment">// 处理键值对</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="9-线程和进程的区别？"><a href="#9-线程和进程的区别？" class="headerlink" title="9.线程和进程的区别？"></a>9.线程和进程的区别？</h2><p>线程是进程内部，</p><p>举个例子，可以将进程比作一个运行的程序，而线程则是程序中的一个执行路径。假设你在电脑上同时打开了多个应用程序，比如浏览器、音乐播放器和文本编辑器。每个应用程序都是一个进程，它们独立运行，并且拥有各自的内存空间和资源。而每个应用程序内部可能会有多个线程，比如浏览器中的渲染线程、网络请求线程和 JavaScript 执行线程等。这些线程共享浏览器进程的内存空间和资源，协同工作来完成各种任务，例如同时下载多个文件、渲染网页内容和响应用户交互等。在这个例子中，每个应用程序是一个进程，而应用程序内部的线程是在进程内部进行调度和执行的。</p><p>当我们试图理解进程和线程的区别时，可以通过比喻来简化这些概念。一个常用的比喻是将进程比作工厂，而线程则比作工厂里的工人。</p><h3 id="进程比作工厂"><a href="#进程比作工厂" class="headerlink" title="进程比作工厂"></a>进程比作工厂</h3><p>想象一个进程像是一个工厂。每个工厂（进程）拥有它自己的资源：建筑物（内存空间）、电力供应（CPU时间）、原料（程序代码和数据）等。每个工厂独立运作，生产产品（执行程序）。工厂之间互不干扰，它们各自管理自己的资源。如果一个工厂发生故障（进程崩溃），它不会影响到其他工厂的运作。</p><h3 id="线程比作工人"><a href="#线程比作工人" class="headerlink" title="线程比作工人"></a>线程比作工人</h3><p>在每个工厂内部，有许多工人（线程）在工作。这些工人共享工厂的资源：他们在同一建筑内工作，使用相同的电力供应和原料。但每个工人负责完成特定的任务（执行特定的代码段）。一些工人可能在装配线上工作（执行计算任务），而其他工人可能在包装部门（处理输入&#x2F;输出任务）。</p><p>工人之间可以轻松地互相沟通（线程间通信），因为他们处于同一个工厂内。他们可以直接交谈，交换工具或材料，而不需要通过外部邮递服务（进程间通信需要更复杂的机制）。</p><p>如果一个工人遇到问题（线程崩溃），这可能会影响到同一工厂内的其他工人，因为他们共享同样的工作环境。在最坏的情况下，这可能导致整个工厂停工（进程崩溃）。</p><h3 id="创建和管理"><a href="#创建和管理" class="headerlink" title="创建和管理"></a>创建和管理</h3><p>创建一个新工厂（进程）需要大量的资源和时间，因为你需要建造建筑物，安装设备，招聘员工等。相比之下，雇佣一个新工人（创建一个线程）成本较低，因为工厂的基础设施已经就绪，只需要为新工人提供一些个人工具和工作空间即可。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过将进程比作工厂，线程比作工人，我们可以更容易地理解它们之间的关系和区别。进程是资源分配和执行的独立单位，拥有自己的地址空间和资源。线程是进程内部的执行单位，共享进程的资源，但是能独立执行任务，提高工作效率。</p><h2 id="10-守护线程是什么？"><a href="#10-守护线程是什么？" class="headerlink" title="10.守护线程是什么？"></a>10.守护线程是什么？</h2><p>在 Java 中，守护线程（Daemon Thread）是一种特殊类型的线程，它是为其他线程提供服务的线程。与普通线程（用户线程）相比，守护线程具有以下特点：</p><ol><li>生命周期依赖：守护线程的生命周期依赖于其他非守护线程。当所有非守护线程都结束时，虚拟机会自动退出，不会等待守护线程执行完毕。</li><li>后台执行：守护线程在后台默默地执行任务，不会阻止程序的终止。当所有非守护线程结束后，守护线程会被自动终止。</li><li>资源释放：守护线程主要用于执行一些后台任务，如垃圾回收、自动保存等。它们通常不处理关键业务逻辑，因此在程序终止时，不需要手动释放守护线程所占用的资源。</li></ol><p>在 Java 中，可以通过 <code>setDaemon(true)</code> 方法将线程设置为守护线程。默认情况下，线程是非守护线程。</p><p>下面是一个简单的示例，演示了守护线程的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaemonThreadExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">daemonThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Daemon thread is running.&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        daemonThread.setDaemon(<span class="literal">true</span>); <span class="comment">// 将线程设置为守护线程</span></span><br><span class="line"></span><br><span class="line">        daemonThread.start(); <span class="comment">// 启动守护线程</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Main thread ends.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，创建了一个守护线程，它会每隔一秒输出一条信息。主线程启动守护线程后，立即结束，而守护线程会在后台一直运行，直到程序终止。</p><h2 id="11-创建线程有哪几种方式？"><a href="#11-创建线程有哪几种方式？" class="headerlink" title="11.创建线程有哪几种方式？"></a>11.创建线程有哪几种方式？</h2><h2 id="12-什么是反射？"><a href="#12-什么是反射？" class="headerlink" title="12.什么是反射？"></a>12.什么是反射？</h2><p><strong>什么是反射机制？</strong><br>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个 对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 java语言的反射机制。<br>静态编译和动态编译<br><strong>静态编译</strong>：在编译时确定类型，绑定对象<br><strong>动态编译</strong>：运行时确定类型，绑定对象<br><strong>反射机制优缺点</strong><br><strong>优点</strong>： 运行期类型的判断，动态加载类，提高代码灵活度。<br><strong>缺点</strong>： 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能 比直接的java代码要慢很多。<br><strong>反射机制的应用场景有哪些？</strong><br>反射是框架设计的灵魂。<br>在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实 际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。<br>举例：①我们在使用JDBC连接数据库时使用Class.forName()通过反射加载数据库的驱动程序；<br>②Spring框架也用到很多反射机制， 经典的就是xml的配置模式。Spring 通过 XML 配置模式装载 Bean 的过程：</p><p>1)将程序内所有 XML 或 Properties 配置文件加载入内存中;<br>2)Java类里面解析xml或 properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息;<br>3)使用反射机制，根据这 个字符串获得某个类的Class实例;<br>4)动态配置实例的属性</p><p><strong>Java获取反射的三种方法</strong><br>1.通过new对象实现反射机制 2.通过路径实现反射机制 3.通过类名实现反射机制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">String name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> sex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">float</span> score;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Get</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//获取反射机制三种方式</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//方式一(通过建立对象)</span></span><br><span class="line"></span><br><span class="line"> <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"></span><br><span class="line"> <span class="type">Class</span> <span class="variable">classobj1</span> <span class="operator">=</span> stu.getClass();</span><br><span class="line"></span><br><span class="line"> System.out.println(classobj1.getName());</span><br><span class="line"></span><br><span class="line"> <span class="comment">//方式二（所在通过路径-相对路径）</span></span><br><span class="line"></span><br><span class="line"> <span class="type">Class</span> <span class="variable">classobj2</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;fanshe.Student&quot;</span>);</span><br><span class="line"></span><br><span class="line"> System.out.println(classobj2.getName());</span><br><span class="line"></span><br><span class="line"> <span class="comment">//方式三（通过类名）</span></span><br><span class="line"></span><br><span class="line"> <span class="type">Class</span> <span class="variable">classobj3</span> <span class="operator">=</span> Student.class;</span><br><span class="line"></span><br><span class="line"> System.out.println(classobj3.getName());</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="13-什么是Java-序列化？什么情况下需要序列化？"><a href="#13-什么是Java-序列化？什么情况下需要序列化？" class="headerlink" title="13.什么是Java 序列化？什么情况下需要序列化？"></a>13.什么是Java 序列化？什么情况下需要序列化？</h2><h2 id="14-如何实现对象克隆？"><a href="#14-如何实现对象克隆？" class="headerlink" title="14.如何实现对象克隆？"></a>14.如何实现对象克隆？</h2><h2 id="15-深拷贝和浅拷贝区别是什么？"><a href="#15-深拷贝和浅拷贝区别是什么？" class="headerlink" title="15.深拷贝和浅拷贝区别是什么？"></a>15.深拷贝和浅拷贝区别是什么？</h2><p>浅拷贝（shallowCopy）只是增加了一个指针指向已存在的内存地址， 深拷贝（deepCopy）是增加了一个指针并且申请了一个新的内存，使这个增加 的指针指向这个新的内 存， 使用深拷贝的情况下，释放内存的时候不会因为出现浅拷贝时释放同一个内存的 错误。 浅复制：仅仅是指向被复制的内存地址，如果原地址发生改变，那么浅复制出来 的对象也会相应的改变。 深复制：在计算机中开辟一块新的内存地址用于存放复制的对象。</p><h2 id="16-session-和-cookie-有什么区别？"><a href="#16-session-和-cookie-有什么区别？" class="headerlink" title="16.session 和 cookie 有什么区别？"></a>16.session 和 cookie 有什么区别？</h2><ul><li>存储位置：session是存放在服务器端的，cookie是存放在浏览器里<ul><li>安全性：cookie可以被用户随意篡改，是不安全的。session将数据存放在数据库或者内存中，用户无法直接访问修改，是更加安全的<ul><li>跨域支持：cookie支持跨域访问，多个域名之间共享数据。而session通常与单个域名相关，不支持跨域<ul><li>生命周期：cookie的生命周期可以设置过期时间，在浏览器关闭后可以不销毁。而session的生命周期一般是伴随着浏览器的关闭或者超过一定时间不用了就会自动销毁。<ul><li>存储位置：cookie是存在浏览器的cookie文件中。而session是存在内存或者数据库中<ul><li>存储容量：cookie的存储容量是比较小的，session容量可以更大<ul><li>性能开销：session存储在服务器中，它是一个用户对应一个session，随着用户的数量增加，对服务器的负载也会变大。cookie存储在客户端中，对服务器的负载小</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h2 id="17-get-和post-请求有哪些区别？"><a href="#17-get-和post-请求有哪些区别？" class="headerlink" title="17.get 和post 请求有哪些区别？"></a>17.get 和post 请求有哪些区别？</h2><p>GET和POST是HTTP协议中两种常用的请求方法，它们有以下区别：</p><ol><li>数据传输方式：<ul><li>GET请求：通过URL参数传递数据，数据附加在URL的查询字符串中，可以在浏览器地址栏中看到。GET请求的数据传输是明文的，不适合传输敏感信息。</li><li>POST请求：通过请求体传递数据，数据不会显示在URL中，对传输的数据进行了加密处理，更适合传输敏感信息。</li></ul></li><li>数据长度限制：<ul><li>GET请求：由于数据附加在URL中，URL长度有限制，不同浏览器和服务器对URL长度的限制不同，通常在2048个字符左右。</li><li>POST请求：没有长度限制，可以传输大量数据。</li></ul></li><li>安全性：<ul><li>GET请求：数据在URL中可见，容易被截获和篡改，不适合传输敏感信息。</li><li>POST请求：数据在请求体中，不会显示在URL中，相对于GET请求更安全。</li></ul></li><li>幂等性：<ul><li>GET请求：对服务器的资源操作是幂等的，即多次请求同一个URL返回的结果是相同的，不会对服务器产生副作用。</li><li>POST请求：对服务器的资源操作可能是非幂等的，多次请求同一个URL可能会产生不同的结果，可能对服务器产生副作用。</li></ul></li><li>缓存：<ul><li>GET请求：可以被浏览器缓存，当再次请求相同URL时，浏览器可以直接从缓存中获取响应结果。</li><li>POST请求：不会被浏览器缓存，每次请求都会向服务器发送请求。</li></ul></li><li>使用场景：<ul><li><strong>GET请求：适合获取资源、查询数据，对于幂等操作和不涉及敏感信息的请求。</strong></li><li><strong>POST请求：适合提交数据、修改资源，对于非幂等操作和涉及敏感信息的请求。</strong></li></ul></li></ol><p>需要根据具体的需求和场景选择合适的请求方法，合理使用GET和POST可以提高系统的性能和安全性。</p><p><strong>假设你在一家餐厅（服务器）点餐（发送请求）。你可以通过两种方式提交你的订单（数据）：</strong></p><ol><li><strong>GET请求比喻</strong>：通过大声告诉服务员（URL）你想要的食物，例如：“我想要一个汉堡和一份薯条。” 这种方式类似于GET请求，因为你的订单（数据）对周围的人来说是可见的，容易被人听到（数据通过URL传递，容易被拦截）。此外，如果你的订单非常长，你可能会因为太多信息而让服务员（服务器）难以记住，或者服务员根本听不过来（URL长度限制）。</li><li><strong>POST请求比喻</strong>：你写下你的订单（数据）在一张纸上，然后递给服务员（HTTP消息体）。这样，你的订单对其他客人来说是不可见的（数据不在URL中，更安全）。同时，你可以在纸上写下尽可能多的特殊要求，因为纸张容纳的信息量远大于你能大声说出的（没有数据大小限制）。</li></ol><h2 id="18-如何避免-SQL注入？"><a href="#18-如何避免-SQL注入？" class="headerlink" title="18.如何避免 SQL注入？"></a>18.如何避免 SQL注入？</h2><h2 id="19-try-catch-finally-中哪个部分可以省略？"><a href="#19-try-catch-finally-中哪个部分可以省略？" class="headerlink" title="19.try-catch-finally 中哪个部分可以省略？"></a>19.try-catch-finally 中哪个部分可以省略？</h2><p>catch可以省略</p><p>原因 :<br>更为严格的说法其实是：try只适合处理运行时异常，try+catch适合处理运行时异常+普通异常。也就是说，如果你只用try去处理普通异常却不加以catch处 理，编译是通不过的，因为编译器硬性规定，普通 异常如果选择捕获，则必须用 catch显示声明以便进一步处理。而运行时异常在编译时没有如此规定， 所以 catch可以省略，你加上catch编译器也觉得无可厚非。 理论上，编译器看任何代码都不顺眼，都觉得可能有潜在的问题，所以你即使对 所有代码加上try，代码 在运行期时也只不过是在正常运行的基础上加一层皮。 但是你一旦对一段代码加上try，就等于显示地承 诺编译器，对这段代码可能抛 出的异常进行捕获而非向上抛出处理。如果是普通异常，编译器要求必须 用 catch捕获以便进一步处理；如果运行时异常，捕获然后丢弃并且+finally扫尾 处理，或者加上catch 捕获以便进一步处理。 至于加上finally，则是在不管有没捕获异常，都要进行的“扫尾”处理。</p><hr><h1 id="第一家：与工厂对接的、20人左右、转正后薪资-4-5k-5k"><a href="#第一家：与工厂对接的、20人左右、转正后薪资-4-5k-5k" class="headerlink" title="第一家：与工厂对接的、20人左右、转正后薪资 4.5k-5k"></a>第一家：与工厂对接的、20人左右、转正后薪资 4.5k-5k</h1><p>问了以下问题：</p><h2 id="1-Spring-与-Spring-Boot-的区別"><a href="#1-Spring-与-Spring-Boot-的区別" class="headerlink" title="1.Spring 与 Spring Boot 的区別"></a>1.Spring 与 Spring Boot 的区別</h2><p>Spring和Spring Boot是两个相关的框架，它们有以下区别：</p><ol><li>复杂性：Spring是一个全功能的企业级开发框架，提供了广泛的功能和组件，如依赖注入、AOP、事务管理、MVC框架等。Spring框架需要进行显式的配置和集成，因此在配置和启动上可能需要更多的工作。而Spring Boot是建立在Spring框架之上的工具，旨在简化Spring应用程序的初始化和开发过程。Spring Boot通过自动配置和约定优于配置的原则，大大减少了开发人员的配置工作，使得快速构建和部署应用变得更加容易。</li><li>配置方式：在Spring中，开发人员需要显式地进行配置，通常使用XML配置文件或Java注解来定义和管理Bean、依赖关系、事务等。而Spring Boot采用了约定优于配置的原则，通过自动配置和默认值，减少了大部分的配置工作。Spring Boot使用基于Java的配置（如注解配置）和属性文件来管理应用程序的配置。</li><li>依赖管理：Spring框架的依赖管理相对灵活，开发人员可以根据需要选择和配置所需的库和组件。而Spring Boot通过提供一组预定义的“Starter”依赖简化了依赖管理。这些Starter依赖包含了常用的库和组件，可以根据应用程序的需求进行选择和引入。</li><li>内嵌服务器：Spring Boot内置了一个嵌入式的Servlet容器（如Tomcat、Jetty等），可以方便地将应用程序打包为可执行的JAR文件，并直接运行。这样可以简化部署过程，不再需要独立安装和配置外部的Servlet容器。</li></ol><p>总的来说，Spring Boot是建立在Spring框架之上的工具，旨在简化Spring应用程序的初始化、配置和部署过程。它通过自动配置、约定优于配置的原则、依赖管理和内嵌服务器等特性，提供了更简单、更快速的开发体验。Spring框架则提供了更多的灵活性和自定义能力，适用于更复杂和定制化的企业级应用开发。</p><p><strong>Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？</strong><br> 启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：<br> <strong>@SpringBootConfiguration</strong>：组合了@Configuration 注解，实现配置文件的功能。<br> <strong>@EnableAutoConfiguration</strong>：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源 自动配置功能：  @SpringBootApplication(exclude &#x3D; { DataSourceAutoConfiguration.class })。 </p><p><strong>@ComponentScan</strong>：Spring组件扫描。</p><h2 id="2-Spring-Bean-的生命周期"><a href="#2-Spring-Bean-的生命周期" class="headerlink" title="2.Spring Bean 的生命周期"></a>2.Spring Bean 的生命周期</h2><p>实例化，属性赋值，初始化，使用，销毁</p><p>在 Spring 框架中，Bean 的生命周期包括以下几个阶段：</p><ol><li>实例化（Instantiation）：在这个阶段，Spring 容器会根据配置信息或注解创建一个 Bean 的实例。可以通过构造函数实例化或使用工厂方法创建 Bean。</li><li>属性赋值（Population）：在实例化之后，Spring 容器会将配置的属性值或依赖注入到 Bean 实例中。这可以通过 XML 配置、注解或自动装配等方式完成。</li><li>初始化（Initialization）：在属性赋值完成后，Spring 容器会调用 Bean 的初始化方法，进行一些自定义的初始化逻辑。可以通过实现 InitializingBean 接口或使用 @PostConstruct 注解来定义初始化方法。</li><li>使用（In Use）：在初始化完成后，Bean 可以被应用程序使用。它可以响应应用程序的请求，提供所需的功能。</li><li>销毁（Destruction）：在应用程序关闭或容器销毁时，Spring 容器会调用 Bean 的销毁方法，执行一些清理操作。可以通过实现 DisposableBean 接口或使用 @PreDestroy 注解来定义销毁方法。</li></ol><p>需要注意的是，Bean 的生命周期可以通过配置或注解进行控制，例如使用 XML 配置的 init-method 和 destroy-method 属性，或使用 @PostConstruct 和 @PreDestroy 注解。</p><p>另外，Spring 还提供了 BeanPostProcessor 接口，它允许在 Bean 的初始化前后进行一些自定义的处理。通过实现 BeanPostProcessor 接口，可以在 Bean 的初始化前后对 Bean 进行修改或增强。</p><p>总结起来，Spring Bean 的生命周期包括实例化、属性赋值、初始化、使用和销毁这几个阶段。通过配置或注解，可以控制 Bean 在每个阶段的行为，并在需要时执行自定义的初始化和销毁逻辑。</p><p>实例化，属性赋值，初始化对象，使用，销毁</p><h2 id="3-Spring-MVC-的执行流程"><a href="#3-Spring-MVC-的执行流程" class="headerlink" title="3.Spring MVC 的执行流程"></a>3.Spring MVC 的执行流程</h2><p>Spring MVC 是一种基于 Spring 框架的 Web 应用程序开发框架，它通过 MVC（Model-View-Controller）的设计模式来组织和处理请求。下面是 Spring MVC 的执行流程：</p><ol><li>客户端发送请求：客户端（如浏览器）发送一个 HTTP 请求到服务器。</li><li>DispatcherServlet 接收请求：DispatcherServlet 是 Spring MVC 的核心控制器，它拦截所有的请求，并作为前端控制器来处理请求。DispatcherServlet 接收到请求后，根据配置的 URL 映射规则将请求分发给相应的处理器。</li><li>处理器映射器（Handler Mapping）进行映射：处理器映射器根据配置的 URL 映射规则，将请求映射到一个具体的处理器（Controller）。</li><li>处理器执行请求：处理器（Controller）是一个用于处理请求的组件，它根据业务逻辑处理请求，并生成一个 ModelAndView 对象，包含处理结果和视图信息。</li><li>处理器适配器（Handler Adapter）执行处理器：处理器适配器负责执行处理器，并将处理结果封装成 ModelAndView 对象。</li><li>视图解析器（View Resolver）解析视图：视图解析器根据 ModelAndView 中的视图名称解析出真正的视图对象（View），可以是 JSP、Thymeleaf、Freemarker 等。</li><li>视图渲染：视图对象负责将模型数据渲染成最终的响应结果，可以是 HTML 页面、JSON 数据等。</li><li>响应结果返回给客户端：DispatcherServlet 将渲染后的响应结果返回给客户端，完成请求处理过程。</li></ol><p>在整个流程中，Spring MVC 提供了一系列的组件来处理请求，包括 DispatcherServlet、处理器映射器、处理器适配器、视图解析器等。通过配置和扩展这些组件，可以实现灵活的请求处理和视图渲染。同时，Spring MVC 还提供了拦截器、数据绑定、表单验证等功能，以支持更复杂的 Web 应用程序开发。</p><h2 id="4-MySQL-的内外连接"><a href="#4-MySQL-的内外连接" class="headerlink" title="4.MySQL 的内外连接"></a>4.MySQL 的内外连接</h2><p>在 MySQL 中，内连接（INNER JOIN）和外连接（LEFT JOIN、RIGHT JOIN、FULL JOIN）是用于连接多个表的操作。</p><ol><li>内连接（INNER JOIN）：内连接返回两个表中匹配的行。只有当连接条件满足时，才会返回结果。语法如下：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列名</span><br><span class="line"><span class="keyword">FROM</span> 表<span class="number">1</span></span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 连接条件;</span><br></pre></td></tr></table></figure><ol><li>左外连接（LEFT JOIN）：左外连接返回左表中的所有行，以及右表中满足连接条件的行。如果右表中没有匹配的行，则以 NULL 值填充。语法如下：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列名</span><br><span class="line"><span class="keyword">FROM</span> 表<span class="number">1</span></span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 连接条件;</span><br></pre></td></tr></table></figure><ol><li>右外连接（RIGHT JOIN）：右外连接返回右表中的所有行，以及左表中满足连接条件的行。如果左表中没有匹配的行，则以 NULL 值填充。语法如下：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列名</span><br><span class="line"><span class="keyword">FROM</span> 表<span class="number">1</span></span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 连接条件;</span><br></pre></td></tr></table></figure><ol><li>全外连接（FULL JOIN）：全外连接返回左表和右表中的所有行，如果左表或右表中没有匹配的行，则以 NULL 值填充。语法如下：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列名</span><br><span class="line"><span class="keyword">FROM</span> 表<span class="number">1</span></span><br><span class="line"><span class="keyword">FULL</span> <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 连接条件;</span><br></pre></td></tr></table></figure><p>在连接条件中，可以使用比较运算符（如 &#x3D;、&lt;、&gt;）或其他逻辑运算符（如 AND、OR）来指定连接条件。</p><p>这些连接操作可以帮助在多个表之间建立关联，并根据连接条件返回合适的结果集。根据业务需求和数据关系，选择适当的连接类型来获取所需的数据。</p><h2 id="5-Redis-是如何使用的，有哪些基本数据类型"><a href="#5-Redis-是如何使用的，有哪些基本数据类型" class="headerlink" title="5.Redis 是如何使用的，有哪些基本数据类型"></a>5.Redis 是如何使用的，有哪些基本数据类型</h2><p>Redis 是一个开源的高性能键值存储系统，常用于缓存、消息队列、实时统计等场景。它支持多种数据结构和数据类型，包括以下基本数据类型：</p><ol><li>字符串（String）：字符串是 Redis 最基本的数据类型，可以存储任意类型的数据，如文本、数字等。字符串类型支持丰富的操作，如设置值、获取值、追加、计数器操作等。</li><li>列表（List）：列表是一个有序的字符串集合，可以在列表的两端进行元素的插入和删除操作。列表类型支持根据索引获取元素、获取列表长度、修剪列表等操作，还提供了一些特殊的操作，如弹出元素、阻塞式弹出等。</li><li>哈希（Hash）：哈希是一个键值对的集合，类似于关联数组。哈希类型适用于存储对象，每个对象可以包含多个字段和对应的值。哈希类型支持设置字段值、获取字段值、获取所有字段和值等操作。</li><li>集合（Set）：集合是一个无序的字符串集合，不允许重复的元素。集合类型支持添加元素、删除元素、判断元素是否存在、计算交集、并集、差集等操作。</li><li>有序集合（Sorted Set）：有序集合是一个有序的字符串集合，每个元素都关联一个分数，用于排序。有序集合类型支持添加元素、删除元素、根据分数范围获取元素、根据分数排序等操作。</li></ol><p>除了以上基本数据类型，Redis 还提供了一些其他的数据结构和数据类型，如位图（Bitmap）、超级日志（HyperLogLog）、地理位置（Geospatial）等，以满足不同场景下的需求。</p><h2 id="6-Nginx-做什么用的"><a href="#6-Nginx-做什么用的" class="headerlink" title="6.Nginx 做什么用的"></a>6.Nginx 做什么用的</h2><h2 id="7-Docker-怎么构建镜像的，怎么push-到仓库"><a href="#7-Docker-怎么构建镜像的，怎么push-到仓库" class="headerlink" title="7.Docker 怎么构建镜像的，怎么push 到仓库"></a>7.Docker 怎么构建镜像的，怎么push 到仓库</h2><ol start="2"><li>你是怎么引入配置的<br> 总结：没有问八股文类 java 基础的问题，视频面试的，面完直接让我去公司谈谈</li></ol><h1 id="第二家：物流仓促（个人觉得也做外包-、全栈、转正后薪资-4k-4-5k"><a href="#第二家：物流仓促（个人觉得也做外包-、全栈、转正后薪资-4k-4-5k" class="headerlink" title="第二家：物流仓促（个人觉得也做外包)、全栈、转正后薪资 4k-4.5k"></a>第二家：物流仓促（个人觉得也做外包)、全栈、转正后薪资 4k-4.5k</h1><p>问了以下问题：</p><h2 id="1-java-中八种数据类型，假如有一个类中有属性为身高，那么使用那种数据类型？"><a href="#1-java-中八种数据类型，假如有一个类中有属性为身高，那么使用那种数据类型？" class="headerlink" title="1.java 中八种数据类型，假如有一个类中有属性为身高，那么使用那种数据类型？"></a>1.java 中八种数据类型，假如有一个类中有属性为身高，那么使用那种数据类型？</h2><p>int,short,long,byte<br>float,double<br>char<br>boolean</p><h2 id="2-有哪几种集合容器，有什么区别，list-和-set-的区别。你怎么看到list-中的有序？"><a href="#2-有哪几种集合容器，有什么区别，list-和-set-的区别。你怎么看到list-中的有序？" class="headerlink" title="2.有哪几种集合容器，有什么区别，list 和 set 的区别。你怎么看到list 中的有序？"></a>2.有哪几种集合容器，有什么区别，list 和 set 的区别。你怎么看到list 中的有序？</h2><p>list,set,map</p><ul><li>list是有序的，允许重复元素，可以插入多个null。</li><li>set是无序的，set不可以重复元素，只允许一个null</li><li>map不是collection的子接口，map可以有任意个null值，但是只允许有一个null键,key不能重复，value可以重复</li></ul><h2 id="3-前端-form-表単怎么提交数据的"><a href="#3-前端-form-表単怎么提交数据的" class="headerlink" title="3.前端 form 表単怎么提交数据的"></a>3.前端 form 表単怎么提交数据的</h2><h2 id="4-Form-传参数怎么传，id-还是-name，后端怎么接收"><a href="#4-Form-传参数怎么传，id-还是-name，后端怎么接收" class="headerlink" title="4.Form 传参数怎么传，id 还是 name，后端怎么接收"></a>4.Form 传参数怎么传，id 还是 name，后端怎么接收</h2><h2 id="5-String-类型的日期，怎么在前段显示为日期（这个我没懂没回答出来）"><a href="#5-String-类型的日期，怎么在前段显示为日期（这个我没懂没回答出来）" class="headerlink" title="5.String 类型的日期，怎么在前段显示为日期（这个我没懂没回答出来）"></a>5.String 类型的日期，怎么在前段显示为日期（这个我没懂没回答出来）</h2><h2 id="6-Mysql的语句考察（语句挺简单的，好久没写我给忘了，没答出来）"><a href="#6-Mysql的语句考察（语句挺简单的，好久没写我给忘了，没答出来）" class="headerlink" title="6.Mysql的语句考察（语句挺简单的，好久没写我给忘了，没答出来）"></a>6.Mysql的语句考察（语句挺简单的，好久没写我给忘了，没答出来）</h2><h2 id="7-前段用的什么东西？"><a href="#7-前段用的什么东西？" class="headerlink" title="7.前段用的什么东西？"></a>7.前段用的什么东西？</h2><h2 id="8-你对框架有什么看法？"><a href="#8-你对框架有什么看法？" class="headerlink" title="8.你对框架有什么看法？"></a>8.你对框架有什么看法？</h2><p>总结：基础问的多，主要在试探会不会开发</p><h1 id="第三家：外包、纯后端、转正后薪资-4-5-5k"><a href="#第三家：外包、纯后端、转正后薪资-4-5-5k" class="headerlink" title="第三家：外包、纯后端、转正后薪资 4.5-5k"></a>第三家：外包、纯后端、转正后薪资 4.5-5k</h1><p>有做题目，String、集合的关系图、有哪些运行中异常、算法、sql语句问了以下问题：</p><h2 id="你对上一个面试者有什么看法？"><a href="#你对上一个面试者有什么看法？" class="headerlink" title="你对上一个面试者有什么看法？"></a>你对上一个面试者有什么看法？</h2><h2 id="Nginx-做什么用的？配置在那个文件，怎么配置的？"><a href="#Nginx-做什么用的？配置在那个文件，怎么配置的？" class="headerlink" title="Nginx 做什么用的？配置在那个文件，怎么配置的？"></a>Nginx 做什么用的？配置在那个文件，怎么配置的？</h2><h2 id="Docker-命令有哪些？"><a href="#Docker-命令有哪些？" class="headerlink" title="Docker 命令有哪些？"></a>Docker 命令有哪些？</h2><h2 id="RabbitMQ、FastDFS、Elasticsearch-是做什么的？"><a href="#RabbitMQ、FastDFS、Elasticsearch-是做什么的？" class="headerlink" title="RabbitMQ、FastDFS、Elasticsearch 是做什么的？"></a>RabbitMQ、FastDFS、Elasticsearch 是做什么的？</h2><h2 id="Git-会不会？"><a href="#Git-会不会？" class="headerlink" title="Git 会不会？"></a>Git 会不会？</h2><h2 id="controller-中都有什么注解"><a href="#controller-中都有什么注解" class="headerlink" title="controller 中都有什么注解"></a>controller 中都有什么注解</h2><p>@RestController,@Controller,@RequestMapping,@PostMapping,@RequestParam,@RequestBody,@PathVariable</p><p>在Spring框架中，尤其是在开发Spring MVC应用时，Controller层使用了多种注解来简化Web应用的开发。这些注解提供了定义请求路由、请求数据处理、响应数据封装等功能。以下是一些常见的与Controller相关的注解：</p><h3 id="Controller"><a href="#Controller" class="headerlink" title="@Controller"></a>@Controller</h3><ul><li><strong>@Controller</strong>：标识一个类为Spring MVC Controller处理器。Spring框架的控制反转（IoC）容器会自动检测使用了此注解的类，并将它们注册为Controller Bean。</li></ul><h3 id="请求映射注解"><a href="#请求映射注解" class="headerlink" title="请求映射注解"></a>请求映射注解</h3><ul><li><strong>@RequestMapping</strong>：用于映射Web请求到具体的处理函数。它可以声明在类或方法上，用于设置请求的URL、HTTP方法等信息。</li><li><strong>@GetMapping</strong>：是@RequestMapping的一个简化版，专门用于处理GET类型的请求。</li><li><strong>@PostMapping</strong>：用于处理POST类型的请求，也是@RequestMapping的简化版。</li><li><strong>@PutMapping</strong>、**@DeleteMapping<strong>、</strong>@PatchMapping**：分别用于处理PUT、DELETE、PATCH类型的HTTP请求。</li></ul><h3 id="请求数据处理注解"><a href="#请求数据处理注解" class="headerlink" title="请求数据处理注解"></a>请求数据处理注解</h3><ul><li><strong>@RequestParam</strong>：用于将请求参数绑定到控制器的方法参数上。</li><li><strong>@PathVariable</strong>：用于将URL中的模板变量绑定到控制器的方法参数上。</li><li><strong>@RequestBody</strong>：用于将HTTP请求的body部分绑定到一个对象上，通常用于处理POST请求的内容。</li><li><strong>@RequestHeader</strong>：用于将请求头信息绑定到控制器的方法参数上。</li></ul><h3 id="响应数据处理注解"><a href="#响应数据处理注解" class="headerlink" title="响应数据处理注解"></a>响应数据处理注解</h3><ul><li><strong>@ResponseBody</strong>：指示方法的返回值应该被直接在响应体中返回，而不是解释为视图名。</li><li><strong>@ResponseStatus</strong>：用于指定方法完成后应该返回的HTTP状态码。</li><li><strong>@RestController</strong>：是@Controller和@ResponseBody的组合注解，用于简化创建RESTful服务的Controller。使用@RestController，所有方法默认都会使用@ResponseBody。</li></ul><h3 id="其他有用的注解"><a href="#其他有用的注解" class="headerlink" title="其他有用的注解"></a>其他有用的注解</h3><ul><li><strong>@ModelAttribute</strong>：用于将方法参数或方法返回值绑定到指定的模型属性上，通常用于表单数据的提交处理。</li><li><strong>@SessionAttributes</strong>：用于在会话中存储模型属性，通常用于跨请求之间共享模型属性。</li><li><strong>@RequestMapping</strong>的变体（如@GetMapping, @PostMapping等）提供了一种便捷的方式来处理特定类型的请求。</li></ul><p>总结：基础和框架都有，很实在</p><h1 id="第四家：不清楚"><a href="#第四家：不清楚" class="headerlink" title="第四家：不清楚"></a>第四家：不清楚</h1><p>有做题目，八股文，抽象类和普通类的区别什么的<br>问了以下问题：</p><h1 id="一、"><a href="#一、" class="headerlink" title="一、"></a>一、</h1><h2 id="1-Spring-的文件上传怎么实现的？"><a href="#1-Spring-的文件上传怎么实现的？" class="headerlink" title="1.Spring 的文件上传怎么实现的？"></a>1.Spring 的文件上传怎么实现的？</h2><p>在Spring框架中，文件上传可以通过多种方式实现，其中最常用的方法是使用Spring的MultipartResolver接口和MultipartFile类。</p><p>以下是文件上传的基本步骤：</p><ol><li>配置MultipartResolver：在Spring配置文件中配置MultipartResolver，用于处理文件上传请求。可以选择使用Spring提供的CommonsMultipartResolver或StandardServletMultipartResolver，具体根据项目所使用的Servlet容器来选择。</li><li>创建文件上传表单：在前端页面中创建一个包含文件上传字段的表单。确保表单的enctype属性设置为”multipart&#x2F;form-data”，以支持文件上传。</li><li>处理文件上传请求：在控制器中处理文件上传请求。可以通过在方法参数中添加MultipartFile类型的参数来接收上传的文件。例如：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">handleFileUpload</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file)</span> &#123;</span><br><span class="line">    <span class="comment">// 文件上传处理逻辑</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;upload-success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>处理上传文件：在处理文件上传的方法中，可以使用MultipartFile对象的方法来获取文件的相关信息和内容。例如，可以使用<code>file.getOriginalFilename()</code>获取原始文件名，使用<code>file.getSize()</code>获取文件大小，使用<code>file.getInputStream()</code>获取文件内容的输入流等。</li><li>保存上传文件：根据业务需求，可以将上传的文件保存到本地文件系统、数据库或其他存储介质中。可以使用Java的IO操作或其他框架（如Apache Commons IO）来实现文件的保存。</li></ol><p>需要注意的是，文件上传可能会涉及到文件大小限制、文件类型限制、文件重命名、文件存储路径等问题。可以通过配置MultipartResolver的属性或在控制器中添加相应的验证逻辑来处理这些问题。</p><p>此外，Spring还提供了更高级的文件上传功能，例如支持同时上传多个文件、限制文件大小、处理文件上传进度等。可以根据具体需求，使用Spring提供的相关类和方法来实现更复杂的文件上传功能。</p><h2 id="2-sql-语句"><a href="#2-sql-语句" class="headerlink" title="2.sql 语句"></a>2.sql 语句</h2><h2 id="3-项目中都有什么包名"><a href="#3-项目中都有什么包名" class="headerlink" title="3.项目中都有什么包名"></a>3.项目中都有什么包名</h2><h2 id="4-controller-中都有什么注解"><a href="#4-controller-中都有什么注解" class="headerlink" title="4.controller 中都有什么注解"></a>4.controller 中都有什么注解</h2><p>@RestController,@Controller,@RequestMapping,@PostMapping,@RequestParam,@RequestBody,@PathVariable</p><h1 id="二、"><a href="#二、" class="headerlink" title="二、"></a>二、</h1><h2 id="1-String-能不能-用-和equals-？"><a href="#1-String-能不能-用-和equals-？" class="headerlink" title="1.String 能不能 用&#x3D;&#x3D;和equals ？"></a>1.String 能不能 用&#x3D;&#x3D;和equals ？</h2><p>String可以用重写后的equals方法,用于进行字符串内容的比较<br>String用&#x3D;&#x3D;比较两对象的内存地址是否相等</p><h2 id="2-技术栈的都问了一边是干什么的？里面有什么用法？"><a href="#2-技术栈的都问了一边是干什么的？里面有什么用法？" class="headerlink" title="2.技术栈的都问了一边是干什么的？里面有什么用法？"></a>2.技术栈的都问了一边是干什么的？里面有什么用法？</h2><h2 id="3-Docker-命令"><a href="#3-Docker-命令" class="headerlink" title="3.Docker 命令"></a>3.Docker 命令</h2><h2 id="4-AJAX-做什么用的"><a href="#4-AJAX-做什么用的" class="headerlink" title="4.AJAX 做什么用的"></a>4.AJAX 做什么用的</h2><h2 id="5-你是怎么引入配置的？"><a href="#5-你是怎么引入配置的？" class="headerlink" title="5.你是怎么引入配置的？"></a>5.你是怎么引入配置的？</h2><h2 id="6-mybatis-中＄和-的区别"><a href="#6-mybatis-中＄和-的区别" class="headerlink" title="6.mybatis 中＄和#的区别"></a>6.mybatis 中＄和#的区别</h2><p>当id&#x3D;1时传进的参数为<br>#{id&#x3D;?}<br>${id&#x3D;1}</p><p>问题</p><h2 id="redis数据类型"><a href="#redis数据类型" class="headerlink" title="redis数据类型"></a>redis数据类型</h2><p>Redis 是一个开源的高性能键值存储系统，常用于缓存、消息队列、实时统计等场景。它支持多种数据结构和数据类型，包括以下基本数据类型：</p><ol><li>字符串（String）：字符串是 Redis 最基本的数据类型，可以存储任意类型的数据，如文本、数字等。字符串类型支持丰富的操作，如设置值、获取值、追加、计数器操作等。</li><li>列表（List）：列表是一个有序的字符串集合，可以在列表的两端进行元素的插入和删除操作。列表类型支持根据索引获取元素、获取列表长度、修剪列表等操作，还提供了一些特殊的操作，如弹出元素、阻塞式弹出等。</li><li>哈希（Hash）：哈希是一个键值对的集合，类似于关联数组。哈希类型适用于存储对象，每个对象可以包含多个字段和对应的值。哈希类型支持设置字段值、获取字段值、获取所有字段和值等操作。</li><li>集合（Set）：集合是一个无序的字符串集合，不允许重复的元素。集合类型支持添加元素、删除元素、判断元素是否存在、计算交集、并集、差集等操作。</li><li>有序集合（Sorted Set）：有序集合是一个有序的字符串集合，每个元素都关联一个分数，用于排序。有序集合类型支持添加元素、删除元素、根据分数范围获取元素、根据分数排序等操作。</li></ol><p>除了以上基本数据类型，Redis 还提供了一些其他的数据结构和数据类型，如位图（Bitmap）、超级日志（HyperLogLog）、地理位置（Geospatial）等，以满足不同场景下的需求。</p><p>使用 Redis，可以通过 Redis 客户端（如 Redis CLI、Redisson、Lettuce 等）或编程语言的 Redis 客户端库来与 Redis 服务器进行交互，执行各种数据操作和命令。通过合理地选择和使用 Redis 的数据类型，可以实现高效的数据存储和处理。</p><h2 id="消息队列的作用——我这里想"><a href="#消息队列的作用——我这里想" class="headerlink" title="消息队列的作用——我这里想"></a>消息队列的作用——我这里想</h2><h2 id="mysql-掌握程度，sql优化"><a href="#mysql-掌握程度，sql优化" class="headerlink" title="mysql 掌握程度，sql优化"></a>mysql 掌握程度，sql优化</h2><h2 id="服务器部署spring项目吗？"><a href="#服务器部署spring项目吗？" class="headerlink" title="服务器部署spring项目吗？"></a>服务器部署spring项目吗？</h2><h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><hr><h1 id="图锐"><a href="#图锐" class="headerlink" title="图锐"></a>图锐</h1><h2 id="1-说一下链表"><a href="#1-说一下链表" class="headerlink" title="1.说一下链表"></a>1.说一下链表</h2><p>和数组是统一等级，LinkedList是链表，且插入和删除有优势，但循环遍历的效率不高</p><h2 id="2-什么是栈"><a href="#2-什么是栈" class="headerlink" title="2.什么是栈"></a>2.什么是栈</h2><p>能从栈顶进行进栈和出栈操作，后进先出</p><h2 id="3-说一下String是什么"><a href="#3-说一下String是什么" class="headerlink" title="3.说一下String是什么"></a>3.说一下String是什么</h2><p>底层是一个char类型的数组，不可继承</p><h2 id="4-String-StringBuffer-和-StringBuilder-的区别是什么"><a href="#4-String-StringBuffer-和-StringBuilder-的区别是什么" class="headerlink" title="4.String StringBuffer 和 StringBuilder 的区别是什么"></a>4.String StringBuffer 和 StringBuilder 的区别是什么</h2><p>StringBuffer对方法加了同步锁，或者对调用方法加了同步锁，线程是安全的<br>StringBuilder是没有对方法加同步锁，线程是不安全的<br>大批量数据单线程用StringBuilder<br>大批量数据多线程用StringBuffer</p><h2 id="5-字符串拼接的方法"><a href="#5-字符串拼接的方法" class="headerlink" title="5.字符串拼接的方法"></a>5.字符串拼接的方法</h2><p>用+进行拼接<br>stringBuffer的方法进行拼接<br>stringBuilder的方法进行拼接</p><h2 id="6-判断String字符串中是否有abc，字符串的截取"><a href="#6-判断String字符串中是否有abc，字符串的截取" class="headerlink" title="6.判断String字符串中是否有abc，字符串的截取"></a>6.判断String字符串中是否有abc，字符串的截取</h2><p>判断是否有abc：string.contains<br>字符串的截取：string.subString</p><h2 id="7-String类中的常用方法："><a href="#7-String类中的常用方法：" class="headerlink" title="7.String类中的常用方法："></a>7.String类中的常用方法：</h2><p>indexOf()：返回指定字符的索引。<br>charAt()：返回指定索引处的字符。<br>replace()：字符串替换。<br>trim()：去除字符串两端空白。<br>split()：分割字符串，返回一个分割后的字符串数组。<br>getBytes()：返回字符串的 byte 类型数组。<br>length()：返回字符串长度。<br>toLowerCase()：将字符串转成小写字母。<br>toUpperCase()：将字符串转成大写字符。<br>substring()：截取字符串。<br>equals()：字符串比较。</p><h1 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h1><p>20</p><h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><p><img src="https://cdn.jsdelivr.us/gh/Asakushen/pic/2024/03/07/46ae60.png" alt="图片说明"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">ReverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//pre指针：用来指向反转后的节点，初始化为null</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">         <span class="comment">//当前节点指针</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//循环迭代</span></span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//Cur_next 节点，永远指向当前节点cur的下一个节点</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">Cur_next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            <span class="comment">//反转的关键：当前的节点指向其前一个节点(注意这不是双向链表，没有前驱指针)</span></span><br><span class="line">            cur.next = pre;</span><br><span class="line">            <span class="comment">//更新pre</span></span><br><span class="line">            pre = cur;</span><br><span class="line">            <span class="comment">//更新当前节点指针</span></span><br><span class="line">            cur = Cur_next ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//为什么返回pre？因为pre是反转之后的头节点</span></span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p><img src="https://cdn.jsdelivr.us/gh/Asakushen/pic/2024/03/07/d50072.png" alt="图片说明"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] MySort (<span class="type">int</span>[] arr) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr.length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        for(int end=arr.length-1; end&gt;0; end--)&#123;//每次选出最大的放到最后，重复；</span></span><br><span class="line"><span class="comment">//            for(int i=0;i&lt;end;i++)&#123;</span></span><br><span class="line"><span class="comment">//                if(arr[i]&gt;arr[i+1])&#123;</span></span><br><span class="line"><span class="comment">//                    swap(arr,i,i+1);</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;arr.length-i-<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    swap(arr,j,j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[]arr,<span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> tmp;</span><br><span class="line">        tmp=arr[i];</span><br><span class="line">        arr[i]=arr[j];</span><br><span class="line">        arr[j]=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*    public static void swap(int[] arr, int i, int j) &#123;</span></span><br><span class="line"><span class="comment">        arr[i] = arr[i] ^ arr[j];</span></span><br><span class="line"><span class="comment">        arr[j] = arr[i] ^ arr[j];</span></span><br><span class="line"><span class="comment">        arr[i] = arr[i] ^ arr[j];</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h2><h3 id="2-说说面向对象的理解"><a href="#2-说说面向对象的理解" class="headerlink" title="2.说说面向对象的理解?"></a>2.说说面向对象的理解?</h3><p><strong>面向过程</strong>：<br>优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式 开发、Linux&#x2F;Unix等一般采用面向过程开发，能是最重要的因素。<br>缺点：没有面向对象易维护、易复用、易扩展<br><strong>面向对象</strong>： 优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系 统，使系统更加灵活、更加易于维护<br>缺点：性能比面向过程低 面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步 一步的实现。</p><p>面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题 的方法。需要什么功能直接使用就可以了，不必去一步一步的实现，至于这个功能是如何实现的，管我们什么事？我们会用就可以了。 面向对象的底层其实还是面向过程，把面向过程抽象成类，然后封装，方便我们使用的就是面向对象了。</p><h3 id="3-java-内存模型"><a href="#3-java-内存模型" class="headerlink" title="3.java 内存模型?"></a>3.java 内存模型?</h3><h3 id="4-垃圾回收的目的"><a href="#4-垃圾回收的目的" class="headerlink" title="4.垃圾回收的目的?"></a>4.垃圾回收的目的?</h3><p>垃圾回收的主要目的是自动管理内存，以减轻程序员的负担，并提高程序的可靠性和性能。以下是垃圾回收的几个目标：</p><ol><li>释放不再使用的内存：垃圾回收器负责检测和回收不再使用的内存空间。当对象不再被引用时，垃圾回收器可以自动将其标记为可回收，并释放其占用的内存。这减少了内存泄漏和内存溢出的风险，确保可用内存供其他对象使用。</li><li>简化内存管理：手动管理内存是一项复杂而容易出错的任务。垃圾回收机制使程序员从手动释放内存的责任中解放出来。程序员不再需要显式地跟踪和释放每个对象的内存，而是可以专注于业务逻辑的实现。这提高了开发效率，并降低了出现内存管理错误的可能性。</li><li>提高程序的可靠性：垃圾回收可以防止一些常见的内存错误，如空指针异常和野指针访问。通过自动检测和清理不再使用的对象，垃圾回收器减少了悬空引用和访问已释放内存的风险，从而提高了程序的稳定性和可靠性。</li><li>优化性能：垃圾回收器可以在运行时选择最佳时间来执行垃圾回收操作。它们通常在应用程序空闲时进行工作，以最小化对应用程序性能的影响。通过自动释放不再使用的内存，垃圾回收器可以减少内存碎片化并提高内存的利用率，从而改善程序的整体性能。</li></ol><p>总的来说，垃圾回收的目的是提供一种自动管理内存的机制，减轻程序员的负担，提高程序的可靠性和性能。它使内存管理变得更简单，减少了内存错误的风险，并优化了程序的执行效率。</p><h3 id="5-什么时候会进行垃圾回收"><a href="#5-什么时候会进行垃圾回收" class="headerlink" title="5.什么时候会进行垃圾回收?"></a>5.什么时候会进行垃圾回收?</h3><p>当对象不再被引用时，垃圾回收器可以自动将其标记为可回收，并释放其占用的内存。</p><h3 id="6-常用那些集合-有什么特点"><a href="#6-常用那些集合-有什么特点" class="headerlink" title="6.常用那些集合?有什么特点?"></a>6.常用那些集合?有什么特点?</h3><ol><li>ArrayList：基于数组实现的动态数组。它可以自动扩容，并支持随机访问元素。特点包括高效的随机访问和尾部插入&#x2F;删除操作，但在中间插入&#x2F;删除元素时效率较低。</li><li>LinkedList：基于链表实现的双向链表。它支持高效的插入&#x2F;删除操作，但访问任意位置的元素需要遍历链表。特点包括高效的插入&#x2F;删除操作，但随机访问的效率较低。</li><li>HashSet：基于哈希表实现的无序集合。它使用哈希函数来存储元素，具有快速的插入&#x2F;删除&#x2F;查找操作。特点包括无序性、不允许重复元素和高效的插入&#x2F;删除&#x2F;查找操作。</li><li>TreeSet：基于红黑树实现的有序集合。它可以按照元素的自然顺序或自定义比较器进行排序，并支持高效的插入&#x2F;删除&#x2F;查找操作。特点包括有序性、不允许重复元素和高效的插入&#x2F;删除&#x2F;查找操作。</li><li>HashMap：基于哈希表实现的无序键值对集合。它使用键的哈希值来存储和查找值，具有快速的插入&#x2F;删除&#x2F;查找操作。特点包括无序性、键唯一性和高效的插入&#x2F;删除&#x2F;查找操作。</li><li>TreeMap：基于红黑树实现的有序键值对集合。它可以按照键的自然顺序或自定义比较器进行排序，并支持高效的插入&#x2F;删除&#x2F;查找操作。特点包括有序性、键唯一性和高效的插入&#x2F;删除&#x2F;查找操作。</li></ol><p>这些集合类型具有不同的特点和适用场景：</p><ul><li>ArrayList 和 LinkedList 适用于需要频繁访问元素的场景。ArrayList 在随机访问和尾部插入&#x2F;删除操作上效率更高，而 LinkedList 在插入&#x2F;删除元素时效率更高。</li><li>HashSet 和 TreeSet 适用于需要<strong>存储唯一元素</strong>的场景。HashSet 提供了快速的插入&#x2F;删除&#x2F;查找操作，但不保证元素的顺序。TreeSet 提供了有序性和更多的检索功能，但插入&#x2F;删除操作稍慢。</li><li>HashMap 和 TreeMap 适用于存储键值对的场景。HashMap 提供了快速的插入&#x2F;删除&#x2F;查找操作，但不保证键的顺序。TreeMap 提供了有序性和更多的检索功能，但插入&#x2F;删除操作稍慢。</li></ul><p>根据具体的需求和性能要求，选择合适的集合类型可以提高程序的效率和可读性。</p><h3 id="7-Map可以存储重复数据么"><a href="#7-Map可以存储重复数据么" class="headerlink" title="7.Map可以存储重复数据么?"></a>7.Map可以存储重复数据么?</h3><p>map的key不能重复，value可以重复</p><h3 id="8-list-集合如何去重"><a href="#8-list-集合如何去重" class="headerlink" title="8.list 集合如何去重?"></a>8.list 集合如何去重?</h3><ol><li>使用Set集合：将List集合转换为Set集合，因为Set集合不允许重复元素，重复元素会被自动去除。可以使用<strong>HashSet</strong>或<strong>TreeSet</strong>来存储去重后的元素，并将List集合中的元素逐个添加到Set集合中。例如：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(list);</span><br><span class="line">List&lt;Integer&gt; deduplicatedList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(set);</span><br></pre></td></tr></table></figure><h3 id="9-Redis工作原理"><a href="#9-Redis工作原理" class="headerlink" title="9.Redis工作原理?"></a>9.Redis工作原理?</h3><ol><li>redis的五中基本数据类型： 答：string、hash、set、zset、list。<br>string,set,zset,list,hash</li></ol><h3 id="10-Redis如何优化登录流程-目的是什么-达到什么效果"><a href="#10-Redis如何优化登录流程-目的是什么-达到什么效果" class="headerlink" title="10.Redis如何优化登录流程?目的是什么? 达到什么效果?"></a>10.Redis如何优化登录流程?目的是什么? 达到什么效果?</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="MySQL怎么映射"><a href="#MySQL怎么映射" class="headerlink" title="MySQL怎么映射"></a>MySQL怎么映射</h3><ol><li>手动映射：最简单的方式是手动编写代码来处理数据表和对象之间的映射关系。通过使用SQL语句执行查询和更新操作，并将结果映射到对象的属性上，可以实现手动的数据映射。这种方式需要开发人员自行编写映射逻辑，比较灵活，但也需要更多的代码开发工作。</li><li>ORM框架：ORM（对象关系映射）框架可以自动处理数据表和对象之间的映射关系，提供了一种更高级的映射方式。在MySQL中，有一些常用的ORM框架可供选择，如Hibernate、Spring Data JPA、Sequelize等。这些框架提供了一套API和配置方式，可以简化数据库操作，并自动将数据表映射到对象上。</li><li>注解：一些ORM框架允许使用注解（Annotation）来标记对象和数据表之间的映射关系。通过在对象的属性或方法上添加注解，可以指定对应的数据表字段名、关联关系等信息，框架会根据注解来自动进行映射。这种方式可以在代码中直观地表示映射关系，减少了配置文件的使用。</li><li>XML配置：一些ORM框架使用XML配置文件来定义对象和数据表之间的映射关系。通过在配置文件中指定对象和数据表的对应关系、字段映射规则等信息，框架可以根据配置文件来进行映射。这种方式适用于需要更灵活配置的场景，但相对来说配置较为繁琐。</li></ol><h3 id="SpringBoot的工作原理"><a href="#SpringBoot的工作原理" class="headerlink" title="SpringBoot的工作原理"></a>SpringBoot的工作原理</h3><ol><li>自动配置：Spring Boot通过自动配置机制来简化应用程序的配置。它根据应用程序的依赖和类路径上的资源，自动配置Spring框架的各个模块和组件。例如，它会根据类路径上的数据库驱动依赖自动配置数据源和JPA，根据类路径上的Web依赖自动配置Web服务器和Servlet容器等。自动配置可以减少开发人员的配置工作，提高开发效率。</li><li>起步依赖：Spring Boot使用起步依赖（Starter Dependencies）来简化依赖管理。起步依赖是一组预配置的依赖项集合，它们提供了常见场景下所需的依赖，例如Web应用程序、数据库访问、安全性等。通过引入适当的起步依赖，开发人员可以轻松地获取所需的功能和依赖，而不需要手动配置和管理各个依赖项。</li><li>内嵌服务器：Spring Boot支持内嵌服务器，可以将应用程序打包为可执行的JAR文件，并直接运行在内嵌的Web服务器中，如Tomcat、Jetty等。这样可以简化应用程序的部署和运行，不需要额外安装和配置外部的Web服务器。</li><li>约定优于配置：Spring Boot遵循约定优于配置的原则，通过一些默认的约定来减少配置。例如，它会根据类路径上的资源和注解自动扫描组件，并进行相应的自动配置。开发人员只需要按照一些约定来编写代码和组织项目结构，就能够获得一些默认的配置和行为。</li><li>外部化配置：Spring Boot支持外部化配置，可以将应用程序的配置信息放在外部的配置文件中，如application.properties或application.yml。通过使用这些配置文件，开发人员可以在不修改代码的情况下修改应用程序的配置，例如数据库连接信息、日志级别等。</li><li>Actuator：Spring Boot提供了Actuator模块，用于监控和管理应用程序。Actuator可以提供有关应用程序运行状况、健康状况、性能指标等方面的信息，可以通过HTTP接口或JMX进行访问。通过Actuator，开发人员可以方便地监控和管理应用程序。</li></ol><h2 id="什么是事务的隔离级别？MySQL的默认隔离级别是什么？"><a href="#什么是事务的隔离级别？MySQL的默认隔离级别是什么？" class="headerlink" title="什么是事务的隔离级别？MySQL的默认隔离级别是什么？"></a>什么是事务的隔离级别？MySQL的默认隔离级别是什么？</h2><p>为了达到事务的四大特性，数据库定义了4种不同的事务隔离级别，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏读、 不可重复读、幻读这几类问题。<br><img src="https://cdn.jsdelivr.us/gh/Asakushen/pic/2024/03/07/4d0073.png" alt="image-20230817175317428"></p><p>SQL 标准定义了四个隔离级别：<br><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，可能会导 致脏读、幻读或不可重复读。<br><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读 或不可重复读仍有可能发生。 <strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务 自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。<br><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执 行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。<br>这里需要注意的是：Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle默认采用的 READ_COMMITTED隔离级别<br>事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是MVVC（多版本并发控制），通过 保存修改的旧版本信息来支持并发一致性读和回滚等特性。<br>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是READ-COMMITTED(读 取提交内容):，但是你要知道的是InnoDB 存储引擎默认使用 REPEATABLE-READ（可重读）并不会有 任何性能损失。<br>InnoDB 存储引擎在 分布式事务 的情况下一般会用到SERIALIZABLE(可串行化)隔离级别。  </p><h2 id="String、StringBuffer、StringBuilder区别？"><a href="#String、StringBuffer、StringBuilder区别？" class="headerlink" title="String、StringBuffer、StringBuilder区别？"></a>String、StringBuffer、StringBuilder区别？</h2><ol><li><p>不可变性：</p><ul><li>String类是不可变的，即一旦创建了String对象，就不能修改它的值。每次对String对象进行修改时，都会创建一个新的String对象。</li><li>StringBuffer和StringBuilder类是可变的，可以对其进行修改和操作，而不会创建新的对象。</li></ul></li><li><p>线程安全性：</p><ul><li>String类是线程安全的，可以在多线程环境下共享和操作String对象。</li><li>StringBuffer类是线程安全的，提供了同步方法，可以在多线程环境下安全地进行字符串操作。</li><li>StringBuilder类不是线程安全的，不提供同步方法，适用于单线程环境下的字符串操作。</li></ul></li><li><p>性能：</p><ul><li>由于String类的不可变性，每次对String对象进行修改都会创建一个新的对象，频繁的字符串拼接操作会导致大量的对象创建和内存开销。</li><li>StringBuffer类在进行字符串操作时，会在原有对象的基础上进行修改，避免了对象的频繁创建，因此在字符串拼接操作较多或需要线程安全时，使用StringBuffer会更高效。</li><li>StringBuilder类与StringBuffer类类似，但不提供同步方法，因此在单线程环境下，StringBuilder的性能比StringBuffer稍高。</li></ul><h1 id="Redis-了解穿透，击穿，雪崩现象及其解决方案"><a href="#Redis-了解穿透，击穿，雪崩现象及其解决方案" class="headerlink" title="Redis.了解穿透，击穿，雪崩现象及其解决方案"></a>Redis.了解穿透，击穿，雪崩现象及其解决方案</h1><h3 id="1-Redis-穿透（Cache-Penetration）"><a href="#1-Redis-穿透（Cache-Penetration）" class="headerlink" title="1. Redis 穿透（Cache Penetration）"></a>1. Redis 穿透（Cache Penetration）</h3><p><strong>现象：</strong> 当一个请求查询一个不存在于缓存中的数据时，每次请求都会直接访问数据库，这可能导致数据库负载过高。</p><p><strong>原因：</strong> 请求查询的数据不存在于缓存中，但却在数据库中也不存在。</p><p><strong>解决方案：</strong></p><ul><li><strong>布隆过滤器（Bloom Filter）：</strong> 在请求到达缓存之前，使用布隆过滤器快速地判断查询的数据是否存在于数据库中，如果不存在，则直接返回，避免对数据库的查询。</li><li><strong>缓存空对象：</strong> 在缓存中存储那些不存在于数据库中的数据的键，但是值为空对象，这样可以防止针对同一无效数据的重复查询。</li></ul><h3 id="2-Redis-击穿（Cache-Breakdown）"><a href="#2-Redis-击穿（Cache-Breakdown）" class="headerlink" title="2. Redis 击穿（Cache Breakdown）"></a>2. Redis 击穿（Cache Breakdown）</h3><p><strong>现象：</strong> 在一个高并发的场景下，某个缓存失效时，大量的请求同时涌入，导致请求直接击穿到数据库上，造成数据库压力激增。</p><p><strong>原因：</strong> 缓存中某个热门数据过期后，大量的请求同时访问数据库。</p><p><strong>解决方案：</strong></p><ul><li><strong>互斥锁（Mutex Lock）：</strong> 在查询缓存失效时，使用互斥锁来保护对数据库的访问，只允许一个线程查询数据库，其他线程等待查询结果。</li><li><strong>预先加载（Preloading）：</strong> 在缓存失效前，提前加载该数据的新值到缓存中，或者设置较短但有一定冗余的过期时间，以减少缓存失效时的并发请求。</li></ul><h3 id="3-Redis-雪崩（Cache-Avalanche）"><a href="#3-Redis-雪崩（Cache-Avalanche）" class="headerlink" title="3. Redis 雪崩（Cache Avalanche）"></a>3. Redis 雪崩（Cache Avalanche）</h3><p><strong>现象：</strong> 在某个时间点，大量的缓存同时失效，导致大量请求涌入数据库，造成数据库瞬时压力过大。</p><p><strong>原因：</strong> 缓存中的大量数据在同一时间段内过期失效，导致大量请求同时涌入数据库。</p><p><strong>解决方案：</strong></p><ul><li><strong>分布式部署：</strong> 将缓存服务器进行分布式部署，使得不同缓存的失效时间不一致，减少因缓存同时失效而引发雪崩效应的概率。</li><li><strong>缓存失效时间随机化：</strong> 对缓存的失效时间进行随机化设置，使得缓存失效的时间分布更加均匀，减少集中失效的可能性。</li><li><strong>热点数据永不过期：</strong> 对于一些热点数据，设置其永不过期，或者采用异步更新的方式来更新热点数据，避免热点数据的集中失效。</li></ul><h1 id="1-基本数据类型（Primitive-Data-Types）："><a href="#1-基本数据类型（Primitive-Data-Types）：" class="headerlink" title="1. 基本数据类型（Primitive Data Types）："></a>1. 基本数据类型（Primitive Data Types）：</h1><p>Java 中的基本数据类型包括以下八种：</p><ol><li><strong>byte：</strong> 8 位，有符号，范围为 -128 到 127。</li><li><strong>short：</strong> 16 位，有符号，范围为 -32768 到 32767。</li><li><strong>int：</strong> 32 位，有符号，范围为 -2^31 到 2^31-1。</li><li><strong>long：</strong> 64 位，有符号，范围为 -2^63 到 2^63-1。</li><li><strong>float：</strong> 32 位，单精度浮点数。</li><li><strong>double：</strong> 64 位，双精度浮点数。</li><li><strong>char：</strong> 16 位，Unicode 字符。</li><li><strong>boolean：</strong> 表示逻辑值的类型，只有两个取值：true 和 false。</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-JDK和JRE-有什么区别？&quot;&gt;&lt;a href=&quot;#1-JDK和JRE-有什么区别？&quot; class=&quot;headerlink&quot; title=&quot;1.JDK和JRE 有什么区别？&quot;&gt;&lt;/a&gt;1.JDK和JRE 有什么区别？&lt;/h2&gt;&lt;p&gt;jvm是java虚拟机。JR</summary>
      
    
    
    
    
    <category term="-面试" scheme="https://xu-zi-kang.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>【docker】自动清理阿里云盘缓存</title>
    <link href="https://xu-zi-kang.github.io/2024/01/23/%E3%80%90docker%E3%80%91%E8%87%AA%E5%8A%A8%E6%B8%85%E7%90%86%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98%E7%BC%93%E5%AD%98/"/>
    <id>https://xu-zi-kang.github.io/2024/01/23/%E3%80%90docker%E3%80%91%E8%87%AA%E5%8A%A8%E6%B8%85%E7%90%86%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98%E7%BC%93%E5%AD%98/</id>
    <published>2024-01-23T08:40:49.000Z</published>
    <updated>2024-03-16T04:18:20.791Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">模式0：每天自动清理一次。如果系统重启需要手动重新运行或把命令加入系统启动。</span><br><span class="line">bash -c <span class="string">&quot;<span class="subst">$(curl -s https://xiaoyahelper.zngle.cf/aliyun_clear.sh | tail -n +2)</span>&quot;</span> -s 0 -tg</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">模式1：一次性清理，一般用于测试效果。</span><br><span class="line">bash -c <span class="string">&quot;<span class="subst">$(curl -s https://xiaoyahelper.zngle.cf/aliyun_clear.sh | tail -n +2)</span>&quot;</span> -s 1 -tg</span><br></pre></td></tr></table></figure><h4 id="模式2：已废弃，不再支持"><a href="#模式2：已废弃，不再支持" class="headerlink" title="模式2：已废弃，不再支持"></a><del>模式2：已废弃，不再支持</del></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">模式3：创建一个名为 xiaoyakeeper 的docker定时运行小雅转存清理并升级小雅镜像</span><br><span class="line">bash -c <span class="string">&quot;<span class="subst">$(curl -s https://xiaoyahelper.zngle.cf/aliyun_clear.sh | tail -n +2)</span>&quot;</span> -s 3 -tg</span><br></pre></td></tr></table></figure><p><del>模式4：同模式3</del></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">模式5：与模式3的区别是实时清理，只要产生了播放缓存一分钟内立即清理。签到和定时升级同模式3</span><br><span class="line">bash -c <span class="string">&quot;<span class="subst">$(curl -s https://xiaoyahelper.zngle.cf/aliyun_clear.sh | tail -n +2)</span>&quot;</span> -s 5 -tg</span><br></pre></td></tr></table></figure><h3 id="推荐模式3和模式5"><a href="#推荐模式3和模式5" class="headerlink" title="推荐模式3和模式5"></a>推荐模式3和模式5</h3><p> <em><strong>*发送验证码说明：*</strong></em></p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以等待20秒，即自动跳过此部分，不影响正常使用。</span><br><span class="line">需要发送验证码的可以TG自行查找：xiaoyahelper_bot</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;</summary>
      
    
    
    
    
    <category term="-docker" scheme="https://xu-zi-kang.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>【git】完美解决git报错</title>
    <link href="https://xu-zi-kang.github.io/2024/01/23/%E3%80%90git%E3%80%91%E5%AE%8C%E7%BE%8E%E8%A7%A3%E5%86%B3git%E6%8A%A5%E9%94%99/"/>
    <id>https://xu-zi-kang.github.io/2024/01/23/%E3%80%90git%E3%80%91%E5%AE%8C%E7%BE%8E%E8%A7%A3%E5%86%B3git%E6%8A%A5%E9%94%99/</id>
    <published>2024-01-23T08:37:50.000Z</published>
    <updated>2024-03-16T04:16:46.854Z</updated>
    
    <content type="html"><![CDATA[<h1 id="完美解决-git报错fatal-unable-to-access-‘https-github-com-git‘-Recv-failure-Connection-was-reset"><a href="#完美解决-git报错fatal-unable-to-access-‘https-github-com-git‘-Recv-failure-Connection-was-reset" class="headerlink" title="完美解决 git报错fatal: unable to access ‘https://github.com/.../.git‘:Recv failure Connection was reset"></a>完美解决 git报错fatal: unable to access ‘<a href="https://github.com/.../.git%E2%80%98:Recv">https://github.com/.../.git‘:Recv</a> failure Connection was reset</h1><p>在使用git时，经常会碰到这个错误：fatal: unable to access ‘<a href="https://github.com/.../.git':Recv">https://github.com/.../.git&#39;:Recv</a> failure Connection was reset。</p><p>结合我个人最近的使用经验，提供两个方法，亲测有效。</p><p>方法一<br>该方法也是最常见的方法，那就是在终端执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset http.proxy </span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>本人之前在使用git时，有些时候使用方法一就能解决问题，有些时候还是会报错，下面这个方法，能够完美地解决报错。</p><p><a href="https://so.csdn.net/so/search?q=%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE&spm=1001.2101.3001.7020">系统设置</a>搜索代理，然后点击编辑按钮：<br><img src="https://cdn.jsdelivr.us/gh/Asakushen/pic/2024/03/07/3e80db.png" alt="在这里插入图片描述"></p><p>打开<a href="https://so.csdn.net/so/search?q=%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8&spm=1001.2101.3001.7020">代理服务器</a>，端口设置为<code>7890</code>，这个对你正常上网没有影响，可以放心设置。然后点击保存。</p><p><img src="https://cdn.jsdelivr.us/gh/Asakushen/pic/2024/03/07/2723b2.png" alt="在这里插入图片描述"></p><p>然后在终端输入命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy http://127.0.0.1:7890</span><br></pre></td></tr></table></figure><p>这样就大功告成了。可以在终端输入<code>git config --global -l</code>加以检验是否设置成功：</p><p><img src="https://cdn.jsdelivr.us/gh/Asakushen/pic/2024/03/07/41c5b9.png" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;完美解决-git报错fatal-unable-to-access-‘https-github-com-git‘-Recv-failure-Connection-was-reset&quot;&gt;&lt;a href=&quot;#完美解决-git报错fatal-unable-to-acces</summary>
      
    
    
    
    
    <category term="-git" scheme="https://xu-zi-kang.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>【git】生成sshKey密匙</title>
    <link href="https://xu-zi-kang.github.io/2024/01/23/%E3%80%90git%E3%80%91%E7%94%9F%E6%88%90sshKey%E5%AF%86%E5%8C%99/"/>
    <id>https://xu-zi-kang.github.io/2024/01/23/%E3%80%90git%E3%80%91%E7%94%9F%E6%88%90sshKey%E5%AF%86%E5%8C%99/</id>
    <published>2024-01-23T07:24:08.000Z</published>
    <updated>2024-03-16T04:17:10.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="3-1-生成ssh-key"><a href="#3-1-生成ssh-key" class="headerlink" title="3-1 生成ssh key"></a>3-1 生成ssh key</h2><p>首先检查是否已生成密钥 <code>cd ~/.ssh</code>，ls如果有2个文件，则密钥已经生成，id_rsa.pub就是公钥</p><p><img src="https://cdn.jsdelivr.usn/gh/Asakushen/pic/2024/03/07/ff7e40.png" alt="img"></p><p>也可以打开我的电脑C:\Users\Y\ .ssh 里面找到</p><p><img src="https://cdn.jsdelivr.usn/gh/Asakushen/pic/2024/03/07/57c7b6.png" alt="img"></p><p>如果没有生成，那么通过$ ssh-keygen -t rsa -C “<a href="mailto:&#120;&#120;&#120;&#120;&#120;&#x78;&#x40;&#49;&#x36;&#51;&#46;&#x63;&#111;&#109;">&#120;&#120;&#120;&#120;&#120;&#x78;&#x40;&#49;&#x36;&#51;&#46;&#x63;&#111;&#109;</a>”来生成。</p><p>1）是路径确认，直接按回车存默认路径即可</p><p>2）直接回车键，这里我们不使用密码进行登录, 用密码太麻烦;</p><p>3）直接回车键</p><p><img src="https://cdn.jsdelivr.usn/gh/Asakushen/pic/2024/03/07/440b62.png" alt="img"></p><p>生成成功后，去对应目录C:\Users\Y\ .ssh里（Y为电脑用户名，每个人不同）用记事本打开id_rsa.pub，得到ssh key公钥</p><p><img src="https://cdn.jsdelivr.usn/gh/Asakushen/pic/2024/03/07/c6ea3b.png" alt="img"></p><h2 id="3-2-为github账号配置ssh-key"><a href="#3-2-为github账号配置ssh-key" class="headerlink" title="3-2 为github账号配置ssh key"></a>3-2 为github账号配置ssh key</h2><p>切换到github，展开个人头像的小三角，点击settings</p><p><img src="https://cdn.jsdelivr.usn/gh/Asakushen/pic/2024/03/07/b6e5e3.png" alt="img"></p><p>然后打开SSH keys菜单， 点击Add SSH key新增密钥，填上标题，跟仓库保持一致吧，好区分。</p><p>接着将id_rsa.pub文件中key粘贴到此，最后Add key生成密钥吧。</p><p><img src="https://cdn.jsdelivr.usn/gh/Asakushen/pic/2024/03/07/d2a30c.png" alt="img"></p><p>如此，github账号的SSH keys配置完成。</p><p><img src="https://cdn.jsdelivr.usn/gh/Asakushen/pic/2024/03/07/44fb32.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;3-1-生成ssh-key&quot;&gt;&lt;a href=&quot;#3-1-生成ssh-key&quot; class=&quot;headerlink&quot; title=&quot;3-1 生成ssh key&quot;&gt;&lt;/a&gt;3-1 生成ssh key&lt;/h2&gt;&lt;p&gt;首先检查是否已生成密钥 &lt;code&gt;cd ~/.ss</summary>
      
    
    
    
    
    <category term="-git" scheme="https://xu-zi-kang.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>黃明志Ft.</title>
    <link href="https://xu-zi-kang.github.io/2024/01/23/%E9%BB%83%E6%98%8E%E5%BF%97Ft-%E3%80%90%E6%B5%8B%E8%AF%95%E5%A4%96%E9%93%BE%E6%8E%A5%E3%80%91/"/>
    <id>https://xu-zi-kang.github.io/2024/01/23/%E9%BB%83%E6%98%8E%E5%BF%97Ft-%E3%80%90%E6%B5%8B%E8%AF%95%E5%A4%96%E9%93%BE%E6%8E%A5%E3%80%91/</id>
    <published>2024-01-23T06:39:59.000Z</published>
    <updated>2024-03-07T08:49:50.601Z</updated>
    
    <content type="html"><![CDATA[<iframe width="560" height="315" src="https://www.youtube.com/embed/a1T2FVLP29M?si=2OfjjcLBpZqtYIUj" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe><h1 id="黃明志-测试外链接【不小心-I-Shot-You】-亞洲通才-2020-Asian-Polymath"><a href="#黃明志-测试外链接【不小心-I-Shot-You】-亞洲通才-2020-Asian-Polymath" class="headerlink" title="黃明志 &amp; 测试外链接【不小心 I Shot You】@亞洲通才 2020 Asian Polymath"></a>黃明志 &amp; 测试外链接【不小心 I Shot You】@亞洲通才 2020 Asian Polymath</h1><iframe width="560" height="315" src="https://www.youtube.com/embed/wl1JHpRox_8?si=xWVcb-gJB-5YxPjr" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>]]></content>
    
    
      
      
    <summary type="html">&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/a1T2FVLP29M?si=2OfjjcLBpZqtYIUj&quot; title=&quot;YouTube video player&quot; frameborde</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【docker】Portainer-docker图形化工具</title>
    <link href="https://xu-zi-kang.github.io/2024/01/21/%E3%80%90docker%E3%80%91Portainer-docker%E5%9B%BE%E5%BD%A2%E5%8C%96%E5%B7%A5%E5%85%B7/"/>
    <id>https://xu-zi-kang.github.io/2024/01/21/%E3%80%90docker%E3%80%91Portainer-docker%E5%9B%BE%E5%BD%A2%E5%8C%96%E5%B7%A5%E5%85%B7/</id>
    <published>2024-01-21T12:07:14.000Z</published>
    <updated>2024-03-16T04:19:07.699Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-图形化工具-Portaine"><a href="#Docker-图形化工具-Portaine" class="headerlink" title="Docker 图形化工具 Portaine"></a>Docker 图形化工具 Portaine</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">之前操作Docker的时候，一直使用的是命令行的形式。命令行虽说看起来挺炫酷，但有时候还是挺麻烦的。今天给大家推荐一个Docker图形化工具[Portainer]，轻量级又好用，希望对大家有所帮助！</span><br></pre></td></tr></table></figure><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Portainer 是一款轻量级的应用，它提供了图形化界面，用于方便地管理Docker环境，包括单机环境和集群环境。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote><p>直接使用Docker来安装Portainer是非常方便的，仅需要两步即可完成。</p></blockquote><ul><li>首先下载Portainer的Docker镜像；</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull portainer/portainer</span><br></pre></td></tr></table></figure><ul><li>然后再使用如下命令运行Portainer容器；</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 9000:9000 -p 8000:8000 --name portainer \</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--restart=always \</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-v /mydata/portainer/data:/data \</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-d portainer/portainer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure><ul><li><p>第一次登录的时候需要创建管理员账号，访问地址：<a href="http://ip:9000/">http://ip:9000/</a></p><p><img src="https://cdn.jsdelivr.us/gh/Asakushen/pic/2024/03/07/ae0433.png" alt="img"></p></li></ul><p>吊炸天的 Docker 图形化工具 Portainer，必须推荐给你</p><ul><li>之后我们选择连接到本地的Docker环境，连接完成后我们就可以愉快地使用Portainer进行可视化管理了！</li><li><img src="https://cdn.jsdelivr.us/gh/Asakushen/pic/2024/03/07/a25f59.png" alt="img"></li></ul><p>吊炸天的 Docker 图形化工具 Portainer，必须推荐给你</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li>登录成功后，可以发现有一个本地的Docker环境；</li><li><img src="https://cdn.jsdelivr.us/gh/Asakushen/pic/2024/03/07/f2b7c1.png" alt="img"></li></ul><p>吊炸天的 Docker 图形化工具 Portainer，必须推荐给你</p><ul><li>打开Dashboard菜单可以看到Docker环境的概览信息，比如运行了几个容器，有多少个镜像等；</li><li><img src="https://cdn.jsdelivr.us/gh/Asakushen/pic/2024/03/07/255c89.png" alt="img"></li></ul><p>吊炸天的 Docker 图形化工具 Portainer，必须推荐给你</p><ul><li>打开App Templates菜单可以看到很多创建容器的模板，通过模板设置下即可轻松创建容器，支持的应用还是挺多的；</li><li><img src="https://cdn.jsdelivr.us/gh/Asakushen/pic/2024/03/07/ebc1fa.png" alt="img"></li></ul><p>吊炸天的 Docker 图形化工具 Portainer，必须推荐给你</p><ul><li>打开Containers菜单，可以看到当前创建的容器，我们可以对容器进行运行、暂停、删除等操作；</li><li><img src="https://cdn.jsdelivr.us/gh/Asakushen/pic/2024/03/07/b945bb.png" alt="img"></li></ul><p>吊炸天的 Docker 图形化工具 Portainer，必须推荐给你</p><ul><li>选择一个容器，点击Logs按钮，可以直接查看容器运行日志，可以和docker logs命令说再见了；</li></ul><p><img src="https://cdn.jsdelivr.us/gh/Asakushen/pic/2024/03/07/2e803b.png" alt="img"></p><ul><li>点击Inspect按钮，可以查看容器信息，比如看看容器运行的IP地址；</li><li><img src="https://cdn.jsdelivr.us/gh/Asakushen/pic/2024/03/07/3723a4.png" alt="img"></li></ul><p>吊炸天的 Docker 图形化工具 Portainer，必须推荐给你</p><ul><li>点击Stats按钮，可以查看容器的内存、CPU及网络的使用情况，性能分析不愁了；</li><li><img src="https://cdn.jsdelivr.us/gh/Asakushen/pic/2024/03/07/02d48b.png" alt="img"></li></ul><p>吊炸天的 Docker 图形化工具 Portainer，必须推荐给你</p><ul><li>点击Console按钮，可以进入到容器中去执行命令，比如我们可以进入到MySQL容器中去执行登录命令；</li></ul><p><img src="https://cdn.jsdelivr.us/gh/Asakushen/pic/2024/03/07/a50d7c.png" alt="img"></p><ul><li>打开Images菜单，我们可以查看所有的本地镜像，对镜像进行管理；</li><li><img src="https://cdn.jsdelivr.us/gh/Asakushen/pic/2024/03/07/41c616.png" alt="img"></li></ul><p>吊炸天的 Docker 图形化工具 Portainer，必须推荐给你</p><ul><li>打开Networks菜单，可以查看Docker环境中的网络情况；</li><li><img src="https://cdn.jsdelivr.us/gh/Asakushen/pic/2024/03/07/425bac.png" alt="img"></li></ul><p>吊炸天的 Docker 图形化工具 Portainer，必须推荐给你</p><ul><li>打开Users菜单，我们可以创建Portainer的用户，并给他们赋予相应的角色；</li></ul><p><img src="https://cdn.jsdelivr.us/gh/Asakushen/pic/2024/03/07/b6fce6.png" alt="img"></p><ul><li>打开Registries菜单，我们可以配置自己的镜像仓库，这样在拉取镜像的时候，就可以选择从自己的镜像仓库拉取了。</li><li><img src="https://cdn.jsdelivr.us/gh/Asakushen/pic/2024/03/07/d146ca.png" alt="img"></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Portainer作为一款轻量级Docker图形化管理工具，功能强大且实用，要是有个私有镜像仓库管理功能就更好了，这样我们就不用安装重量级的镜像仓库<a href="https://so.csdn.net/so/search?q=Harbor&spm=1001.2101.3001.7020">Harbor</a>了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Docker-图形化工具-Portaine&quot;&gt;&lt;a href=&quot;#Docker-图形化工具-Portaine&quot; class=&quot;headerlink&quot; title=&quot;Docker 图形化工具 Portaine&quot;&gt;&lt;/a&gt;Docker 图形化工具 Portaine&lt;/</summary>
      
    
    
    
    
    <category term="-docker" scheme="https://xu-zi-kang.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>【hexo】hexo报错解决办法</title>
    <link href="https://xu-zi-kang.github.io/2024/01/12/%E3%80%90hexo%E3%80%91hexo%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>https://xu-zi-kang.github.io/2024/01/12/%E3%80%90hexo%E3%80%91hexo%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</id>
    <published>2024-01-12T10:30:40.000Z</published>
    <updated>2024-03-16T04:16:19.769Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hexo发生error：spawn-failed错误的解决方法"><a href="#hexo发生error：spawn-failed错误的解决方法" class="headerlink" title="hexo发生error：spawn failed错误的解决方法"></a>hexo发生error：spawn failed错误的解决方法</h1><h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><ul><li>先是出现错误：<br><code>error：spawn failed...</code></li><li>然后经过一些博客的操作会出现以下问题：<br><code>fatal: cannot lock ref &#39;HEAD&#39;: unable to resolve reference HEAD: Invalid argument error: src refspec</code></li><li>或者：<br><code>error: src refspec HEAD does not match any.</code>等等</li><li>总结一下：<br>问题大多是因为git 进行push或者hexo d的时候改变了一些.deploy_git文件下的内容。</li></ul><h3 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h3><p>1.删除<code>.deploy_git</code>文件夹;<br>2.输入<code>git config --global core.autocrlf false</code><br>3，然后，依次执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>问题解决。暴力直接，有效。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;hexo发生error：spawn-failed错误的解决方法&quot;&gt;&lt;a href=&quot;#hexo发生error：spawn-failed错误的解决方法&quot; class=&quot;headerlink&quot; title=&quot;hexo发生error：spawn failed错误的解决方</summary>
      
    
    
    
    
    <category term="-hexo" scheme="https://xu-zi-kang.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
